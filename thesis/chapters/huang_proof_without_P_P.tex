\chapter{Interpolant extraction from resolution proofs in two phases}
\label{sec:two_phases}
\label{chap:two_phases}

In \cite{Huang95}, Huang proposes an algorithm for computing interpolants of two disjoint sets of first-order formulas $\Gamma$ and $\Delta$, where $\Gamma\cup\Delta$ is unsatisfiable, by traversing a resolution refutation of $\Gamma \cup \Delta$.
We present his proof in a modified form in this section and in a form closer to \cite{Huang95} in Appendix~\ref{sec:huang}.
The central difference between these versions lies in the treatment of the interplay of substitutions and liftings.
While in \cite{Huang95}, propositional deductions are employed, in which all substitutions are trivial,
we provide a method which allows for commuting substitutions and liftings under certain conditions.

\section{Layout of the proof}

The underlying algorithm produces in a first phase propositional interpolants inductively for every clause which occurs in the resolution refutation.
These interpolants are propositional in the sense that they only obey the language restriction on predicates and may contain colored terms.
The propositional interpolant assigned to the last clause, the empty clause, is a propositional interpolant for the initial clause sets.

The second phase of the algorithm addresses the colored terms still contained in the propositional interpolant.
These are eliminated (lifted) by replacing them with bound variables whose quantifiers are subject to a certain ordering.



\section{Extraction of propositional interpolants}

We define a procedure $\PI$, which produces propositional interpolants from resolution refutations and is based on the ``Interpolation algorithm'' in \cite{Huang95}.
It is structured in the two subprocedures $\PIinit$ and $\PIstep$:

\begin{defi}[$\PIinit$]
	For clauses $C \in \Gamma\cup\Delta$, we define $\PIinit(C)$ as follows:

	\[\PIinit(C) \defeq
	\begin{cases}
		\bot & \text{ if $C \in \Gamma$} \\
		\top & \text{ if $C \in \Delta$}  
	\end{cases}
	\qedhere
\]
\end{defi}

\begin{defi}[$\PIstep$]
	Let $\inference$ be an inference of a resolution refutation of $\Gamma\cup\Delta$ which derives $C$ from the clauses $C_1, \dots, C_n$ where $n=1$ if $\inference$ is a factorisation inference and $n=2$ in case of a resolution or paramodulation inference. 
	Let $\bar I = I_1, \dots, I_n$ be formulas.

	Then $\PIstep(\inference, \bar I)$ is defined according to the following cases:

	\begin{indproof}
		\indproofitem{Resolution}
		\label{def:PI_resolution}
			If $\inference$ is a resolution inference of $C_1: D \lor l$ and $C_2: E \lor \lnot l'$ with $\sigma = \mgu(\inference)$, then $\PIstep(\inference, I_1, I_2)$ is defined as follows:
			%$\PI(C)$ is defined according to this case distinction:
			\begin{enumerate}
				\item If $l$ is $\Gamma$-colored: 
					$\PIstep(\inference, I_1, I_2) \defeq{} [I_1 \lor I_2]\sigma$
				\item If $l$ is $\Delta$-colored: 
					$\PIstep(\inference, I_1, I_2) \defeq{} [I_1 \land I_2]\sigma$
				\item If $l$ is grey: 
					$\PIstep(\inference, I_1, I_2) \defeq{} [(l \land I_2) \lor (\lnot l' \land I_1) ]\sigma $
			\end{enumerate}

			\indproofitem{Factorisation}
			If $\inference$ is a factorisation inference of $C_1: l \lor l' \lor D$ with $\sigma = \mgu(\inference)$,
			then $\PIstep(\inference, I_1) \defeq I_1\sigma$.

		\indproofitem{Paramodulation}
			\label{def:PI_paramod}
			Suppose that $\inference$ is a paramodulation inference of $C_1: s=t \lor D$ and $C_2: E\occuratp{r}$ 
			with $\sigma = \mgu(\inference)$ such that $s\sigma = r\sigma$.
			Let $h\occur{r}$ be the maximal colored term\footnote{Cf.\ Definition~\ref{def:coloring} for a definition of the notion of maximal colored terms.} in which $r$ occurs in $E\occuratp{r}$.
			Then $\PIstep(\inference, I_1, I_2)$ is defined according to the following case distinction:

			\begin{enumerate}
				\item If $h\occur{r}$ is $\Delta$-colored and $h\occur{r}$ occurs more than once in $(I_2 \lor E\occuratp{r})\sigma$: %\newline
					\label{def:PI_paramod_1}
					$\PIstep(\inference, I_1, I_2) \defeq{} [ ( s=t \land I_2 ) \lor (s\neq t \land I_1) ]\sigma \lor (s=t \land h\occur{s} \neq h\occur{t})\sigma$
				\item If $h\occur{r}$ is $\Gamma$-colored and $h\occur{r}$ occurs more than once in $(I_2 \lor E\occuratp{r})\sigma$:
					%\newline
					\label{def:PI_paramod_2}
					$\PIstep(\inference, I_1, I_2) \defeq{} [ ( s=t \land I_2 ) \lor (s\neq t \land I_1) ]\sigma \land (s\neq t \lor h\occur{s} = h\occur{t})\sigma$
				\item If $r$ does not occur in a colored term in $E\occuratp{r}$ which occurs more than once in\nolinebreak{} $(I_2 \lor E\occuratp{r})\sigma$:
					\label{def:PI_paramod_3}
					\newline
					$\PIstep(\inference, I_1, I_2) \defeq{} [ ( s=t \land I_2 ) \lor (s\neq t \land I_1) ]\sigma$
					\qedhere

			\end{enumerate}
	\end{indproof}
\end{defi}



\begin{defi}[Propositional interpolant extraction $\PI$]
	\label{def:PI}
	Let $\pi$ be a resolution refutation of $\Gamma \cup \Delta$.
	\defiemph{${\PI(\pi)}$} is defined to be $\PI(\square)$, where $\square$ is the empty clause derived in $\pi$.
	For a clause $C$ in $\pi$, \defiemph{$\PI(C)$} is defined as follows:
	\begin{indproof}
		\indproofitem{Base case}
			If $C \in \Gamma\cup\Delta$, then $\PI(C) \defeq \PIinit(C)$.
		\indproofitem{Induction step}
			If $C$ is the result of an inference $\inference$ using the clauses $C_1, \dots, C_n$, then $\PI(C) \defeq \PIstep(\inference, \PI(C_1), \dots, \PI(C_n))$.
			\qedhere
	\end{indproof}
\end{defi}

For an illustration of the application of $\PI$ to a resolution refuation, see Example~\ref{exa:two_phase}

\begin{remark}
	The control flow of the procedure $\PI$ is predominantly determined by the coloring of literals.
	In this context, two distinct but similar interpretations of the notion of color are viable: 
	On the one hand, one can employ the usual, symbol-based interpretation as given in Definition~\ref{def:coloring}, where a (predicate) symbol is considered grey if there is at least one formula in $\Gamma$ as well as at least one formula in $\Delta$ which contain the symbol, and otherwise the symbol is considered to be colored in the respective color. 
	Note that this does not necessarily capture the logical meaning of the symbol, as the symbol then is allowed to occur in the interpolant even if among the clauses used in the resolution refutation, only for instance clauses from $\Gamma$ contain the symbol.
	It is obvious that one can then also find an interpolant which does not contain the symbol by computing an interpolant for $\Gamma'$ and $\Delta$, where $\Gamma'$ is derived from $\Gamma$ by omitting any formula containing that symbol. 
	Clearly the refutation of $\Gamma \cup \Delta$ is also a refutation of $\Gamma' \cup \Delta$ and an appropriate interpolant can hence easily be computed.

	However in \cite{Huang95}, a stricter notion of coloring is employed.
	There, a predicate symbol is colored based on its occurrence:
	All occurrences of predicate symbols in formulas in $\Gamma$ ($\Delta$) are considered to be $\Gamma$-($\Delta$-)colored.
	A predicate symbol occurring in a clause in the resolution derivation is $\Phi$-colored if its predecessor in the preceding clause is.
	Factorisation inferences create grey literals in case the factorised literals are respectively $\Gamma$- and $\Delta$-colored.

	The definition above can be understood in this sense by only considering a minor adaption:
	Resolved or factorised literals $l$ are to be read as $\Gamma$-($\Delta$-)colored only if \emph{both} resolved or factorised literals $l$ and $l'$ in fact are $\Gamma$-($\Delta$-)colored and otherwise to be treated as grey. 
	This is necessitated by the fact that in our definition, we may conclude from the circumstance that two resolved or factorised literals have the same predicate symbol that they also do possess the same coloring.
	In the definition due to \cite{Huang95}, this is in general not the case.
\end{remark}


\section{Lifting of colored symbols}
\label{sec:lifting}
As $\PI$ only fixes the propositional structure of the interpolant but still contains colored symbols, 
we define a procedure which replaces colored terms by variables, which eventually will become bound by appropriate quantifiers.
This replacement is referred to as lifting:


\begin{defi}[Lifting]
\newcommand{\colterm}[1]{s_{#1}}
Let $\varphi$ a formula or a term and $\colterm{1}, \dotsc, \colterm{n}$ the $\Phi$-terms which have a maximal $\Phi$-colored occurrence in $\varphi$.

	Let furthermore $z_{\expa(\colterm{1})}, \ldots, z_{\expa(\colterm{n})}$ be fresh variables, referred to as \defiemph{$\Phi$-lifting variables} or \defiemph{lifting variables} if the coloring is clear from the context.

	We first define the function $\expa$, which replaces lifting variables occurring in colored terms by the term they lift in order to avoid lifting variables in the index of other lifting variables and is defined as follows for terms $t$:
	\medskip

	%\vspace{-\bigskipamount}
	\begin{adjustwidth}{-1em}{}
	%\[
		\noindent $
		\expa(t) \defeq \begin{cases}
			t & \text{if $t$ is a constant $c$} \\
			t & \text{if $t$ is a non-lifting variable $x$} \\
			f(\expa(t_1),\dots, \expa(t_m)) & \text{if $t=f(t_1, \dots, t_m)$} \\
			\expa(s) & \text{if $t$ is a lifting variable $z_s$}
	\end{cases}
	$
%\]
	\end{adjustwidth}
	\medskip

	The \defiemph{lifting} of the formula or term $\varphi$, denoted by $\lifphi{\varphi}$, is an abbreviation for 
	$\lifphi{\varphi, Z}$ where $Z = \{ \colterm{1}, \dotsc, \colterm{n} \}$.
		$\lifphi{\varphi, Z}$ is defined as follows:
	\[
		\lifphi{\varphi, Z} \defeq
		\begin{cases}
			\varphi & \text{if $Z = \emptyset$} \\
			%\lifphi{\varphi\abstractionOp{\colterm{i}/z_{\colterm{i}}}, Z\setminus\{\colterm{i}\}} & \parbox[t]{0.4\linewidth}{$\colterm{i} \in Z$ such that $\colterm{i}$ is not subterm of another term in $Z$} \\
			\lifphi{\psi, Z\setminus\{\colterm{i}\}} & \parbox[t]{0.622\linewidth}{if $\colterm{i} \in Z$  and $\psi$ is created from $\varphi$ by replacing every occurrence of $\colterm{i}$ by $z_{\expa(\colterm{i})}$} 
		\end{cases}
	\]
	To simplify the syntax, we sometimes write $\lifphinovar{\varphi}$ or $\lifboth{\varphi}$ if the lifting variables or the lifting variables and the color of the terms to lift are clear from the context or not of essence.
	%	We denote $\varphi$ lifted of both $\Gamma$- and $\Delta$-terms by $\lifboth{\varphi}$ if the variables replacing the colored terms are clear from the context or are not crucial.
\end{defi}

We usually lift $\Delta$-terms by variables with the letter $x$ and $\Gamma$-terms with the letter\nolinebreak{} $y$. If the lifting is not specific to a color, we use variables with the letter\nolinebreak{} $z$.
In order to illustrate this definition, we present a examples:

\begin{exa}
	Let $f$ and $a$ be $\Gamma$-colored, $g$ and $b$ be $\Delta$-colored and $h$ be grey.
	\begin{enumerate}
		\item
			Consider the lifting of the $\Gamma$-terms of the formula $P(a, h(g(a)), f(b, x))$:
			\begin{align*}
				& \lifgamma{ P(a, h(g(a)), f(b, x)) } = \\
		 & \lifgamma{ P(a, h(g(a)), f(b, x)), \{a, f(b, x)\} } = \\
		 & \lifgamma{ P(y_{\expa(a)}, h(g(y_{\expa(a)})), f(b, x)), \{f(b, x)\} } = \\
		& \lifgamma{ P(y_a, h(g(y_a)), f(b, x)), \{f(b, x)\} } = \\
		& \lifgamma{ P(y_a, h(g(y_a)), y_{\expa(f(b,\,x))}), \emptyset } = \\
		& \lifgamma{ P(y_a, h(g(y_a)), y_{f(b,\,x)}), \emptyset } = \\
		& P(y_a, h(g(y_a)), y_{f(b,\,x)})
			\end{align*}

		\item
			By lifting the $\Delta$-terms of $P(y_a, h(g(y_a)), y_{f(b,\,x)})$, we witness the application of the function $\expa$:
			\begin{align*}
				& \lifdelta{ P(y_a, h(g(y_a)), y_{f(b,\,x)}) } = \\
			& \lifdelta{ P(y_a, h(g(y_a)), y_{f(b,\,x)}), \{g(y_a)\} } = \\
		 & \lifdelta{P(y_a, h(x_{\expa(g(y_a))}), y_{f(b,\,x)}), \emptyset } = \\
		 & \lifdelta{P(y_a, h(x_{g(a)}), y_{f(b,\,x)}), \emptyset } = \\
		 & P(y_a, h(x_{g(a)}), y_{f(b,\,x)})
			\qedhere
			\end{align*}
	\end{enumerate}
\end{exa}

Some elementary properties of liftings are described by the following lemmas:


\begin{lemma}[Commutativity of lifting and logical operators]
	\label{lemma:lift_logic_commute}
	Let $A$ and $B$ be first-order formulas and $s$ and $t$ be terms. Then it holds that:
	\begin{enumerate}
		\item $\lift{\Phi}{\lnot A}{z} \spas\semiff{} \lnot \lift{\Phi}{A}{z}$
		\item $\lift{\Phi}{A \circ B}{z} \spas\semiff{} ( \lift{\Phi}{A}{z} \circ \lift{\Phi}{B}{z} )$ for $\circ \in \{\land, \lor\}$
		\item $\lift{\Phi}{s = t}{z} \spas\semiff{} ( \lift{\Phi}{s}{z} = \lift{\Phi}{t}{z} )$
			\hfill\lemmaqed
	\end{enumerate}
\end{lemma}


We furthermore require a means for commuting substitutions and liftings.
This however can not be achieved in a direct manner. The following examples illustrate
that in general for a term $t$, it is not the case that
$
\lifphi{t\sigma} =
\lifphi{t}\sigma 
$.

Below, we assume that substitutions unless explicitly defined otherwise do not affect lifting variables.
This is justified as all substitutions which occur in resolution refutations have this property.

\begin{exa}
	\label{exa:lifting_commute}
	~
	\begin{enumerate}
		\item
			\label{exa:lifting_commute_1}
			Let $t = f(x)$ be a $\Phi$-term and $\sigma = \{x \mapsto a\}$.
			Then $\lifphi{t\sigma} = \lifphi{f(x)\sigma} = \lifphi{f(a)} = z_{f(a)}$.
			However $\lifphi{t}\sigma = \lifphi{f(x)}\sigma = z_{f(x)}\sigma = z_{f(x)}$.

			This suggests that substitutions also have to be applied to lifted terms.

		\item
			\label{exa:lifting_commute_2}
			Let $s=x$ be a variable and $\sigma = \{x\mapsto c\}$, where $c$ is a $\Phi$-term.
			Then $\lifphi{s\sigma} = 
			\lifphi{x\sigma} =
			\lifphi{c} = z_c$.
			But 
			$\lifphi{s}\sigma = 
			\lifphi{x}\sigma = 
			x\sigma = 
			c$.

			In this case, we see that terms in $\ran(\sigma)$ have to be lifted when the substitution is pulled out of the lifting.

		\item
			\label{exa:lifting_commute_3}
			Let $r = \lifphi{f(x)} = z_{f(x)}$ and $\sigma = \{x\mapsto a\}$.
			Then $\lifphi{r\sigma} = \lifphi{z_{f(x)}\sigma} = \lifphi{z_{f(x)}} = z_{f(x)}$.
			Here however, $\lifphi{r}\sigma = \lifphi{z_{f(x)}}\sigma = z_{f(x)}\sigma = z_{f(x)}$.

			This shows that obviously, as lifting variables are affected neither by substitutions nor liftings, arbitrary commutations of these can be performed. 
			Note however that in case~\ref{exa:lifting_commute_1}, lifting variables have to be modified.
			\qedhere
	\end{enumerate}
\end{exa}

As a first step towards a solution, we define a substitution which acts as a tool to ensure that modifications to terms are also applied to lifting variables.
This is vital for Item~\ref{exa:lifting_commute_1} of Example~\ref{exa:lifting_commute}.

\begin{defi}[$\tau$]
	For a substitution $\sigma$ we define the infinite substitution $\tau(\sigma)$ with $\dom(\tau(\sigma)) = \dom(\sigma) \cup \{z_s \mid s\sigma \neq s\}$ as follows for a variable $x$:

	\[
		x\tau(\sigma) =
		\begin{cases}
			x\sigma & \text{$x$ is a non-lifting variable} \\
			z_{t\sigma} & \text{$x$ is a lifting variable $z_t$}
		\end{cases} 
	\]
	%\qedhere

	If the substitution $\sigma$ is clear from the context, we abbreviate $\tau(\sigma)$ by $\tau$. 
	For inferences $\inference$, we define $\tau(\inference)$ to be $\tau(\mgu(\inference))$.
\end{defi}

\addtocounter{exa}{-2}
\begin{exa}[continued]
	Using $\tau(\sigma)$, we can solve the first example as $\lifphi{t\tau(\sigma)} = \lifphi{f(x)\tau(\sigma)} = \lifphi{f(a)} = z_{f(a)} = z_{f(x)\sigma} = z_{f(x)}\tau(\sigma) = \lifphi{f(x)}\tau(\sigma) = \lifphi{t}\tau(\sigma)$.
	However the second example can not be dealt with analogously.
\end{exa}
\addtocounter{exa}{1}

Now we implement the idea motivated by Item~\ref{exa:lifting_commute_2} of Example~\ref{exa:lifting_commute} by lifting also the terms introduced by $\tau$.
It turns out that in this formulation, commutation can be done in general:


%\begin{exa}
%
%	Let $\sigma = \{x \mapsto a\}$
%	and consider the terms $f(x)$ and $f(a)$, where $f$ and $a$ are colored symbols.
%	Clearly $f(x)\sigma = f(a)$ and therefore necessarily $z_{f(x)}\tau = z_{f(a)}$.
%
%	But now consider $z_{f(x)} \sigma$.
%	As $z_{f(x)}$ is a lifting variable, $z_{f(x)} \not\in \dom(\sigma)$ as $\sigma$ is a unifier from a resolution derivation inference.
%	Hence $z_{f(x)}\sigma = z_{f(x)}$ and therefore $\lifboth{z_{f(x)}\sigma} = \lifboth{z_{f(x)}} = z_{f(x)}$, but $\lifboth{z_{f(x)}}\tau = z_{f(x)}\tau = z_{f(a)}$.
%	So $\lifboth{z_{f(x)}\sigma} \neq \lifboth{z_{f(x)}}\tau$.
%\end{exa}
\begin{lemma}
	\label{lemma:lifting_tau_commute}
	For a formula or term $\varphi$ and a substitution $\sigma$ such that $\tau = \tau(\sigma)$,
	$\lifboth{\lifboth{ \varphi} \tau} =\nolinebreak \lifboth{ \varphi \tau } $.
\end{lemma}
\begin{proof}
	We proceed by induction.

	\begin{itemize}
		\item Suppose that $t$ is a grey constant or function symbol of the form $f(t_1, \dots, t_n)$.
			Then we can derive the following, where (IH) signifies a deduction by virtue of the induction hypothesis. 
			\begin{align*}
				\lifboth{\lifboth{t}\tau} &= \lifboth{\lifboth{ f(t_1, \dots, t_n)}\tau} \\
																													&= \lifboth{ f(\lifboth{t_1}\tau, \dots, \lifboth{t_n}\tau) } \\
																											&= f(\lifboth{\lifboth{t_1}\tau}, \dots, \lifboth{\lifboth{t_n}\tau}) \\
																									&\stackrel{\mathclap{\text{(IH)}}}= f(\lifboth{t_1\tau}, \dots, \lifboth{t_n\tau}) \\
																							&= \lifboth{f(t_1, \dots, t_n)\tau} \\
																					 &= \lifboth{t\tau}
			\end{align*}
		\item Suppose that $t$ is a colored constant or function symbol. Then:
			\[
				\lifboth{\lifboth{t}\tau}= \lifboth{z_t\tau} 
				= \lifboth{z_{t\sigma}} 
				= z_{t\sigma} 
				= z_t\tau
				= \lifboth{t\tau}
			\]
		\item Suppose that $t$ is a variable $x$. Then:
			\[
				\lifboth{\lifboth{t}\tau} = \lifboth{\lifboth{ x}\tau} = \lifboth{x\tau} = \lifboth{t\tau}
			\]
		\item Suppose that $t$ is a lifting variable $z_t$. Then:
			\[
				\lifboth{\lifboth{z_t}\tau} = \lifboth{z_t\tau} 
				\qedhere
			\]
	\end{itemize}

\end{proof}

The formulation of this Lemma can however be improved.
First, note that the outer lifting of the expression $\lifboth{\lifboth{\varphi}\tau}$ is only applied to terms introduced by $\tau$, which motivates the following definition:

\begin{defi}[$\tauellphi$]
	For a substitution $\sigma$, we define the infinite substitution $\tauellphi(\sigma)$ on variables $x$ as follows: 
	$x\tauellphi(\sigma) \spas\defeq \lifphinovar{x\tau(\sigma)}$.

	If $\sigma$ is clear from the context, we just write $\tauellphi$ and as usual, we may also omit\nolinebreak{} $\Phi$.
\end{defi}



\begin{lemma}
	\label{lemma:lifting_tau_commute_2}
	For a formula or term $\varphi$,
	$\lifboth{\varphi}\tauell = \lifboth{\varphi\tau}$.
\end{lemma}
\begin{proof}
	Immediate by Lemma~\ref{lemma:lifting_tau_commute} and the definition of $\tauell$.
\end{proof}

Second, if we can exclude the case of lifting variables, we can apply $\sigma$ as desired:
\begin{lemma}
	\label{lemma:lifting_subst_commute}
	For a formula or term $\psi$ and a substitution $\sigma$, such that no lifting variable occurs in $\psi$ or $\ran(\sigma)$,
	$\lifboth{\psi}\tauell = \lifboth{\psi\sigma}$.
\end{lemma}
\begin{proof}
	Immediate by \ref{lemma:lifting_tau_commute_2} and the definition of $\tau$.
\end{proof}

Note that if the formula or term contains lifting variables,
it is not possible to perform the commutation with $\sigma$ as in Lemma~\ref{lemma:lifting_subst_commute}.
As illustrated in Item~\ref{exa:lifting_commute_3} of Example~\ref{exa:lifting_commute},
we here have that $\lifphi{z_t\sigma} = \lifphi{z_t} = z_t$, but $\lifphi{z_t\tauell} = \lifphi{z_{{t\sigma}}} = z_{{t\sigma}}$
Hence in these cases, $\tauell$ would have to leave lifting variables unchanged, which contradicts other use cases such as Item ~\ref{exa:lifting_commute_1} of Example~\ref{exa:lifting_commute}.

However in the context of interpolant extraction, one can deal with interpolants containing free occurrences of lifting variables by just employing $\tau$ in their construction instead of $\sigma$.



\begin{comment}
	\begin{lemma}
		Let $s$ and $t$ be terms such that no $x_i$ occurs in them, $\Phi$ a set of formulas and $M$ a model.
		Then $M\entails \lft{\Phi}{x}{s} = \lft{\Phi}{x}{t}$ implies that $M\entails s=t$.
		\label{lemma:lift_equality}
	\end{lemma}
	\begin{proof}
		Suppose no $\Delta$-term occurs in $s$ or $t$. Then $\lft{\Phi}{x}{s} = s$ 
		and $\lft{\Phi}{x}{t} = t$.

		Otherwise let $t_i$ be a maximal $\Delta$-term in $s$. Suppose it occurs at position $p$. In $\lft{\Phi}{x}{s}$, it is replaced by $x_i$.
		But as $M \entails \lft{\Phi}{x}{s} = \lft{\Phi}{x}{t}$, two situations can arise:
		\begin{compactenum}
		\item $x_i$ occurs at $p$ in $\lft{\Phi}{x}{t}$.
			As $x_i$ does not occur in $t$, it is placed there by the lifting.
			But $x_i$ is only employed in order to replace $t_i$, so at position $p$ in $t$, we have $t_i$.
		\item A term $r$ occurs at $p$ in $\lft{\Phi}{x}{t}$ which does not influence the evaluation of $\lft{\Phi}{x}{t}$ in $M$. This can be the case if $r$ is contained in a subterm of $u$ and in $M$, the function symbol of $u$ is interpreted such that it does not depend on the argument that contains $r$.

			But as the maximal $\Delta$-term $t_i$ occurs in $s$ at $p$ and $M \entails \lft{\Phi}{x}{s} = \lft{\Phi}{x}{t}$, there is a function symbol $u'$ in $\lft{\Phi}{x}{s}$ corresponding to $u$ which also does not depend on this argument.

			Hence even though $s$ and $t$ are not syntactically equal, $M\entails s=t$ in this case. \qedhere
		\end{compactenum}

	\end{proof}
\end{comment}



\section{Main lemma}
\label{sec:two_phase_main_lemma}

By lifting symbols of one color of the propositional interpolant, we are able to already obtain a formula partially fulfilling the requirements for interpolants.
The proof is separated into parts dealing with $\PIinit$ and $\PIstep$ respectively to be later combined to a result for\nolinebreak{} $\PI$.

We employ the following additional notation: For a clause $C$, $C_\Phi$ denotes the clause created from $C$ by removing all literals which are not $\Phi$-colored.

\begin{lemma}
	\label{lemma:gamma_entails_init}
	Let $C$ be an clause in $\Gamma \cup \Delta$ 
	Then $\Gamma \entails \lifdelta{\PIinit(C) \lor\nolinebreak C_\Gamma}$.
\end{lemma}
\begin{proof}
	If $C \in \Gamma$, then $\Gamma \entails \lifdelta{C_\Gamma}$ as $C_\Gamma = C$ and $\lifdelta{C} = C$.
	Otherwise $C \in \Gamma$, but then $\PIinit(C) =\nolinebreak{} \top$.
\end{proof}



\begin{lemma}
	\label{lemma:gamma_entails_step}
	Let $\inference$ be an inference in a resolution refutation of $\Gamma \cup \Delta$ using the clauses $C_1, \dots, C_n$
	and let $\bar I = I_1, \dots, I_n$ be formulas such that 
	$\Gamma \entails \lifdelta{I_i \lor\nolinebreak (C_i)_\Gamma} $ for $1 \varleq i \varleq n$.
	Then
	$\Gamma \entails \lifdelta{\PIstep(\inference, \bar I) \lor\nolinebreak C_\Gamma} $.
\end{lemma}
\begin{proof}
	We distinguish based on the type of $\inference$.
	\begin{indproof}
		\indproofitem{Resolution}
			Suppose that $\inference$ is a resolution inference of the clauses $C_1: D \lor l$ and $C_2: E \lor \lnot l'$ with $\sigma = \mgu(\inference)$.

			By Lemma~\ref{lemma:lift_logic_commute} we obtain from the assumption that
			$\Gamma \entails \lifdelta{I_1} \lor \lifdelta{D_\Gamma} \lor \lifdelta{l_\Gamma}$
			as well as 
			$\Gamma \entails \lifdelta{I_2} \lor \lifdelta{E_\Gamma} \lor \lnot \lifdelta{l'_\Gamma}$.
			Now we apply $\tauelldelta$ and by Lemma~\ref{lemma:lifting_subst_commute} get that:

			$\Gamma \stackrel\markA\entails \lifdelta{I_1\sigma} \lor \lifdelta{D_\Gamma\sigma} \lor \lifdelta{l_\Gamma\sigma}$

			$\Gamma \stackrel\markB\entails \lifdelta{I_2\sigma} \lor \lifdelta{E_\Gamma\sigma} \lor \lnot \lifdelta{l'_\Gamma\sigma}$

			As $l_\Gamma\sigma \syneq l'_\Gamma\sigma$,
			we also have that
			$\lifdelta{l_\Gamma\sigma} = \lifdelta{l'_\Gamma\sigma}$.
			We proceed by a case distinction on the color of the resolved literal to show that in each case, we have that
			$\Gamma \entails \lifdelta{\PIstep(\inference, \bar I)} \lor \lifdelta{C_\Gamma}$,
			which by Lemma~\ref{lemma:lift_logic_commute} suffices for the result.
			\begin{enumerate}
				\item Suppose that $l$ is $\Gamma$-colored.
					Then $l_\Gamma = l$ and $l'_\Gamma = l$, and we can perform a resolution step on \markA{} and \markB{} to obtain that
					$\Gamma \entails
					\lifdelta{I_1\sigma} \lor
					\lifdelta{I_2\sigma} \lor 
					\lifdelta{D_\Gamma\sigma}  \lor
					\lifdelta{E_\Gamma\sigma}$.
					This however is nothing else than $\Gamma \entails \lifdelta{\PIstep(\inference, \bar I)} \lor \lifdelta{C_\Gamma}$.

				\item Suppose that $l$ is $\Delta$-colored.
					Then \markA{} and \markB{} reduce to 
					$\Gamma \entails \lifdelta{I_1\sigma} \lor \lifdelta{D_\Gamma\sigma}$
					and
					$\Gamma \entails \lifdelta{I_2\sigma} \lor \lifdelta{E_\Gamma\sigma}$
					respectively,
					which clearly implies that 
					$\Gamma \entails \left(\lifdelta{I_1\sigma} \land \lifdelta{I_2\sigma}\right) \lor \lifdelta{D_\Gamma\sigma} \lor \lifdelta{E_\Gamma\sigma}$.
					This is turn is however just the unfolding of the definition of
					$\Gamma \entails \lifdelta{\PIstep(\inference, \bar I)} \lor \lifdelta{C_\Gamma}$.

				\item Suppose that $l$ is grey.
					Then $l_\Gamma = l$ and $l'_\Gamma = l$.
					Suppose that for a model $M$ of $\Gamma$ that $M \notentails \lifdelta{E_\Gamma\sigma}$ and $M \notentails \lifdelta{D_\Gamma\sigma}$.
					Then as $\lifdelta{l_\Gamma \sigma} = \lifdelta{l'_\Gamma\sigma}$, by \markA{} and \markB{}, depending on the truth value of $\lifdelta{l_\Gamma \sigma}$ in $M$, we have that either $M \entails \lifdelta{l_\Gamma\sigma} \land \lifdelta{I_2\sigma}$ or $M \entails \lnot\lifdelta{l'_\Gamma\sigma} \land \lifdelta{I_1\sigma}$ holds.
					Hence altogether we obtain that 
					$\Gamma \entails
					\lifdelta{D_\Gamma\sigma} \spam\lor
					\lifdelta{E_\Gamma\sigma} \spam\lor\allowbreak
					(\lifdelta{l_\Gamma\sigma} \land \lifdelta{I_2\sigma}) \spam\lor\allowbreak
					(\lnot\lifdelta{l'_\Gamma\sigma} \land \lifdelta{I_1\sigma})$.
					But this is equivalent to
					$\Gamma \entails \lifdelta{\PIstep(\inference, \bar I)} \lor \lifdelta{C_\Gamma}$.

			\end{enumerate}


			\indproofitem{Factorisation}
			Suppose the clause $C$ is the result of a factorisation inference $\inference$ of $C_1: l \lor l' \lor D$ with $\sigma=\mgu(\inference)$.

			By Lemma~\ref{lemma:lift_logic_commute}, the induction hypothesis gives $\Gamma \entails \lifdelta{ I_1 } \lor \lifdelta{ l_\Gamma} \lor \lifdelta{l'_\Gamma} \lor \lifdelta{D_\Gamma }$.
			Now we apply $\tauelldelta$
			and by Lemma~\ref{lemma:lifting_subst_commute}, obtain that 
			$\Gamma \entails \lifdelta{ I_1\sigma } \lor \lifdelta{ l_\Gamma\sigma } \lor  \lifdelta{l'_\Gamma\sigma} \lor \lifdelta{D_\Gamma\sigma }$.
			As however $l\sigma \syneq l'\sigma$, 
			also $\lifboth{l\sigma} = \lifboth{l'\sigma}$, so we can apply a factorisation step and obtain that
			$\Gamma \entails \lifdelta{ I_1\sigma } \lor \lifdelta{ l_\Gamma\sigma} \lor \lifdelta{D_\Gamma\sigma }$,
			which by Lemma~\ref{lemma:lift_logic_commute} is nothing else than $\Gamma \entails \PIstep(\inference, \bar I) \lor \lifdelta{C_\Gamma}$.

		\indproofitem{Paramodulation}
			Suppose the clause $C$ is the result of a paramodulation inference\nolinebreak{} $\inference$ of $C_1: s=t \lor D$ and $C_2: E\occatp{r}$ with $\sigma=\mgu(\inference)$.

			By the induction hypothesis and Lemma~\ref{lemma:lift_logic_commute}, we obtain the following: 

			$\Gamma \stackrel\markA\entails \lifdelta{I_1} \lor \lifdelta{D_\Gamma} \lor \lifdelta{s}=\lifdelta{t}$

			$\Gamma \stackrel\markB\entails \lifdelta{I_2} \lor \lifdelta{(E\occatp{r})_\Gamma}$

			Suppose now that for a model $M$ of $\Gamma$ and an assignment $\alpha$ of the free variables of $\lifdelta{s}$ and $\lifdelta{t}$ that $M_\alpha \entails \lifdelta{s}\neq \lifdelta{t}$.
			Then we get by \markA{} that $M_\alpha \entails \lifdelta{I_1} \lor \lifdelta{D_\Gamma}$, which by applying $\tauelldelta$ and Lemma~\ref{lemma:lifting_subst_commute} gives $M_\alpha \entails \lifdelta{I_1\sigma} \lor \lifdelta{D_\Gamma\sigma}$.
			Note that $M_\alpha \entails \lifdelta{s\sigma}\neq \lifdelta{t\sigma} \land \lifdelta{I_1\sigma}$ suffices for $M_\alpha \entails \lifdelta{\PIstep(\inference, \bar I)}$ and $M_\alpha \entails \lifdelta{D_\Gamma\sigma}$ implies that $M_\alpha \entails \lifdelta{C_\Gamma}$.
			Therefore we obtain that 
			$M_\alpha \entails \lifdelta{\PIstep(\inference, \bar I)} \lor \lifdelta{C_\Gamma}$.

			Now suppose to the contrary that for a model $M$ of $\Gamma$ that for any assignment of free variables $M \entails \lifdelta{s}\nolinebreak=\lifdelta{t}$.

			By applying $\tauelldelta$ and  Lemma~\ref{lemma:lifting_subst_commute} we obtain from \markB{} that
			$\Gamma \entails \lifdelta{I_2\sigma} \lor \lifdelta{(E\occatp{r})_\Gamma\sigma}$.
			As however $r\sigma \syneq s\sigma$,
			$\lifdelta{r\sigma} \syneq \lifdelta{s\sigma}$.
			Therefore we also have that 
			$\Gamma \entails \lifdelta{I_2\sigma} \lor \lifdelta{(E\occatp{s})_\Gamma\sigma}$.

			We proceed by a case distinction:
			\begin{itemize}
				\item Suppose that the position $p$ in $E\occatp{s}$ is not contained in a $\Delta$-term.
					Then
					$\lifdelta{(E\occatp{s})_\Gamma\sigma}$
					and
					$\lifdelta{(E\occatp{t})_\Gamma\sigma}$
					only differ at at position $p$.
					As $M \entails \lifdelta{s} = \lifdelta{t}$, we can apply $\tauelldelta$ and by Lemma~\ref{lemma:lifting_subst_commute} obtain that 
					$M \entails \lifdelta{s\sigma} = \lifdelta{t\sigma}$.
					Thus
					$M\entails \lifdelta{(E\occatp{s})_\Gamma\sigma} \semiff 
					\lifdelta{(E\occatp{t})_\Gamma\sigma}$
					and consequently
					$M \entails \lifdelta{I_2\sigma} \lor \lifdelta{(E\occatp{t})_\Gamma\sigma}$.
					As furthermore $\lifdelta{s\sigma} =\lifdelta{t\sigma} \land \lifdelta{I_2\sigma}$ entails $\lifdelta{\PIstep(\inference, \bar I)}$
					and $\lifdelta{(E\occatp{t})_\Gamma\sigma}$ is sufficient for $\lifdelta{C_\Gamma}$,
					we have that 
					$M\entails \lifdelta{\PIstep(\inference, \bar I)} \lor \lifdelta{C_\Gamma}$.

				\item
					Suppose that the position $p$ in $E\occatp{s}$ is contained in a maximal $\Delta$-term $h\occ{s}$.
					We distinguish further:

					\begin{itemize}
						\item Suppose $h\occ{s}$ occurs more than once in $I_2\sigma \lor E\occatp{s}\sigma$ and let $\alpha$ be an arbitrary assignment to the variables $\lifdelta{h\occ{s}} = x_{h\occ{s}}$ and $\lifdelta{h\occ{t}} = x_{h\occ{t}}$.

							If $M_\alpha \entails \lifdelta{h\occ{s}} \neq \lifdelta{h\occ{t}}$, then we have that $M_\alpha \entails \lifdelta{s}\nolinebreak=\lifdelta{t} \land\allowbreak \lifdelta{h\occ{s}} \neq \lifdelta{h\occ{t}}$, which implies that $M_\alpha \entails \lifdelta{\PIstep(\inference, \bar I)}$.

							%Assume that $M \entails \lifdelta{h\occ{s}} = \lifdelta{h\occ{t}}$ as otherwise $M \entails \lifdelta{s}\nolinebreak=\lifdelta{t} \land\allowbreak \lifdelta{h\occ{s}} \neq \lifdelta{h\occ{t}}$, which implies that $M \entails \lifdelta{\PIstep(\inference, \bar I)}$.
							Otherwise it holds that $M_\alpha \entails \lifdelta{h\occ{s}} = \lifdelta{h\occ{t}}$.
							But then 
							$\lifdelta{(E\occatp{s})_\Gamma\sigma}$
							and
							$\lifdelta{(E\occatp{t})_\Gamma\sigma}$
							differ in subterms which are equal in $M_\alpha$,
							%at position of $h\occ{s}$ and $h\occ{t}$ respectively and
							so by a similar line of argument as in the preceding case, we can deduce that $M \entails \lifdelta{\PIstep(\inference, \bar I)} \lor \lifdelta{C}$.

						\item Suppose $h\occ{s}$ occurs exactly once in $I_2\sigma \lor E\occatp{s}\sigma$.
							Then the lifting variable $x_{h\occ{s}}$
							occurs exactly once in $\lifdelta{I_2\sigma} \lor \lifdelta{E\occatp{s}\sigma}$.

							Note that from \markB{} by applying $\tauelldelta$ and Lemma~\ref{lemma:lifting_subst_commute}, we obtain that $M\entails \lifdelta{I_2\sigma} \lor \lifdelta{(E\occatp{s})_\Gamma\sigma}$.
							As $x_{h\occ{s}}$ occurs only once and free in this formula, it is implicitly universally quantified and we can instantiate it arbitrarily, in particular by $x_{h\occ{t}}$.
							But thereby we get that 
							$M\entails \lifdelta{I_2\sigma} \lor \lifdelta{(E\occatp{t})_\Gamma\sigma}$, 
							which implies that
							$\Gamma\entails \lifdelta{\PIstep(\inference, \bar I)} \lor \lifdelta{C_\Gamma}$.
							\qedhere
					\end{itemize}
			\end{itemize}

	\end{indproof}
\end{proof}

\begin{lemma}
	\label{lemma:gamma_entails_lifted_interpolant}
	Let $\pi$ be a resolution refutation of $\Gamma \cup \Delta$ and $C$ be a clause occurring in $\pi$.
	Then $\Gamma \entails \lifdelta{\PI(C) \lor\nolinebreak C}$.
\end{lemma}
\begin{proof}
	We proceed by induction on the strengthening
	$\Gamma \entails \lifdelta{\PI(C) \lor\nolinebreak C_\Gamma}$.

	If $C \in \Gamma\cup\Delta$, then by Lemma~\ref{lemma:gamma_entails_init} gives the result.

	For the induction step, suppose the clause $C$ is the result of an inference $\inference$ using the clauses $C_1, \dots, C_n$.
	By induction hypothesis, $\Gamma \entails \lifdelta{\PI(C_i) \lor\nolinebreak (C_i)_\Gamma}$ for $1\varleq i\varleq n$, hence
	by Lemma~\ref{lemma:gamma_entails_step}, we obtain that 
	$\Gamma \entails \lifdelta{\PIstep(\inference, \bar I) \lor C_\Gamma}$.
	This however is nothing else than $\Gamma \entails \lifdelta{\PI(C) \lor C_\Gamma}$.
\end{proof}




\section{Symmetry of the extracted interpolants}
\label{sec:symmetry}

The interpolant extraction procedure $\PI$ exhibits a convenient property which is termed \emph{symmetry} in \cite[Definition 3]{interpolantStrenth} and will be used to show that results concerning $\Gamma$ can easily be generalised to results for $\Delta$.
We develop it starting from $\PIinit$ and $\PIstep$ in order to then state it for $\PI$. 

\newcommand{\primex}[1]{\ensuremath{\bhat{#1}}}

\begin{lemma}
	\label{lemma:symmetry_base}
	Let $C$ be a clause in $\Gamma \cup \Delta$ and $\primex C$ the same clause in $\primex\Gamma\cup \primex\Delta$ such that $\primex\Gamma = \Delta$ and $\primex\Delta = \Gamma$.
	Then $\PIinit(C) \semiff \lnot \PIinit(\primex C)$. 
\end{lemma}
\begin{proof}
	\[
		\PIinit(C) =
	\begin{cases} \top & \text{ if $C \in \Delta$} \\ \bot & \text{ if $C \in \Gamma$}\end{cases}
	\spam= \begin{cases} \top & \text{ if $\primex C \in \primex\Gamma$} \\ \bot & \text{ if $\primex C \in \primex\Delta$}\end{cases}\\
		\spam =
	 \begin{cases} \lnot \bot & \text{ if $\primex C \in \primex\Gamma$} \\ \lnot \top & \text{ if $\primex C \in \primex\Delta$}\end{cases}
		=
		\lnot \PIinit(\primex C) 
		\qedhere
	\]
\end{proof}

\begin{lemma}
	\label{lemma:symmetry_step}
	Let $\pi$ be a resolution refutation of $\Gamma \cup \Delta$ and
	$\primex\pi$ be $\pi$ with opposite coloring, i.e.\ $\primex\Gamma = \Delta$ and $\primex\Delta = \Gamma$.
	If $\inference$ is an inference of $\pi$ using the clauses $C_1, \dots, C_n$,
	and
	$I_1, \dots, I_n$ and 
	$\primex I_1, \dots, \primex I_n$ are formulas  
	such that $I_i \semiff \lnot \primex I_i$ for $1\varleq i \varleq n$, then
	$\PIstep(\inference, I_1, \dots, I_n) \spas\semiff \PIstep(\primex\inference, \primex I_1, \dots, \primex I_n)$.
\end{lemma}
\begin{proof}
	Let $\primex\varphi$ denote the clause/formula/literal/term in $\primex\pi$ corresponding to the clause/formula/literal/term $\varphi$ in $\pi$.

	We distinguish cases based on the type of the inference $\inference$:

	\begin{indproof}
		\indproofitem{Resolution}
			\newcommand{\p}[1]{\primex{#1}}

			Suppose that $\inference$ is a resolution inference of $C_1: D \lor l$ and $C_2: E \lor \lnot l'$ with $\sigma = \mgu(\inference)$.

			We distinguish the following cases:
			\begin{enumerate}
				\item $l$ is $\Gamma$-colored. Then $\primex l$ is $\Delta$-colored.
					\begin{align*}
						\PIstep(\inference, I_1, \dots, I_n) &= I_1\sigma \lor I_2\sigma\\
													 &\semiff \lnot ( \lnot I_1\sigma \land \lnot I_2\sigma )\\
														&\semiff \lnot ( \p I_1\sigma \land \p I_2\sigma ) \\
														&= \lnot \PIstep(\primex \inference, \p I_1, \p I_2)  
					\end{align*}
				\item $l$ is $\Delta$-colored. This case can be argued analogously.

				\item $l$ is grey. Then $\primex l$ is grey. 
					Note that $l\sigma \syneq l'\sigma$ \markB.
					\nopagebreak 
					\begin{align*}
						\PIstep(\inference, I_1, \dots, I_n) 
						&=  [(l \land I_2) \lor (\lnot l'  \land I_1)]\sigma\\
						&\hspace{-1pt}\stackrel{\mathclap{\markB}}\semiff[(\lnot l \lor I_2) \land (l' \lor I_1)]\sigma\\
						 &\semiff \lnot [(l \land \lnot I_2) \lor (\lnot l'  \land \lnot I_1)]\sigma\\
						 &= \lnot [(\p l \land\lnot I_2 ) \lor (\lnot \p{l'}\land \lnot I_1 )]\sigma\\
						 &\semiff \lnot  [(\p l \land \p I_2 ) \lor (\lnot \p{l'} \land \p I_1)]\sigma \\
						 &= \lnot \PIstep(\p \inference, \p I_1, \dots, \p I_n)
					\end{align*}
			\end{enumerate}

				\indproofitem{Factorisation}
					Suppose that $\inference$ is a factorisation inference of $C_1: l \lor l' \lor D$
					with $\sigma = \mgu(\inference)$.
					Then $\PIstep(\inference, I_1) = I_1\sigma \spas\semiff \lnot \p I_1\sigma = \lnot \PIstep(\p \inference, \p I_1)$.

				\indproofitem{Paramodulation}
					Suppose that $\inference$ is a paramodulation inference of $C_1: s=t \lor D$ and $C_2: E\occur{r}$ 
					with $\sigma = \mgu(\inference)$.

					We proceed by a case distinction:

					\begin{enumerate}
						\item $r$ occurs in a maximal $\Delta$-term $h\occur{r}$ in $E\occur{r}$ and $h\occur{r}$ occurs more than once in $I_2 \lor E\occur{r}$.
							Then $\primex r$ occurs in a maximal $\Gamma$-term $\primex h\occur{r}$ in $\primex E\occur{r}$ and $\primex h\occur{r}$ occurs more than once in $\primex E\occur{r} \lor \PI(\primex E\occur{r})$.
							\begin{align*}
								\PIstep(\inference, I_1, I_2) &= [ ( s=t \land I_2 ) \lor (s\neq t \land I_1) ]\sigma \lor (s=t \land h\occur{s} \neq h\occur{t})\sigma\\
														&\semiff [ ( s=t \land \lnot \p I_2 ) \lor (s\neq t \land \lnot \p I_1) ]\sigma \lor (s=t \land h\occur{s} \neq h\occur{t})\sigma\\
														&\semiff \lnot [ ( s\neq t \lor \p I_2 ) \land (s= t \lor \p I_1) ]\sigma \land \lnot (s\neq t \lor h\occur{s} = h\occur{t})\sigma\\
														&\semiff \lnot [ ( s = t \land \p I_2 ) \lor (s\neq t \land \p I_1) ]\sigma \land \lnot (s\neq t \lor h\occur{s} = h\occur{t})\sigma\\
													 &= \lnot \PIstep(\primex \inference, \p I_1, \p I_2)
							\end{align*}

						\item $r$ occurs in a maximal $\Gamma$-term $h\occur{r}$ in $E\occur{r}$ and $h\occur{r}$ occurs more than once in $I_2 \lor E\occur{r}$.
							This case can be argued analogously.
						\item Otherwise:
							\begin{align*}
								\PIstep(\inference, I_1, I_2) &= [ ( s=t \land I_2 ) \lor (s\neq t \land I_1) ]\sigma \\
														&\semiff\, [ ( s=t \land \lnot \p I_2 ) \lor (s\neq t \land \lnot \p I_1) ]\sigma \\
														&\semiff \lnot [ ( s\neq t \lor \p I_2 ) \land (s=t \lor \p I_1) ]\sigma \\
														&\semiff \lnot [ ( s=t \land \p I_2 ) \lor (s\neq t \land \p I_1) ]\sigma \\
													 &= \lnot \PIstep(\primex \inference, \p I_1, \p I_2)
								\qedhere
							\end{align*}
					\end{enumerate}


	\end{indproof}

\end{proof}



\begin{lemma}
	\label{lemma:symmetry}
	Let $\pi$ be a resolution refutation of $\Gamma \cup \Delta$ and
	$\primex\pi$ be $\pi$ with $\primex\Gamma = \Delta$ and $\primex\Delta = \Gamma$.
	Then for a clause $C$ and its corresponding clause $\primex C$ in $\primex \pi$, $\PI(C) \semiff \lnot \PI(\primex C)$.
\end{lemma}
\begin{proof}
	We prove this lemma by induction.

	For $C \in \Gamma \cup \Delta$, we obtain the result by Lemma~\ref{lemma:symmetry_base}.

	For the induction step, suppose that the clause $C$ is the result of an inference $\inference$ of the clauses $C_1, \dots, C_n$.
	Then by the induction hypothesis, we obtain that  $\PI(C_i) \semiff \lnot \PI(\primex C_i)$ for $1 \varleq i \varleq n$. 
	Hence we can apply Lemma~\ref{lemma:symmetry_step} and get that  $\PIstep(\inference, \PI(C_1), \dots, \PI(C_n)) \semiff \lnot \PIstep(\primex \inference, \PI(\primex C_1), \dots, \PI(\primex C_n))$.
	But this is nothing else than $\PI(C) \spas\semiff \lnot \PI(\primex C)$.
\end{proof}


\begin{corr}
	\label{cor:delta_entails_lifted_interpolant}
	Let $\pi$ be a resolution refutation of $\Gamma \cup \Delta$. 
	Then $\Delta \entails \lft{\Gamma}{x}{ \lnot \PI(C) \lor C }$ for $C$ in $\pi$.
\end{corr}
\begin{proof}
	Form $\primex \pi$ from $\pi$ using $\primex \Gamma = \Delta$ and $\primex \Delta = \Gamma$ as initial clause sets.
	By Lemma \ref{lemma:gamma_entails_lifted_interpolant}, it holds that $\primex \Gamma \entails \lft{\primex\Delta}{x}{ \PI(\primex C) \lor \primex C }$ for $\primex C$ in $\primex \pi$ and 
	by Lemma \ref{lemma:symmetry}, we obtain that 
	$\primex \Gamma \entails \lft{\primex\Delta}{x}{ \lnot \PI(C) \lor \primex C }$ for the clause $C$ in $\pi$ corresponding to $\primex C$ in $\primex \pi$. 
	This however is nothing else than 
	$\Delta \entails\nolinebreak \lft{\Gamma}{x}{ \lnot \PI(C) \lor C }$.
\end{proof}


\section{Propositional and one-sided interpolants}

We now show that the results presented in section \ref{sec:two_phase_main_lemma} and \ref{sec:symmetry}
already give propositional interpolants in the sense that besides possibly containing colored terms, they are proper interpolants.
Note that this coincides with the notion of ``relational interpolant'' as given in \cite{Huang95} and is defined formally in our notation in~\ref{def:huang_orig_rel_prop_interpol}.

\begin{corr}
	\label{cor:propositional_interpolant}
	Let $\pi$ be a resolution refutation of $\Gamma \cup \Delta$.
	Then $\PI(\pi)$ is a propositional interpolant, i.e.\ it holds that:
	\begin{enumerate}
		\item$\Gamma\entails \PI(\pi)$
		\item$\Delta\entails \lnot \PI(\pi)$
		\item $\PS(\PI(\pi)) \subseteq \PS(\Gamma) \cap \PS(\Delta)$.
	\end{enumerate}
\end{corr}
\begin{proof}
	By the definition of $\PI$, 
	$\PI(\pi)$ denotes $\PI(\square)$, where $\square$ is the empty clause derived in $\PI$.
	By Lemma~\ref{lemma:gamma_entails_lifted_interpolant}, we get that 
	$ \Gamma \entails \lifdelta{\PI(\pi)}$.
	As the lifting replaces terms by variables which are then implicitly universally quantified, $\PI(\pi)$ is an instance of $\lifdelta{\PI(\pi)}$.
	Therefore $\Gamma \entails \PI(\pi)$.

	By Corollary~\ref{cor:delta_entails_lifted_interpolant}, $\Delta \entails \lnot \lifgamma{\PI(\pi)}$,
	thus by a similar argument as above, $\Delta \entails \lnot \PI(\pi)$.


	Finally, by the construction of $\PI$, $\PI(\pi)$ is solely comprised of grey predicate symbols.
\end{proof}


From Lemma~\ref{lemma:gamma_entails_lifted_interpolant}, we can also easily derive a result on a restricted notion of interpolation which we refer to as one-sided interpolants. 

\begin{defi}
	Let $\Gamma$ and $\Delta$ be sets of first-order formulas.
	A \defiemph{one-sided interpolant} of $\Gamma$ and $\Delta$ is a first-order formula $I$ such that
	\begin{enumerate}
		\item $\Gamma \entails I$
		\item $\Delta \entails \lnot I$
		\item $\Lang(I) \subseteq \Lang(\Gamma) $
			\qedhere
	\end{enumerate}
\end{defi}

Note that if $I$ is a one-sided interpolant for $\Gamma$ and $\Delta$ and additionally $\Lang(I) \subseteq \Lang(\Delta)$ holds, then $I$ is an interpolant for $\Gamma$ and $\Delta$.

\begin{prop}
	Let $\Gamma$ and $\Delta$ be sets of first-order formulas such that $\Gamma\cup\Delta$ is unsatisfiable.
	Then there is a one-sided interpolant of $\Gamma$ and $\Delta$ which is a $\Pi_1$ formula.
\end{prop}
\begin{proof}
	Let $\pi$ be a resolution refutation of $\Gamma\cup\Delta$.
	By Lemma~\ref{lemma:gamma_entails_lifted_interpolant}, we have that
	$ \Gamma \entails \lifdelta{\PI(\pi)}$,
	or equivalently
	$\Gamma \entails \forall x_{t_1} \quantifierdots \forall x_{t_n}  \PI(\pi)$, where $x_{t_1}, \dots, x_{t_n}$ are the $\Delta$-lifting variables occurring in $\PI(\pi)$.

	By Corollary~\ref{cor:propositional_interpolant}, we get that
	$\Delta \entails \lnot \PI(\pi)$.
	This however provides witness terms for the formula
	$\exists x_{t_1} \quantifierdots \exists x_{t_n} \lnot \lifdelta{ \PI(\pi) }$, hence
	$\Delta \entails \exists x_{t_1} \quantifierdots \exists x_{t_n} \lnot \lifdelta{ \PI(\pi) }$. Now we pull the quantifiers inwards to obtain that
	$\Delta \entails \lnot  \forall x_{t_1} \quantifierdots \forall x_{t_n} \lifdelta{ \PI(\pi) }$.

	Clearly $\forall x_{t_1} \quantifierdots \forall x_{t_n} \lifdelta{ \PI(\pi) }$ is devoid of $\Delta$-terms and hence a one-sided interpolant, which is a $\Pi_1$ formula.
\end{proof}



\section{Quantifying over lifting variables}

As we have already seen in Corollary~\ref{cor:propositional_interpolant} that $\PI(\pi)$ forms a propositional interpolant, it remains to lift all colored terms and quantify over the resulting lifting variables in a viable order.


\begin{lemma}
	%Let $\{z_1,\ldots, z_n\}$ be the maximal colored terms of a clause $C$.
	%Then 
	%$ Q_1 z_1 \ldots Q_n z_n \lft{\Gamma}{y}{ \lft{\Delta}{x}{ C}  }
	%\;\liff\;
	%Q_1 z_1 \ldots Q_n z_n \lft{\Delta}{x'}{ \lft{\Gamma}{y'}{ C}  }$ for $Q_i \in \{\forall, \exists\}$ for $1\varleq i\varleq n$.

	For a formula or term $\varphi$,
	$ \lft{\Gamma}{y}{ \lft{\Delta}{x}{ \varphi}  } =
	\lft{\Delta}{x}{ \lft{\Gamma}{y}{ \varphi }  }$.
	%\label{lemma:naming_of_colored_variables}
	\label{lemma:lifting_order_not_relevant}
\end{lemma}
\begin{proof}
	Let $\varphi$ be a term which contains a colored term which in turn contains a term of different color.
	Suppose without loss of generality that it is a $\Gamma$-term which contains a maximal $\Delta$-term $t$ at position $p$.
	Then $\lft{\Delta}{x}{ \lft{\Gamma}{y}{ \varphi }  }
	= \lft{\Delta}{x}{ y_\varphi }
	= y_\varphi $.

	On the other hand
	$\lft{\Gamma}{y}{ \lft{\Delta}{x}{ \varphi}  } = \lft{\Gamma}{y}{ \psi }$ such that $\psi$ is equal to $\varphi$ besides having $x_t$ at position $p$.
	But $\lft{\Gamma}{y}{ \psi } = y_{\expa(\psi)} = y_\varphi$.
	%	\begin{comment}
	%		Suppose a term $t$ in $C$ is affected by a lifting.
	%		We only need to consider maximal colored terms as grey terms are not affected by the liftings.
	%		Without loss of generality let $t$ be a maximal $\Delta$-colored term.
	%
	%		Let $\Phi$ be the positions of maximal occurrences of $t$.
	%		Then in the left hand side, exactly all terms at positions $\Phi$ are replaced by $x_i$ for some $i$.
	%
	%		In the right hand side, all terms at positions $\Phi$ are replaced by $\lft{\Gamma}{y'}{t}$ first. 
	%		However after this step,
	%		all these terms are equal to $\lft{\Gamma}{y'}{t}$, and as all distinct maximal $\Gamma$-terms are replaced by distinct variables, no other maximal colored term is equal to $\lft{\Gamma}{y'}{t}$.
	%		Hence exactly the terms at positions $\Phi$ are replaced by the same variable $x'_j$ for some $j$.
	%	\end{comment}
\end{proof}


\begin{thm}
	\label{thm:two_phases}
	Let $\pi$ be a resolution refutation of $\Gamma \cup \Delta$ and
	$t_1, \dots, t_n$ be an arrangement of the maximal colored terms in $\PI(\pi)$ according to the subterm order, i.e.\ if $t_i$ is a subterm of $t_j$, then $i<j$.
	Then
	$Q_1 z_{t_1} \ldots Q_n z_{t_n}\,\lifgamma{\lifdelta{\PI(\pi)}}$, where $Q_i$ is $\forall$ $(\exists)$ if $z_{t_i}$ replaces a $\Delta$ $(\Gamma)$-term, is an interpolant for $\Gamma$ and $\Delta$.
\end{thm}
\begin{proof}
	By Lemma \ref{lemma:gamma_entails_lifted_interpolant}, $\Gamma \entails \forall x_{s_1} \ldots \forall x_{s_m}\,\lifdelta{\PI(\pi)}$, where $s_1, \dots s_m$ are the maximal colored $\Delta$-terms in $\PI(\pi)$.

	A term in $\lifdelta{\PI(\pi)}$ is either $x_{s_i}$, $1 \varleq i \varleq m$, a grey term or a $\Gamma$-terms.
	Let $t$ be a maximal $\Gamma$-term in $\PI(\pi)$ and ${r_1}, \dots, {r_k}$ the maximal $\Delta$-terms in\nolinebreak{} $t$.
	Then in $\lifdelta{\PI(\pi)}$, the terms ${r_1}, \dots, {r_k}$ are replaced by $x_{r_1}, \dots, x_{r_k}$ respectively.
	Note that as all of ${r_1}, \dots, {r_k}$ are subterms of $t$, all of $x_{r_1}, \dots, x_{r_k}$ precede $y_t$ in the arrangement of the lifting variables.
	%Note that all of $r_1, \dots, r_k$ are subterms of $t$.
	%Note that the $\Delta$-terms, which are replaced by $x_{r_1}, \ldots, x_{i_{j_k}}$ respectively, are each of strictly smaller size than $t$ as they are strict subterms of $t$.

	%Then it is of the form $f(x_{i_1}, \ldots, x_{i_{n_x}}, u_1, \ldots, u_{n_u}, v_1, \ldots, v_{n_v})$, where $f$ is $\Gamma$-colored, the $u_j$, $1\varleq j \varleq n_u$ are grey terms and the $v_j$, $1\varleq j\varleq n_v$ are $\Gamma$-terms.

	In $\lifgamma{\lifdelta{\PI(\pi)}}$, $t$ is lifted by $y_t$, which is existentially quantified.
	Hence $t$ is a witness for $y_j$ as due to the quantifier ordering,
	it is bound in the scope of the quantification of the lifting variables $x_{r_1}, \dots, x_{r_k}$.
	Therefore $\Gamma \entails Q_1 z_{t_1} \ldots Q_n z_n\,\lifgamma{\lifdelta{\PI(\pi)}}$.

	By Corollary \ref{cor:delta_entails_lifted_interpolant} $\Delta \entails \forall y_{u_1} \dots \forall y_{u_{k'}}\,\lnot \lift{\Gamma}{\PI(\pi)}{y}$, where $u_1, \dots u_{k'}$ are the maximal colored $\Gamma$-terms in $\PI(\pi)$.

	By a similar line of argumentation as above, we can replace the maximal $\Delta$-\nolinebreak{}terms by lifting variables which are then existentially quantified and arrive at
	$\Delta \entails\nolinebreak{} \overline Q_1 z_{t_1} \dots \overline Q_n z_{t_n}\,\lnot \lft{\Delta}{x}{\lft{\Gamma}{y}{\PI(\pi)}}$ where $\overline Q_i = \exists$ ($\forall$) if $Q_i = \forall$ ($\exists$).
	Therefore also
	$\Delta \entails\nolinebreak{} \lnot Q_1 z_{t_1} \dots Q_n z_{t_n}\,\lft{\Delta}{x}{\lft{\Gamma}{y}{\PI(\pi)}}$ and
	finally by Lemma \ref{lemma:lifting_order_not_relevant}, we obtain that 
	$\Delta \entails\nolinebreak{} \lnot Q_1 z_{t_1} \dots Q_n z_{t_n}\,\lft{\Gamma}{y}{\lft{\Delta}{x}{\PI(\pi)}}$.

	As it is now easy to see that $Q_1 z_{t_1} \dots Q_n z_{t_n}\,\lft{\Gamma}{y}{\lft{\Delta}{x}{\PI(\pi)}}$ contains no colored symbol, it is an interpolant.
\end{proof}


\begin{remark}
	In this proof, we order the lifting variables in the interpolant according to the subterm relation of the terms they represent.
	This differs from the proof in \cite{Huang95}, where the ordering is based on the length of these terms.
	The proof of the theorem above however shows that both of these approaches are equally valid, but clearly the subterm-based ordering in general allows for more permutations than the length-based ordering. 
\end{remark}

We conclude by presenting the execution of the algorithm on an example:

\begin{exa}
	\label{exa:two_phase}
	Let $\Gamma = \{ G(x, y) \lor L(x, y) \lor x = y, \lnot G(v, f(v)), \lnot Z(w) \lor \lnot Z(f(w)) \}$
	and 
	$\Delta = \{ Z(d), \lnot Z(z) \lor \lnot L(z, u) \}$.
	Hence $\Lang(\Gamma)\cap \Lang(\Delta) = \{ Z, L \}$,
	$\Lang(\Gamma)\setminus \Lang(\Delta) = \{ G,  f \}$ and
	$\Lang(\Delta)\setminus \Lang(\Gamma) = \{ d \}$.

	We use the following resolution refutation $\pi$ for the extraction of the interpolant:

	{ %\small

		~


		\begin{adjustwidth}{8em}{0em}
			\def\defaultHypSeparation{\hskip 1.4em}
			\def\ScoreOverhang{-0em}
			\begin{prooftree}
				\AxiomCm{ Z(d) }

				\AxiomCm{ G(x, y) \lor L(x, y) \lor x = y }
				\AxiomCm{ \lnot Z(z) \lor \lnot  L(z, u) }
				\RightLabelm{\resrule{\resruleres}{z \mapsto x}}
				\BinaryInfCm{  G(x, y) \lor x=y \lor \lnot Z(x) }

				\AxiomCm{ \lnot Z(w) \lor \lnot Z(f(w)) }
				\AxiomCm{ Z(d)}
				\RightLabelm{\resrule{\resruleres}{w \mapsto d}}
				\BinaryInfCm{ \lnot Z(f(d)) }

				\RightLabelm{\resrule{\resrulepar}{y\mapsto f(d)}}
				\BinaryInfCm{ G(x, f(d)) \lor \lnot Z(x) \lor \lnot Z(x) }
				\RightLabelm{\resrule{\resrulefac}{\id}}
				\UnaryInfCm{ G(x, f(d)) \lor \lnot Z(x)  }

				\AxiomCm{ \lnot G(v, f(v)) }

				\insertBetweenHyps{\hskip -9em}

				\RightLabelm{\resrule{\resruleres}{v\mapsto d,\, x\mapsto d}}
				\BinaryInfCm{  \lnot Z(d)  }

				\insertBetweenHyps{\hskip -10em}

				\RightLabelm{\resrule{\resruleres}{\id}}
				\BinaryInfCm{  \square }
			\end{prooftree}
		\end{adjustwidth}
		~

		~
	}

	In the following tree, we show the propositional interpolant $\PI(C)$ for the corresponding clauses $C$ (in simplified form):
	{
		\def\defaultHypSeparation{\hskip 4.4em}
		\begin{prooftree}

			\AxiomCm{ \top  }

			\AxiomCm{ \bot}
			\AxiomCm{ \top }
			\BinaryInfCm{  L(x, y) }

			\AxiomCm{ \bot}
			\AxiomCm{ \top }
			\BinaryInfCm{ \lnot Z(d) }

			\BinaryInfCm{ (x = f(d) \land \lnot Z(f(d)) ) \lor (x \neq f(d) \land L(x, f(d))) }
			\UnaryInfCm{  (x = f(d) \land \lnot Z(f(d)) ) \lor (x \neq f(d) \land L(x, f(d))) }

			\AxiomCm{ \bot }

			\BinaryInfCm{  (d = f(d) \land \lnot Z(f(d)) ) \lor (d \neq f(d) \land L(d, f(d))) }

			\BinaryInfCm{ \lnot Z(d) \lor  \big( (d = f(d) \land \lnot Z(f(d)) ) \lor (d \neq f(d) \land L(d, f(d))) \big)}
		\end{prooftree}
	}


	\noindent
	Hence
	\[\PI(\pi) \spam=  \lnot Z(d) \spas\lor  (d = f(d) \land \lnot Z(f(d)) ) \spas\lor (d \neq f(d) \land L(d, f(d))) \]
	and lifting and quantification gives the final interpolant
	\[ \forall x_d \exists y_{f(d)} \big( \lnot Z(x_d) \spam\lor  (x_d = y_{f(d)} \land \lnot Z(y_{f(d)}) ) \spam\lor (x_d \neq y_{f(d)} \land L(x_d, y_{f(d)})) \big).
	\qedhere
\]
\end{exa}


	%neg:
	%$ \exists x_d \forall y_{f(d)} ( Z(x_d) \land  (x_d \neq y_{f(d)} \lor Z(y_{f(d)}) ) \land (x_d = y_{f(d)} \lor \lnot L(x_d, y_{f(d)})) )$




	\begin{comment}
		\begin{prooftree}


			\AxiomCm{ G(x, y) \lor L(x, y) \lor x = y \mid \bot }
			\AxiomCm{ \lnot Z(z) \lor \lnot  L(z, u) \mid \top}
			\BinaryInfCm{  G(x, y) \lor x=y \lor \lnot Z(x) \mid (L(x,y) \land \top) \lor (\lnot L(x,y) \land \bot)}
			\noLine
			\UnaryInfCm{  G(x, y) \lor x=y \lor \lnot Z(x) \mid L(x,y)}

			\AxiomCm{ \lnot Z(w) \lor \lnot Z(f(w)) \mid \bot }
			\AxiomCm{ Z(d)\mid \top}
			\BinaryInfCm{ \lnot Z(f(d)) \mid Z(d) \markC  \hl{error}}

			\BinaryInfCm{ G(x, f(d)) \lor \lnot Z(x) \lor \lnot Z(y) \mid (x=f(d) \land Z(d)) \lor (x\neq f(d) \land L(x, f(d))) }
			\UnaryInfCm{ G(x, f(d)) \lor \lnot Z(x)  \mid (x=f(d) \land Z(d)) \lor (x\neq f(d) \land L(x, f(d))) }

			\AxiomCm{ \lnot G(v, f(v)) \mid \bot}

			\BinaryInfCm{  \lnot Z(d)  \mid (d=f(d) \land Z(d)) \lor (d\neq f(d) \land L(d, f(d))) \markC }

			\AxiomCm{ Z(d) \mid \bot }

			\BinaryInfCm{  \square \mid Z(d) \land (  (d=f(d) \land Z(d)) \lor (d\neq f(d) \land L(d, f(d))) ) \markC }



		\end{prooftree}
	\end{comment}


