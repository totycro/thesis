
\section{WT: Interpolation extraction in one pass}

easy for constants, just as in huang but in one pass

terms can grow unpredictably, order cannot be determined during pass

\section{WT: Interpolation extraction in two passes}

\subsection{huang proof revisited}

\subsubsection{propositional part}

Let $\Gamma \cup \Delta$ be unsatisfiable. Let $\pi$ be a proof of the empty clause from $\Gamma \cup \Delta$. Then $\PI$ is a function that returns a interpolant with respect to the current clause. 

\begin{defi}
	$\theta$ is a \defiemph{propositional interpolant} with respect to a clause $C$ in a resolution refutation $\pi$ of $\Gamma \cup \Delta$ if 
	\label{def:rel_prop_interpol}
	\begin{enumerate}
		\item $\Gamma \entails \theta \lor C$
			\label{rel_prop_interpol_cond1}
		\item $\Delta \entails \lnot \theta \lor C$
			\label{rel_prop_interpol_cond2}
		\item $\Pred(\theta) \subseteq (\Pred(\Gamma) \intersect \Pred(\Delta)) \cup \{\top, \bot\} $.
			\label{rel_prop_interpol_cond_lang}
			\qedhere
	\end{enumerate}
\end{defi}

The third condition will sometimes be referred to as \emph{language restriction}.
It is easy to see that a propositional interpolant with respect to $\square$ is a propositional interpolant\todo{add this to the definition, i.e.~possible define rel prop interpol from prop interpol}, i.e.~it is an interpolant without the language restriction on constant, variable and function symbols.

We proceed by defining a procedure $\PI$ which extracts propositional interpolants from a resolution refutation.

\begin{defi}
	\defiemph{$\PI$} is defined as follows:
	\label{def:PI}
\begin{itemize}
	\item[Base case.]
		If $C \in \Gamma$, $\PI(C) = \bot$. 
		If otherwise $C \in \Delta$, $\Delta(C) = \top$. 
	\item[Resolution.]
	\label{def:PI_resolution}
		Suppose the clause $C$ is the result of a resolution step. Then it has the following form: 

%	\begin{prooftree}
%		\AxiomCm{C_1: D \lor l}
%		\AxiomCm{C_2: E \lor \lnot l'}
%		\RightLabelm{\quad l\sigma = l'\sigma}
%		\BinaryInfCm{C: (D\lor E)\sigma}
%	\end{prooftree}
		%\todo{write as prooftree? (not necessary, but nicer)}
		If the clause $C$ is the result of a resolution step of $C_1: D \lor l$ and $C_2: E \lor \lnot l'$ using a unifier $\sigma$ such that $l\sigma = l'\sigma$, then $\PI(C)$ is defined as follows:
	%$\PI(C)$ is defined according to this case distinction:
		\begin{enumerate}
			\item If $\Pred(l) \in \Lang(\Gamma) \setminus \Lang(\Delta)$:\todo{change to "is $\Gamma$-colored?"} $\PI(C) = [\PI(C_1) \lor \PI(C_2)]\sigma$
			\item If $\Pred(l) \in \Lang(\Delta) \setminus \Lang(\Gamma)$: $\PI(C) = [\PI(C_1) \land \PI(C_2)]\sigma$
			\item If $\Pred(l) \in \Lang(\Gamma) \intersect \Lang(\Delta)$: $\PI(C) = [(l \land \PI(C_2)) \lor (l' \land \PI(C_1)) ]\sigma $
		\end{enumerate}

	\item[Factorisation.]
		If the clause $C$ is the result of a factorisation of $C_1: l \lor l' \lor D$ using a unifier $\sigma$ such that $l\sigma = l'\sigma$, then $\PI(C) = \PI(C_1)\sigma$.

	\item[Paramodulation.]
		If the clause $C$ is the result of a paramodulation of $C_1: s=t \lor C$ and $C_2: D[r]$ using a unifier $\sigma$ such that $r\sigma = s\sigma$, then $\PI(C)$ is defined according to the following case distinction:
		\begin{enumerate}
			\item If $r$ occurs in a maximal $\Delta$-term $h(r)$ in $D[r]$ and $h(r)$ occurs more than once in $D[r] \lor \PI(D[r])$:
				\label{def:PI_paramod_1}
				\newline
				$\PI(C) = [ ( s=t \land \PI(C_2) ) \lor (s\neq t \land \PI(C_1)) ]\sigma \lor (s=t \land h(s) \neq h(t))$ 
			\item If $r$ occurs in a maximal $\Gamma$-term $h(r)$ in $D[r]$ and $h(r)$ occurs more than once in $D[r] \lor \PI(D[r])$:
				\label{def:PI_paramod_2}
				\newline
				$\PI(C) = [ ( s=t \land \PI(C_2) ) \lor (s\neq t \land \PI(C_1)) ]\sigma \land (s\neq t \lor h(s) = h(t))$ 
			\item Otherwise:
				\label{def:PI_paramod_3}
				\newline
				$\PI(C) = [ ( s=t \land \PI(C_2) ) \lor (s\neq t \land \PI(C_1)) ]\sigma$ \qedhere

		\end{enumerate}
\end{itemize}
\end{defi}


\begin{prop}
	\label{prop:prop_interpol}
	Let $C$ be a clause of a resolution refutation.
	Then $\PI(C)$ is a propositional interpolant with respect to $C$. 
\end{prop}
\begin{proof}
	Proof by induction on the number of rule applications including the following strengthenings:
	$\Gamma \entails \PI(C) \lor C_\Gamma$ and
	$\Delta \entails \lnot \PI(C) \lor C_\Delta$, where $D_\Phi$ denotes the clause D with only the literals which are contained in $\Lang(\Phi)$. They clearly imply conditions \ref{rel_prop_interpol_cond1} and \ref{rel_prop_interpol_cond2} of definition \ref{def:rel_prop_interpol}. 

\begin{itemize}
	\item[Base case.]
	Suppose no rules were applied. We distinguish two possible cases:
	\begin{enumerate}
		\item $C \in \Gamma$.
			Then $\PI(C) = \bot$. Clearly $\Gamma \entails \bot \lor C_\Gamma$ as $C_\Gamma = C \in \Gamma$, $\Delta \entails \lnot \bot \lor C_\Delta$ and $\bot$ satisfies the restriction on the language.

		\item $C \in \Delta$.
			Then $\PI(C) = \top$. Clearly $\Gamma \entails \top \lor C_\Gamma$, $\Delta \entails \lnot \top \lor C_\Delta$ as $C_\Delta = C \in \Delta$ and $\top$ satisfies the restriction on the language.
	\end{enumerate}

	Suppose the property holds for $n$ rule applications.
	We show that it holds for $n+1$ applications by considering the last one:

\item[Resolution.]
	Suppose the last rule application is an instance of resolution. Then it is of the form:
	\begin{prooftree}
		\AxiomCm{C_1: D \lor l}
		\AxiomCm{C_2: E \lor \lnot l'}
		\RightLabelm{\quad l\sigma = l'\sigma}
		\BinaryInfCm{C: (D\lor E)\sigma}
	\end{prooftree}

	By the induction hypothesis, we can assume that:

	$\Gamma \entails \PI(C_1) \lor (D\lor l)_\Gamma$

	$\Delta \entails \lnot \PI(C_1) \lor (D\lor l)_\Delta$

	$\Gamma \entails \PI(C_2) \lor (E\lor \lnot l')_\Gamma$

	$\Delta \entails \lnot \PI(C_2) \lor (E\lor \lnot l')_\Delta$

		We consider the respective cases from definition \ref{def:PI_resolution}:

			\begin{enumerate}
				\item $\Pred(l) \in \Lang(\Gamma) \setminus \Lang(\Delta)$:
					\label{huang_proof_prop_case_1}
					Then $\PI(C) = [\PI(C_1) \lor \PI(C_2)]\sigma$. 

					As $\Pred(l) \in \Lang(\Gamma)$,
					$\Gamma \entails (\PI(C_1) \lor D_\Gamma\lor l)\sigma$
					as well as $\Gamma \entails (\PI(C_2) \lor E_\Gamma\lor \lnot l')\sigma$.
					By a resolution step, we get $\Gamma \entails (\PI(C_1) \lor \PI(C_2))\sigma \lor ((D \lor E)\sigma)_\Gamma$.

					Furthermore, as $\Pred(l) \not\in \Lang(\PI)$, 
					$\Delta \entails (\lnot\PI(C_1) \lor D_\Delta)\sigma$
					as well as $\Delta \entails (\lnot\PI(C_2) \lor E_\Delta)\sigma$.
					Hence it certainly holds that $\Delta \entails (\lnot \PI(C_1) \lor \lnot\PI(C_2))\sigma \lor (D \lor E)\sigma_\Delta$.

					The language restriction clearly remains satisfied as no non-logical symbols are added.

				\item $\Pred(l) \in \Lang(\Delta) \setminus \Lang(\Gamma)$: 
					\label{huang_proof_prop_case_2}
					Then $\PI(C) = [\PI(C_1) \land \PI(C_2)]\sigma$. 

					As $\Pred(l) \not\in \Lang(\Gamma)$,
					$\Gamma \entails (\PI(C_1) \lor D_\Gamma)\sigma$
					as well as $\Gamma \entails (\PI(C_2) \lor E_\Gamma)\sigma$.
					Suppose that in a model $M$ of $\Gamma$, $M \cancel \entails D_\Gamma$ and $M \cancel \entails E_\Gamma$. Then $M \entails \PI(C_1) \land \PI(C_2)$.
					Hence 
					$\Gamma \entails (\PI(C_1) \land \PI(C_2))\sigma \lor ((D \lor E)\sigma)_\Gamma$.

					Furthermore due to $\Pred(l) \in \Lang(\Delta)$,
					$\Delta \entails (\lnot\PI(C_1) \lor D_\Delta \lor l)\sigma$
					as well as $\Delta \entails (\lnot\PI(C_2) \lor E_\Delta \lor \lnot l')\sigma$.
					By a resolution step, we get $\Delta \entails (\lnot\PI(C_1) \lor \lnot\PI(C_2))\sigma \lor (D_\Delta \lor E_\Delta)\sigma $
					and hence 
					$\Delta \entails \lnot (\PI(C_1) \land \PI(C_2))\sigma \lor (D_\Delta \lor E_\Delta)\sigma $.

					The language restriction again remains intact.

				\item $\Pred(l) \in \Lang(\Delta) \intersect \Lang(\Gamma)$:
					Then $\PI(C) = [(l \land \PI(C_2)) \lor (\lnot l' \land \PI(C_1)) ]\sigma $

					First, we have to show that 
					$ \Gamma \entails [(l \land \PI(C_2)) \lor (l' \land \PI(C_1)) ]\sigma \lor ((D \lor E)\sigma)_\Gamma$.
					Suppose that in a model $M$ of $\Gamma$, $M \cancel \entails D_\Gamma$ and $\Gamma \cancel \entails E$. Otherwise we are done.
					The induction assumption hence simplifies to $M \entails \PI(C_1) \lor l$ and $M \entails \PI(C_2) \lor \lnot l'$ respectively.
					As $l\sigma = l'\sigma$, by a case distinction argument on the truth value of $l\sigma$, we get that either $M \entails (l \land \PI(C_2))\sigma$ or $M \entails  (\lnot l' \land \PI(C_1))\sigma$.


					Second, we show that 
					$\Delta \entails ((l \lor \lnot \PI(C_1)) \land (\lnot l' \lor \lnot \PI(C_2)))\sigma \lor ((D \lor E)\sigma)_\Delta$.
					Suppose again that in a model $M$ of $\Delta$, $M \cancel \entails D_\Delta$ and $\Gamma \cancel \entails E_\Delta$. 
					Then the required statement follows from the induction hypothesis.
					
					The language condition remains satisfied as only the common literal $l$ is added to the interpolant.


			\end{enumerate}

		\item[Factorisation.]	
			Suppose the last rule application is an instance of factorisation. Then it is of the form:
			\begin{prooftree}
				\AxiomCm{C_1: l \lor l' \lor D}
				\RightLabelm{\quad \sigma = \mgu(l, l')}
				\UnaryInfCm{C_1: (l \lor D)\sigma}
			\end{prooftree}

			Then the propositional interpolant $\PI(C)$ is defined as $\PI(C_1)$.
			By the induction hypothesis, we have:

			$\Gamma \entails \PI(C_1) \lor (l \lor l' \lor D)_\Gamma$

			$\Delta \entails \PI(C_1) \lor (l \lor l' \lor D)_\Delta$

			It is easy to see that then also:

			$\Gamma \entails (\PI(C_1)\lor (l \lor D)_\Gamma)\sigma$

			$\Delta \entails (\PI(C_1)\sigma \lor (l \lor D)_\Delta)\sigma$

			The restriction on the language trivially remains intact.
			

		\item[Paramodulation.]	
			Suppose the last rule application is an instance of paramodulation. Then it is of the form:
			\begin{prooftree}
				\AxiomCm{C_1: D \lor s=t}
				\AxiomCm{C_2: E[r]}
				\RightLabel{$\quad \sigma = \mgu(s, r)$}
				\BinaryInfCm{C: (D \lor E[t])\sigma}
			\end{prooftree}

			By the induction hypothesis, we have:

			$\Gamma \entails \PI(C_1) \lor (D\lor s=t)_\Gamma$

			$\Delta \entails \lnot \PI(C_1) \lor (D\lor s=t)_\Delta$

			$\Gamma \entails \PI(C_2) \lor (E[r])_\Gamma$

			$\Delta \entails \lnot \PI(C_2) \lor (E[r])_\Delta$

			First, we show that $\PI(C)$ as constructed in case \ref{def:PI_paramod_3} of the definition is a propositional interpolant in any of these cases:

			$\PI(C) = (s=t \land \PI(C_2)) \lor (s\neq t \land \PI(C_1)) $
			
			Suppose that in a model $M$ of $\Gamma$, $M \cancel \entails D\sigma$ and $M \cancel \entails E[t]\sigma$. Otherwise we are done.
			Furthermore, assume that $M \entails (s=t)\sigma$. Then $M \cancel \entails E[r]\sigma$, but then necessarily $M \entails \PI(C_2)\sigma$. \\
			On the other hand, suppose $M \entails (s\neq t)\sigma$. As also $M \cancel \entails D\sigma$, $M \entails \PI(C_1)\sigma$.
			Consequently, $M \entails [(s=t \land \PI(C_2)) \lor (s\neq t \land \PI(C_1))]\sigma \lor [(D \lor E)_\Gamma]\sigma$

			By an analogous argument, we get $\Delta \entails [(s=t \land \lnot \PI(C_2)) \lor (s\neq t \land \lnot \PI(C_1))]\sigma \lor [(D \lor E)_\Delta]\sigma$,
			which implies
			$\Delta \entails [( s\neq t \lor \lnot \PI(C_2)) \land (s = t \lor \lnot \PI(C_1))]\sigma \lor ((D \lor E)_\Delta)\sigma $

			%By a similar case distinction for a model $M$ of $\Delta$ and assuming that $M \cancel \entails D_\Delta$ and $M \cancel \entails E_\Delta$, we get that if $M \entails (s=t)\sigma$, $M \entails \lnot P$, which implies

			The language restriction again remains satisfied as the only predicate, that is added to the interpolant, is $=$.

			This concludes the argumentation for case \ref{def:PI_paramod_3}. 

			The interpolant of case \ref{def:PI_paramod_1} differs only by an additional formula added via a disjunction and hence condition \ref{rel_prop_interpol_cond1} of definition \ref{def:rel_prop_interpol} holds by the above reasoning.
			As the adjoined formula is a contradiction, its negation is valid which in combination with the above reasoning establishes condition \ref{rel_prop_interpol_cond2}.
			Since no new predicated are added, the language condition remains intact. 

			The situation in case \ref{def:PI_paramod_2} is somewhat symmetric: 
			As a tautology is added to the interpolant with respect to case \ref{def:PI_paramod_1}, condition \ref{rel_prop_interpol_cond1} is satisfied by the above reasoning.
			For condition \ref{rel_prop_interpol_cond2}, consider that the negated interpolant of case \ref{def:PI_paramod_1} implies the negated interpolant of this case.
			The language condition again remains intact.
			\qedhere
	\end{itemize}
\end{proof}

Before we are able to specify a procedure to transform the propositional interpolant generated by $\PI$ into a proper interpolant without any colored terms, we define a simpler but equally powerful form of resolution refutations.

\begin{defi}
	A resolution refutation is a \defiemph{tree refutation} if every clause is used at most once.
\end{defi}

The following lemma shows that this form does not restrict the calculus given that we allow multisets as initial clause sets.
\begin{lemma}
	\label{lemma:bin_tree_deduction}
	Every resolution refutation can be transformed into a tree refutation. 
\end{lemma}
\begin{proof}
	Let $\pi$ be a resolution refutation of $\Phi$.
	We prove that $\pi$ can be transformed into a tree refutation by induction on the number of clauses that are used multiple times.

	Suppose that no clause is used more than once in $\pi$. Then $\pi$ is a tree refutation.

	Otherwise let $\Psi$ be the set of clauses which is used multiple times.
	Let $C \in \Psi$ be such that no clause $D \in \Psi$ is used in the derivation leading to $C$. 
	Let $\chi$ be the derivation leading to $C$.

	Suppose $C$ is used $m$ times.
	We create another resolution refutation $\pi'$ from $\pi$ which contains $m$ copies of $\chi$ and replaces the $i$th use of the clause $C$ by the final clause of the $i$th copy of $\chi$, $1 \leq i \leq m$.
	In order to ensure that the sets of variables of the input clauses are disjoint, we rename the variables in each copy of $\chi$ and adapt $\pi'$ accordingly.
	Hence $\pi'$ is a resolution refutation of $\Phi$ where $m-1$ clauses are used more than once.
\end{proof}

In a tree refutation where the input clauses have a disjoint sets of variables, every variable has a unique ancestor which traces back to an input clause and hence appears only along a certain path.
This insight allows us to push substitutions of the variables upwards along this path and arrive at the following definition and lemma:



%For every unification $\sigma$ in the deduction and for every variable $x$, either $x\sigma = x$ or $x\sigma = t$ where $x$ does not occur in $t$.
%Hence along the path from the input clause to its unification or removal by resolution or factorisation, it occurs unchanged.
%Therefore replacing $x$ along the path with $\sigma x$, where $\sigma$ is a non-trivial unifier used on $x$ in the derivation creates still a valid refutation of whatever.

\begin{defi}
	A resolution refutation is a \defiemph{propositional refutation} if no nontrivial substitutions are employed.
\end{defi}

\begin{lemma}
	Let $\Phi$ be unsatisfiable.
	Then there is a propositional refutation of $\Phi$ which starts from instances of $\Phi$.
\end{lemma}
\begin{proof}
	Let $\pi$ be a resolution refutation of $\Phi$.
	By Lemma \ref{lemma:bin_tree_deduction}, we can assume without loss of generality that $\pi$ is a tree refutation where the sets of variables of the input clauses are disjoint.
	Furthermore, we can assume that only most general unifiers are employed in $\pi$.

	Then any unifier in $\pi$ is either trivial on $x$ or there is one unique unifier $\sigma$ in $\pi$ with $x\sigma = t$ where $x$ does not occur in $t$.
	Hence along the path through the deduction where $x$ occurs, it remains unchanged.
	Therefore we can create a new resolution refutation $\pi'$ from $\pi$ where $x$ is replaced by $t$.
	Clearly $\pi'$ is rooted in instances of $\Phi$.

	By application of this procedure to all variable occurring in $\pi$, we obtain a desired resolution refutation.
\end{proof}

Even though propositional refutations have nice properties for theoretical analysis, their use in practise is not desired as its construction involves a considerable blowup of the refutation. 
But its use is still justified in this instance as we can show for arbitrary refutations $\pi$
that the algorithm stated in \ref{def:PI} gives closely related results for both $\pi$ and its corresponding propositional refutation.

\begin{lemma}
	Let $\pi$ be a resolution refutation of $\Phi$ and $\pi'$ a propositional refutation corresponding to $\pi$.
	Then for every clause $C$ in $\pi$ and its corresponding clause $C'$ in $\pi'$, $\PI(C)\sigma = \PI(C')$, where $\sigma$ is the composition of the unifications of $\pi$ which are applied to the variables occurring in $C$ .
\end{lemma}
\begin{proof}
	For the construction of the propositional skeleton of $\PI(\cdot)$ only the coloring of the clauses is relevant and since this is the same in both $\pi$ and $\pi'$, it coincides for $\PI(C)$ and $\PI(C')$.

	Hence $\PI(C)$ and $\PI(C')$ differ only in their term structure. 
	To be more specific, in $\PI(C')$, the composition of substitutions that are applied in $\pi$ have already been applied to the initial clauses of $\pi'$. 
	Note that substitution commutes with the rules of resolution.
	Therefore the only difference between $\PI(C)$ and $\PI(C')$ is that at certain term positions, there are variables in $\PI(C)$ where in $\PI(C')$ by some substitution a different term is located. 
	But these substitutions are certainly applied by $\sigma$, hence $\PI(C)\sigma = \PI(C')$.
\end{proof}

This establishes the theoretical framework which is required to define and show the correctness of the procedure to construct a proper interpolant from the propositional interpolant.
The idea of this procedure will be to replace colored terms still occurring in the propositional interpolant with variables and quantifying them appropriately.
This replacement is referred to as lifting:


\begin{defi}
	Let $\Gamma$ and $\Delta$ be sets of first-order formulas, 
	$\phi$ a formula or a term, $t_1, \ldots, t_n$ the maximal $\Phi$-terms for $\Phi \in \{\Gamma, \Delta\}$ in $\phi$ and $x_1, \ldots, x_n$ fresh variables.
	Then $\lift{\Phi}{\phi}{x}$ denotes $\phi\termsubst{t_1/x_1}\ldots\termsubst{t_n/x_n}$.
\end{defi}

\begin{lemma} 
	\label{lemma:lift_commute}
	Let $A$ and $B$ be first-order formulas. Then it holds that:
	\begin{enumerate}
		\item $\lift{\Phi}{\lnot A}{x} \liff \lnot \lift{\Phi}{A}{x}$
		\item $\lift{\Phi}{A \circ B}{x} \liff ( \lift{\Phi}{A}{x} \circ \lift{\Phi}{B}{x} )$ for $\circ \in \{\land, \lor\}$
	\end{enumerate}
\end{lemma}

First, we consider the lifting of the $\Delta$-terms:\nopagebreak[4]

\begin{lemma}
	Let $\pi$ be a resolution refutation of $\Gamma \cup \Delta$. 
	Then $\Gamma \entails \lift{\Delta}{ \PI(C) \lor C }{x} $ for $C$ in $\pi$.
\end{lemma}
\begin{proof}
	We proof this result by induction on the number of rule applications in the propositional refutation corresponding to $\pi$. 
	Similar to the proof of \ref{prop:prop_interpol}, we show the strengthening:
	$\Gamma \entails \lift{\Delta}{ \PI(C) \lor C_\Gamma }{x} $ for $C$ in $\pi$.

	\begin{itemize}
		\item[Base case.]

			If no rules have been applied, $C$ is an instance of a clause of either $\Gamma$ or $\Delta$.
			In the former case, all $\Delta$-terms of $C$ were added by unification, hence by replacing them with variables, we obtain a clause $C'$ which still is an instance of $C$ and consequently is implied by $\Gamma$. 
			In the latter case, $\PI(C) = \top$. 

		\item[Resolution.] Suppose the last rule application is an instance of resolution. Then it is of the form:
			\begin{prooftree}
				\AxiomCm{C_1: D\lor l}
				\AxiomCm{C_2: E\lor \lnot l}
				\BinaryInfCm{C: D \lor E}
			\end{prooftree}

						By the induction hypothesis,

						$\Gamma \entails \lift{\Delta}{ \PI(C_1) \lor (D \lor l)_\Gamma }{x}$ and

						$\Gamma \entails \lift{\Delta}{ \PI(C_2) \lor (E \lor \lnot l)_\Gamma }{x}$

						which by Lemma \ref{lemma:lift_commute} is equivalent to

						$\Gamma \entails \lift{\Delta}{ \PI(C_1) }{x} \lor
						\lift{\Delta}{ D_\Gamma }{x} \lor
						\lift{\Delta}{ l_\Gamma }{x} \;\; ^{(\circ)} $
						and

						$\Gamma \entails \lift{\Delta}{ \PI(C_2) }{x} \lor
						\lift{\Delta}{ E_\Gamma }{x} \lor
						\lnot \lift{\Delta}{ l_\Gamma }{x} \;\; ^{(*)}$ .
				

			\begin{enumerate}
					\item Suppose $l$ is $\Gamma$-colored.
						Then $\PI(C) = \PI(C_1) \lor \PI(C_2)$.
						By using resolution of $^{(*)}$ and $^{(\circ)}$ on $\lift{\Delta}{l_\Gamma}{x}$, we get that 
						$$\Gamma \entails\lift{\Delta}{ \PI(C_1) }{x} \lor \lift{\Delta}{ \PI(C_2) }{x} \lor
						\lift{\Delta}{ D_\Gamma }{x} \lor
						\lift{\Delta}{ E_\Gamma }{x}.$$
						Several applications of Lemma \ref{lemma:lift_commute} give
						$\Gamma \entails\lift{\Delta}{ \PI(C_1)  \lor  \PI(C_2) \lor (D \lor E)_\Gamma }{x}$.
				
					\item Suppose $l$ is $\Delta$-colored.
						Then $\PI(C) = \PI(C_1) \land \PI(C_2)$.

						As $l$ and $\lnot l$ are not contained in $\Lang(\Gamma)$, we get that 

						$\Gamma \entails \lift{\Delta}{ \PI(C_1) }{x} \lor
						\lift{\Delta}{ D_\Gamma }{x}$
						and

						$\Gamma \entails \lift{\Delta}{ \PI(C_2) }{x} \lor
						\lift{\Delta}{ E_\Gamma }{x}$.

						So if in a model $M$ of $\Gamma$ we have that
						$\Gamma \cancel\entails \lift{\Delta}{ D_\Gamma }{x}$ and 
						$\Gamma \cancel\entails \lift{\Delta}{ E_\Gamma }{x}$, it follows that $\Gamma \entails \lift{\Delta}{ \PI(C_1) }{x}$ and $\Gamma \entails \lift{\Delta}{ \PI(C_2) }{x}$. Hence by Lemma~\ref{lemma:lift_commute}:
						$\Gamma \entails \lift{\Delta}{ \PI(C_1) \land \PI(C_2) }{x} \lor
						\lift{\Delta}{ (D \lor E)_\Gamma }{x}$.

					\item Suppose $l$ is grey. TODO

			\end{enumerate}


	\end{itemize}


\end{proof}

\clearpage







	\subsubsection{overbinding}

	Algorithm (input: propositional interpolant $\theta$):
	\begin{enumerate}
		\item Let $t_1, \ldots, t_n$ be the maximal occurrences of noncommon terms in $\theta$. Order $t_i$ ascendingly by term size. 
		\item Let $\theta^*$ be $\theta$ with maximal occurrences of $\Delta$-terms $r_1, \ldots, r_k$ replaced by fresh variables $x_1, \ldots, x_k$ and maximal occurrences of $\Gamma$-terms $s_1, \ldots, s_{n-k}$ by fresh variables $x_{k+1}, \ldots, x_{n}$
		\item Return $Q_1 x_1, \ldots Q_n x_n \theta^*$, where $Q_i$ is $\forall$ if $t_i$ is a $\Delta$-term and $\exists$ otherwise.
	\end{enumerate}

	Language condition easily established. To prove:

	$\Gamma \entails Q_1 x_1, \ldots Q_n x_n \theta^*$

	$\Delta \entails \lnot Q_1 x_1, \ldots Q_n x_n \theta^*$

	We know that $\theta$ works, just the terms are missing.

\subsection{final step of huang's proof}

\begin{thm}
	$Q_1 z_1 \ldots Q_n z_n \PI(\square)^*(z_1, \ldots, z_n)$ is a craig interpolant (order as in huang).
\end{thm}
\begin{proof}
	By Lemma \ref{lemma:gamma_entails_interpolant}, $\Gamma \entails \forall x_1 \ldots \forall x_n \overline{\PI(\square)}(x_1, \ldots, x_n)$.

	The terms in $\overline{PI(\square)}$ are either among the $x_i$, $1 \leq i \leq n$ or grey terms or $\Gamma$-terms.
	Let $t$ be a maximal $\Gamma$-term in $\overline{\PI(\square)}$.
	Then it is of the form $f(x_{i_1}, \ldots, x_{i_{n_x}}, u_1, \ldots, u_{n_u}, v_1, \ldots, v_{n_v})$, where $f$ is $\Gamma$-colored, the $x_j$ are as before, the $u_j$ are grey terms and the $v_j$ are $\Gamma$-terms.\todo{basically only need the $x_j$}{}
	Note that the $\Delta$-terms, which are replaced by the $x_{i_1}, \ldots, x_{i_{n_x}}$ are of strictly smaller size than $t$ as they are ``strict'' subterms of $t$.

	In $\PI(\square)^*$, $t$ will be replaced by some $z_j$, which is existentially quantified.
	For this $z_j$, $t$ is a witness as due to the quantifier ordering, all the $x_{i_1}, \ldots, x_{i_{n_x}}$ will be quantified before the existential quantification of $z_j$.
	Therefore $\Gamma \entails Q_1 z_1 \ldots Q_n z_n \PI(\square)^*(z_1, \ldots, z_n)$.

	TODO: $\Delta$
\end{proof}



