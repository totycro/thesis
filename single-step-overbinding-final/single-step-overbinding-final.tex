\documentclass[,%fontsize=11pt,%
	%landscape,
	%DIV8, % mehr text pro seite als defaultyyp
	%DIV10, 
	%DIV=calc,%
	draft=false,% final|draft % draft ist platzsparender (kein code, bilder..)
	%titlepage,
	numbers=noendperiod
	oneside,openany
	a4paper,
	11pt,
%]{scrartcl}
]{memoir}

\usepackage{lscape}
\usepackage{stackengine}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage{enumerate}
\usepackage{paralist}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,backgrounds,graphs,%
	matrix,patterns,arrows,decorations.pathmorphing,decorations.pathreplacing,%
	positioning,fit,calc,decorations.text,shadows%
}


\input{../latex_header.tex}

% subsections also in toc
\setcounter{tocdepth}{2}

%\declaretheorem[title=Theorem,qed=$\triangle$,parent=chapter]{thm}
\newcommand{\thmqed}{$\square$} % for thms without proof
\newcommand{\propqed}{$\square$} % for props without proof
\declaretheorem[title=Theorem]{thm}
\declaretheorem[title=Proposition,sibling=thm]{prop}
%\declaretheorem[title=Lemma,parent=chapter]{lemma}
\declaretheorem[sibling=thm]{lemma}
\declaretheorem[title=Corollary,sibling=thm]{corr}
\declaretheorem[sibling=thm,title=Definition,style=definition,qed=$\triangle$]{defi}
%\declaretheorem[title=Definition,qed=$\triangle$,parent=chapter]{defi}
\declaretheorem[title=Example,style=definition,qed=$\triangle$,sibling=thm]{exa}

\declaretheorem[sibling=thm,title=Conjecture]{conj}

\declaretheorem[title=Remark,style=remark,numbered=no,qed=$\triangle$]{remark}

\def\proofSkipAmount{ \vskip -0.1em } 


%\usepackage{bussproof}

%\usepackage{vaucanson-g}
\usepackage{amssymb}
\usepackage{latexsym}

% for color-highlighted code
%\usepackage{color} % for grey comments
%\usepackage{alltt}

%\usepackage[doublespacing]{setspace}
%\usepackage[onehalfspacing]{setspace}
%\usepackage[singlespacing]{setspace}
%\usepackage{tabularx}
%\usepackage{hyperref}
%\usepackage{comment}
%\usepackage{color}
%\usepackage[final]{listings} % sourcecode in document
%\usepackage{url}      % for urls
%\usepackage{multicol}
%\usepackage{float}
%\usepackage{caption}
%\usepackage{amsmath}
%\usepackage{amssymb}
%
%\usepackage{graphicx}
%
%\usepackage[authoryear]{natbib} % \cite ; square|round etc.
%\usepackage[numbers,square]{natbib}
%\usepackage[square, authoryear]{natbib}
%\usepackage[language=english]{biblatex}

%\bibliographystyle{plain}
%\bibliographystyle{alpha}
%\bibliographystyle{alphadin}
%\bibliographystyle{dinat}
%\bibliographystyle{chicago}
%\bibliographystyle{plainnat}

% smaller url style
\makeatletter
\def\url@leostyle{%
\@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
\urlstyle{leo}

\newcommand{\myfig}[5] {
	\begin{figure}[tbph]
		\centering
		\includegraphics[#3]{#1}
		\caption[#4]{#5}
		\label{fig:#2}
	\end{figure}
}

%\usepackage{thmtools} % actually already in latex_header.tex ...

\usepackage{amsthm}


\chapterstyle{madsen}

% define page numbering styles
\makepagestyle{numberCorner}
\makeevenfoot{numberCorner}{\thepage}{}{}
\makeoddfoot{numberCorner}{}{}{\thepage}

\makepagestyle{numberCenter}
%\makeevenfoot{numberCenter}{}{\thepage}{}
%\makeoddfoot{numberCenter}{}{\thepage}{}
%
%\makeevenhead{numberCenter}{\thechapter}{}{\thesection}
%\makeoddhead{numberCenter}{\thesection }{}{\thechapter}
\makeheadrule{numberCenter}{\textwidth}{1pt}

\makeevenhead{numberCenter}{\thepage}{}{\leftmark}
\makeoddhead{numberCenter}{\rightmark}{}{\thepage}


\makeatletter
\makepsmarks{numberCenter}{
  \def\chaptermark##1{\markboth{%
        \ifnum \value{secnumdepth} > -1
          \if@mainmatter
            \chaptername\ \thechapter\ --- %
          \fi
        \fi
        ##1}{}}
  \def\sectionmark##1{\markright{%
        \ifnum \value{secnumdepth} > 0
          \thesection. \ %
        \fi
        ##1}}
}
\makeatother
\newcommand{\mysetpagestyle}{ 
  %\pagestyle{numberCorner}
  \pagestyle{numberCenter}
}
\mysetpagestyle





\usepackage{refcheck}

\settypeblocksize{0.65\stockheight}{0.65\stockwidth}{*}
\setlrmargins{*}{*}{1.2}
\setulmargins{*}{*}{1.4}
\checkandfixthelayout[nearest]


\begin{document}


\section{referenced lemmas from previous sections}
\begin{quote}
\begin{lemma}[Commutativity of lifting and logical operators]
	\label{lemma:lift_commute}
	\label{lemma:lift_logic_commute}
	Let $A$ and $B$ be first-order formulas and $s$ and $t$ be terms. Then it     holds that:
	\begin{enumerate}
		\item $\lift{\Phi}{\lnot A}{z} \spas\semiff{} \lnot \lift{\Phi}{A}{z}$
		\item $\lift{\Phi}{A \circ B}{z} \spas\semiff{} ( \lift{\Phi}{A}{z} \circ   \lift{\Phi}{B}{z} )$ for  $\circ \in \{\land, \lor\}$
		\item $\lift{\Phi}{s = t}{z} \spas\semiff{} ( \lift{\Phi}{s}{z} =           \lift{\Phi}{t}{z} )$
	\end{enumerate}
\end{lemma}

\begin{restatable}[Commutativity of lifting and substitution]{lemma}{lemmaCommutLiftSubst}
	\label{lemma:lif}
	Let $C$ be a clause and $\sigma$ a substitution such that no lifting variable occurs in $C$ or $\sigma$.
	%Let $t_1,\ldots,t_n$ be all maximal $\Delta$-terms in this context, i.e.\ those that occur in $C$ or $C\sigma$,  and 
	%$x_1, \ldots, x_n$ the corresponding fresh variables to replace the $t_i$ (i.e.~none of the $x_i$ occur in $C$).
	Define $\sigma'$ with $\dom(\sigma') = \dom(\sigma) \cup \{ z_t \mid t\sigma \neq t \}$ such that for a variable $z$, 
	\[
		x \sigma' =
		\begin{cases} 
			z_{t\sigma} & \text{ if } x = z_t \text{ and } t\sigma \neq t \\
			\lifphi{x\sigma} & \text{ otherwise}
		\end{cases} 
	\]

	Then
	$\lifphi{C\sigma} =
	\lifphi{C}\sigma'$.
\end{restatable}
\end{quote}

\chapter{Interpolant extraction from resolution proofs in one phase} 


While the previous chapter demonstrates that it is possible to extract propositional interpolants and lift them from the colored symbols later in order to obtain a proper interpolant, we now present a novel approach, which only operates with grey intermediary interpolants.
This is established by lifting any term which is added to the interpolant. 

By its nature, this approach requires an alternate strategy than the proof of the extraction in two phases as a commutation of substitution and lifting is no longer possible if lifting variables are present.
Let us recall the corresponding lemma from the previous chapter:
\lemmaCommutLiftSubst*
Consider the following illustration of a problem of the notion of applying this lemma to terms containing lifting variables:

\begin{exa}
	Let $\sigma = \{x \mapsto a\}$
	and consider the terms $f(x)$ and $f(a)$, where $f$ and $a$ are colored symbols.
	Clearly $f(x)\sigma = f(a)$ and therefore necessarily $z_{f(x)}\sigma' = z_{f(a)}$.

	But now consider $x_{f(x)} \sigma$.
	As $z_{f(x)}$ is a lifting variable, it is not affected by unifiers from resolution derivations and also not by $\sigma$.
	Hence $z_{f(x)}\sigma = z_{f(x)}$ and therefore $\lifboth{z_{f(x)}\sigma} = \lifboth{z_{f(x)}} = z_{f(x)}$, but $\lifboth{z_{f(x)}}\sigma' = z_{f(x)}\sigma' = z_{f(a)}$.
	So $\lifboth{z_{f(x)}\sigma} \neq \lifboth{z_{f(x)}}\sigma'$.

	We see here that there are circumstances under which in order to commute lifting and substitution,
	the substitution $\sigma'$ is required to conform to the equation
	$z_{f(x)}\sigma' =\nolinebreak z_{f(a)}$, 
	whereas in others, it must hold that
	$z_{f(x)}\sigma' = z_{f(x)}$.
\end{exa}


\section{Definition of the extraction algorithm}

The extracted interpolants are prenex formulas, where 
the quantifier block and the matrix of the formula are calculated separately in each step of the traversal of the resolution refutation.


\subsection{Extraction of the interpolant matrix $\AImat$ and calculation of $\AIcl$}

$\AImat$ is inspired by the propositional interpolants $\PI$ from Definition \ref{def:PI}.
Its difference lies in the fact that the lifting occurs in every step of the extraction.
This however necessitates applying these liftings to the clauses of the resolution refutation as well.
For a clause $C$ of the resolution refutation, we will denote the clause with the respective liftings applied by $\AIcl(C)$ (a formal definition will be given below), and for a term $t$ at position $p$ in $C$, we denote $\AIcl(C)\at{p}$ by $t\cl$.

Now we can define preliminary versions of $\AImatpre$ and $\AIclpre$:

\begin{defi}[$\AImatpre$ and $\AIclpre$]
	Let $\pi$ be a resolution refutation of $\Gamma \cup \Delta$.

	For a clause $C$ in $\pi$, \defiemph{$\AImatpre(C)$} and \defiemph{$\AIclpre(C)$} are defined as follows:
	\begin{itemize}
		\item[Base case.]
			If $C \in \Gamma$, $\AImatpre(C) \defeq \bot$.
			If otherwise $C \in \Delta$, $\AImatpre(C) \defeq \top$.

			In any case, $\AIclpre(C) \defeq \lifboth{C}$.
		\item[Resolution.]

			If the clause $C$ is the result of a resolution step of $C_1: D \lor l$ and $C_2: E \lor \lnot l'$ using a unifier $\sigma$ such that $l\sigma =  l'\sigma$, then $\AImatpre(C)$ and $\AIclpre$ are defined as follows:

			$\AIclpre(C) \defeq \lifboth{(\AIclpre(C_1) \setminus \{l\fromclause\})\sigma} \spam\lor \lifboth{(\AIclpre(C_2)\setminus \{l\fromclause'\})\sigma} $

			\begin{enumerate}

				\item If $l$ is $\Gamma$-colored:
					$\AImatpre(C) \defeq \lifboth{\AImatpre(C_1)\sigma}\spas\lor \lifboth{\AImatpre(C_2)\sigma} $

				\item If $l$ is $\Delta$-colored:
					$\AImatpre(C) \defeq \lifboth{\AImatpre(C_1)\sigma}\spas\land \lifboth{\AImatpre(C_2)\sigma} $

				\item If $l$ is grey:
					$\AImatpre(C) \defeq
					(\lnot {\lifboth{l'\fromclause\sigma}} \land \lifboth{\AImatpre(C_1)\sigma}) \spam\lor
					(\lifboth{l\fromclause\sigma}\land \lifboth{\AImatpre(C_2)\sigma })
					$

			\end{enumerate}

		\item[Factorisation.]
			If the clause $C$ is the result of a factorisation of $C_1: l \lor l' \lor D$ using a unifier $\sigma$ such that $l\sigma = l'\sigma$, then $\AImatpre(C) \defeq \lifboth{\AImatpre(C_1)\sigma}$ and $\AIclpre(C) \defeq \lifboth{ (\AIclause(C_1) \setminus\nolinebreak \{l'\cl\})\sigma}$.
			\qedhere

	\end{itemize}
\end{defi}

Note that in $\AImatpre$ and $\AIclpre$, it is possible that there for a colored term $t$ in $C$ that $t\cl \neq z_t$ as illustrated by the following examples:

\begin{exa}
	We consider a resolution refutation of the initial clause sets
	$\Gamma = \{ R(c), \lnot Q(v) \}$
	and
	$\Delta = \{ \lnot R(u) \lor Q(g(u)) \}$:
	\begin{prooftree}
		\AxiomCm{ R(c) }
		\AxiomCm{ \lnot R(u) \lor Q(g(u)) }
		\prflbl{\resruleres}{y\mapsto c}
		\BinaryInfCm{ Q(g(c)) }

		\AxiomCm{ \lnot Q(v) }
		\prflbl{\resruleres}{v\mapsto g(c)}
		\BinaryInfCm{ \square }
	\end{prooftree}

	We now replace every clause $C$ by $\AImatpre(C) \mid \AIclpre(C)$ in order to visualize the steps of the algorithm:
	\begin{prooftree}
		\AxiomCm{ \bot \mid  R(y_c) }
		\AxiomCm{ \top \mid \lnot R(u) \lor \lnot Q(x_{g(u)}) }
		\prflbl{\resruleres}{y\mapsto c}
		\BinaryInfCm{ R(y_c) \mid  Q(x_{g(u)}) }

		\AxiomCm{ \bot \mid \lnot Q(v) }
		\prflbl{\resruleres}{v\mapsto g(c)} 
		\BinaryInfCm{ \lnot Q(x_{g(c)}) \land R(y_c) \mid  \square }
	\end{prooftree}

	By quantifying $y_c$ existentially and $x_{g(c)}$ universally\footnote{The procedure for calculating the quantifier block is defined in section \ref{sec:arrow_quantifier_block}}, we obtain an interpolant for $\Gamma \cup \Delta$:
	$\exists y_c \forall x_{g(c)} (\lnot Q(x_{g_c}) \land R(y_c))$.
	Note however that $\lifboth{Q(g(c))} = Q(x_{g(c)})$, but $\AImat(Q(g(c))) = Q(x_{g(u)})$.
	This example shows that this circumstance is not necessarily an obstacle for the correctness of this algorithm.
\end{exa}
\begin{exa}
	\label{exa:2b}
	We consider a resolution refutation of the initial clause sets
	$\Gamma = \{ R(c), P(c) \}$
	and
	$\Delta = \{ \lnot R(u) \lor \lnot Q(g(u)), \lnot P(v) \lor Q(g(v))\}$:
	\begin{prooftree}
		\AxiomCm{ \lnot R(u) \lor \lnot Q(g(u)) }
		\AxiomCm{ R(c) }
		\prflbl{\resruleres}{u\mapsto c}
		\BinaryInfCm{ \lnot Q(g(c)) }


		\AxiomCm{ \lnot P(v) \lor Q(g(v)) }
		\AxiomCm{ P(c) }
		\prflbl{\resruleres}{v\mapsto c}
		\BinaryInfCm{ Q(g(c)) }

		\prflblid{\resruleres}
		\BinaryInfCm{\square}

	\end{prooftree}

	We now again display $\AImatpre(C) \mid \AIclpre(C)$ for every clause $C$ of the refutation:
	\begin{prooftree}
		\AxiomCm{ \top \mid  \lnot R(u) \lor \lnot Q(x_{g(u)}) }
		\AxiomCm{ \bot \mid R(y_c) }
		\prflbl{\resruleres}{u\mapsto c}
		\BinaryInfCm{ R(y_c) \mid  \lnot Q(x_{g(u)}) }

		\AxiomCm{ \top \mid \lnot P(v) \lor Q(x_{g(v)}) }
		\AxiomCm{ \bot \mid P(y_c) }
		\prflbl{\resruleres}{v\mapsto c}
		\BinaryInfCm{ P(y_c) \mid  Q(x_{g(v)}) }

		\prflblid{\resruleres}
		\BinaryInfCm{ (Q(x_{g(v)}) \land R(y_c)) \spam\lor (\lnot Q(x_{g(u)}) \land P(y_c))  \mid \square}

	\end{prooftree}

	Note again that here, we have that
	%\[
	$
	\lifboth{\lnot Q(g(c))} = \lnot Q(x_{g(c)}) \spam\neq \AIclpre(\lnot Q(g(c))) = \lnot Q(x_{g(u)})
	$
	%\]
	%as well as a similar discrepancy for the other clause $Q(x_{g(c)})$.
	and
	%\[
	$
	\lifboth{Q(g(c))} = Q(x_{g(c)}) \spam\neq \AIclpre(Q(g(c))) =  Q(x_{g(v)}).
	$
	%\]
	However in this instance, it is not possible to find quantifiers for the free variables of $\AImatpre(\square)$ such that by binding them, an interpolant is produced.
	For the naive approach, namely to use $\exists y_c \forall x_{g(v)} \forall x_{g(u)}$ as prefix, it holds that 
	$\Gamma \notentails \exists y_c \forall x_{g(v)} \forall x_{g(u)} ((Q(x_{g(v)}) \land R(y_c)) \spam\lor (\lnot Q(x_{g(u)}) \land P(y_c)))$.
	This failure is possible as intuitively, resolution deductions are valid by virtue of the resolved literals being equal.
	The interpolant extraction procedure exploits this property not directly on the clauses but on the lifted clause, i.e.\ on $\AIcl(C)$ for a clause $C$.
	Note that by ensuring that for resolved literals $l$ and $l'$, it holds that $l\cl = l'\cl$, we can obtain an interpolant, for instance: 
	$
	\exists y_c \forall x^\ast ((Q(x^\ast) \land R(y_c)) \spam\lor (\lnot Q(x^\ast) \land P(y_c)))
	$.
\end{exa}

In order to avoid the pitfall shown in Example \ref{exa:2b} and to generalize the indicated solution,
we define a function on resolved literals calculating a substitution, which ensures that the literals in the lifted clause, which correspond to the resolved literals, are equal.

\begin{defi}[$\aiu$] 
	For resolved or factorised literals $l $ and $l'$ of a resolution derivation step with a unifier $\sigma$ such that $l\sigma = l'\sigma$,
	and $\lifboth{l\cl\sigma} = P(s_1, \dots, s_n)$ and $\lifboth{l'\cl\sigma} = P(t_1, \dots, t_n)$, we define:
	\[
		\aiu (P(s_1, \dots, s_n), P(t_1, \dots, t_n)) \defeq \bigcup_{i=1}^n \aiu(s_i, t_i)
	\]
	For terms $s$ and $t$ where
	$s = \lifboth{l\fromclause\sigma}\at{p}$
	and 
	$t = \lifboth{l'\fromclause\sigma}\at{p}$
	for some position $p$, we define:
	\[
		\aiu (s, t) \defeq
		\begin{cases}
			\bigcup_{i=1}^n \aiu(s_i, t_i) & \text{if $s$ is grey and $s=f_s(s_1, \dots, s_n)$, $t = f_{t}(t_1,\dots, t_n)$\footnotemark} \\
			\{z_{s'} \mapsto z_r, z_{t'} \mapsto z_r\} &
			%\parbox[t]{.70\textwidth}{
			\text{if $s$ is a lifting variable $z_{s'}$, $t = z_{t'}$,
			and $z_r = \lifboth{l\sigma}\at{p}$}
			%}
			%\{x_j \mapsto x_m, x_k \mapsto x_m\} & \parbox[t]{.75\textwidth}{if $a\cl = x_j$ and $b\cl = x_k$, both lifting variables, and $x_m$ is the       corresponding lifted term in the unified literal, i.e. $x_m = \lifboth{a\sigma} = \lifboth{b\sigma}$. This means to just take the term from the   literal in the actual clause.}
			\qedhere
		\end{cases}
	\]
	\footnotetext{Note that constants are treated as function symbols of arity zero.}
\end{defi}

\begin{prop}
	\label{prop:tau_dom_ran}
	Let $l$ and $l'$ be the resolved or factorised literals of a resolution derivation step and $\sigma$ the unifier employed in this step.
	Furthermore let $\tau = \aiu(\lifboth{l\fromclause\sigma}, \lifboth{l'\fromclause\sigma})$.
	Then $\dom(\tau)$ consists exactly of the lifting variables of $\lifboth{l\fromclause\sigma}$ and $\lifboth{l'\fromclause\sigma}$ and $\ran(\tau)$ consists exactly of the lifting variables of $\lifboth{l\sigma}$.
\end{prop}

\todo[inline]{possibly argue here why $\aiu$ is well-defined (but it follows more or less directly from a later lemma)}


\begin{defi}[$\AImat$ and $\AIcl$]
	Let $\pi$ be a resolution refutation of $\Gamma \cup \Delta$.
	\defiemph{$\AImat(\pi)$} is defined to be $\AImat(\square)$, where $\square$ is the empty box derived in $\pi$.

	For a clause $C$ in $\pi$, \defiemph{$\AImat(C)$} and \defiemph{$\AIcl(C)$} are defined inductively as follows:
	\begin{itemize}
		\item[Base case.]
			If $C \in \Gamma$, $\AImat(C) \defeq \bot$.
			If otherwise $C \in \Delta$, $\AImat(C) \defeq \top$.

			In any case, $\AIcl(C) \defeq \lifboth{C}$.
		\item[Resolution.]

			If the clause $C$ is the result of a resolution step of $C_1: D \lor l$ and $C_2: E \lor \lnot l'$ using a unifier~$\sigma$ such that $l\sigma = l'\sigma$, 
			then 
			let $\tau = \aiu(\lifboth{l\cl\sigma}, \lifboth{l'\cl\sigma})$ and define
			$\AImat(C)$ and $\AIcl(C)$ as follows:

			$\AIcl(C) \defeq \lifboth{(\AIclause(C_1) \setminus \{l\fromclause\})\sigma}\tau \spam\lor \lifboth{(\AIclause(C_2)\setminus \{l\fromclause'\})\sigma}\tau $
			\begin{enumerate}

				\item If $l$ is $\Gamma$-colored:
					$\AImat(C) \defeq \lifboth{\AImat(C_1)\sigma}\tau\spas\lor \lifboth{\AImat(C_2)\sigma}\tau $

				\item If $l$ is $\Delta$-colored:
					$\AImat(C) \defeq \lifboth{\AImat(C_1)\sigma}\tau\spas\land \lifboth{\AImat(C_2)\sigma}\tau $

				\item If $l$ is grey:
					$\AImat(C) \defeq
					(\lnot {\lifboth{l'\fromclause\sigma}}\tau \land \lifboth{\AImat(C_1)\sigma}\tau) \spam\lor
					(\lifboth{l\fromclause\sigma}\tau \land \lifboth{\AImat(C_2)\sigma}\tau)
					$

			\end{enumerate}

		\item[Factorisation.]
			If the clause $C$ is the result of a factorisation of $C_1: l \lor l' \lor D$ using a unifier~$\sigma$ such that $l\sigma = l'\sigma$, then let $\tau = \aiu(\lifboth{l\cl\sigma}, \lifboth{l'\cl\sigma})$ and define 
			$\AImat(C)$ and $\AIcl(C)$ as follows:

			$\AImat(C) \defeq{} \lifboth{\AImat(C_1)\sigma}\tau$

			$\AIcl(C) \defeq \lifboth{ (\AIclause(C_1) \setminus\nolinebreak \{l'\cl\})\sigma}\tau$
			\qedhere

	\end{itemize}
\end{defi}

\begin{defi}
	$\AImatde(C)$ ($\AIclde(C)$) for a clause $C$ is defined as $\AImat(C)$ ($\AIcl(C)$) with the difference that in its inductive definition, every lifting $\lifboth{\varphi}$ for a formula or term $\varphi$ is replaced by a lifting of only the $\Delta$-terms $\lifdeltanovar{\varphi}$.
\end{defi}

\begin{lemma}
	\label{lemma:no_colored_terms}
	Let $C$ be a clause of a resolution refutation of $\Gamma\cup\Delta$.
	$\AImat(C)$ and $\AIcl(C)$ do not contain colored symbols. 
	$\AImatde(C)$ and $\AIclde(C)$ do not contain \mbox{$\Delta$-c}olored symbols. 
\end{lemma}
\begin{proof}
	For $\AImat(C)$ and $\AIcl(C)$, consider the following:
	In the base case of the inductive definitions of $\AImat(C)$ and $\AIcl(C)$, no colored symbols occur.
	In the inductive steps, any colored symbol which is added by $\sigma$ to intermediary formulas is lifted.
	By Proposition~\ref{prop:tau_dom_ran}, $\ran(\tau)$ only consists of lifting variables.

	For $\AImatde(C)$ and $\AIclde(C)$, a similar argument goes through by reading colored as $\Delta$-colored. 
\end{proof}

\begin{lemma}
	\label{lemma:substitute_and_lift}
	Let $\sigma$ be a substitution and $F$ a formula without $\Phi$-colored terms such that for a set of formulas $\Psi$, $\Psi \entails F$.
	Then $\Psi \entails \lifphi{F\sigma}$.
\end{lemma}
\begin{proof}
	$\lifphi{F\sigma}$ is an instance of $F$: 
	$\sigma$ substitutes variables either for terms not containing $\Phi$-colored symbols or by terms containing $\Phi$-colored symbols.
	For the first kind, the lifting has no effect.
	For the latter, the lifting only replaces subterms of the terms introduced by the substitution by a lifting variable such that the original structure of $F$ remains invariant as it by assumption does not contain colored terms.
\end{proof}

\begin{lemma}
	Let $l$ and $l'$ be resolved or factorised literals in a resolution derivation step creating a clause $C$ and 
	$\tau = \aiu(\lifboth{l\cl\sigma}, \lifboth{l'\cl\sigma})$.
	For any substitution $(z_s \mapsto z_t) \in \tau$, 




	\mytodo{check which statment we actually need (resolved literal, clause?)}

	make sure that it works for positions in the resolved literals as well as in the clause


\end{lemma}

\begin{lemma}
	\largered{ either reduce to ``equal up to index of lifting variables'' or use elaborate version as given below with additional lemma about how every $x_s$ refers to the same term PLUS variable renaming convention } 
	\label{lemma:literals_clause_simgeq}
	Let $\lambda$ be a literal in a clause $C$ occurring in a resolution refutation of $\Gamma\cup\Delta$.
	Then $\AIcl(C)$ contains a literal $\lambda\cl$ such that $\lambda\cl \simgeq \lifboth{\lambda}$, where $\simgeq$ is defined as follows:
	\[
		\varphi \simgeq \varphi' \semiff
		\begin{cases}
			P = P' \land \bigwedge_{i=1}^n s_i \simgeq s'_i &  \text{ if $\varphi = P(s_1, \dots, s_n)$ and $\varphi' = P'(s'_1, \dots, s'_n)$} \\
			f = f' \land \bigwedge_{i=1}^n s_i \simgeq s'_i &  \text{ if $\varphi = f(s_1, \dots, s_n)$ and $\varphi' = f'(s'_1, \dots, s'_n)$} \\
			x = x' & \text{ if $\varphi, \varphi'$ are non-lifting variables, $\varphi = x$ and $\varphi' = x'$} \\
			s' \text{ is a specialisation of } s  & \text{ if $\varphi, \varphi'$ are lifting variables, $\varphi = z_s$ and $\varphi' = z_{s'}$} \\
		\end{cases}
	\]
	For resolved or factorised literals $\lambda$ we furthermore have that $\lifboth{\lambda\cl\sigma}\tau \simgeq \lifboth{\lambda\sigma}$.
	\todo[inline]{introduce definition for characterising the relation between $C$ and $\AIcl(C)$}
\end{lemma}
\begin{proof}
	We proceed by induction on the resolution refutation.
	\begin{description}
		\item{Base case.}
			If for a clause $C$ either $C\in \Gamma$ or $C \in \Delta$ holds, then $\AIcl(C) = \lifboth{C}$.
			Therefore for every literal $l$ in $C$, there exists a literal $l\cl$ in $\AIcl(C)$ such that $\lifboth{l} = l\cl$, which implies $l\cl \simgeq \lifboth{l}$.

		\item{Resolution.}
			If the clause $C$ is the result of a resolution step of $C_1: D \lor l$ and $C_2: E \lor \lnot l'$ using a unifier~$\sigma$ such that $l\sigma = l'\sigma$,
			then let $\tau = \aiu(\lifboth{l\cl\sigma}, \lifboth{l'\cl\sigma})$.
			Let $\lambda$ be a literal in $C_1$ or $C_2$. 
			Note that every literal in $C$ is of the form $\lambda\sigma$.
			By the induction hypothesis, there is a literal in $\AIcl(C_1)$ or $\AIcl(C_2)$ respectively such that $\lambda\cl \simgeq \lifboth{\lambda\cl}$.
			If $\lambda \not\in\{l,l'\}$, then $\lifboth{\lambda\cl\sigma}\tau$ is contained in $\AIcl(C)$.
			Hence in any case, it remains to show that $\lifboth{\lambda\cl\sigma}\tau \simgeq \lifboth{\lambda\sigma}$. 


			%Every literal in $C$ is of the form $\lambda\sigma$ for some $\lambda \in C_1$ or $\lambda \in C_2$. Without loss of generality let $\lambda \in C_1$.
			%By the induction hypothesis, there is a literal in $\AIcl(C_1)$ such that $\lambda\cl \simgeq \lifboth{\lambda\cl}$.

			%As $\lambda \neq l$, by the definition of $\AIcl$, $\lifboth{\lambda\cl\sigma}\tau$ is contained in $\AIcl(C)$.
			%It remains to show that $\lifboth{\lambda\cl\sigma}\tau \simgeq \lifboth{\lambda\sigma}$.

			We perform an induction on the structure of $\lambda\cl$ and $\lambda$ 
			by letting $p$ be the position of the current term in the induction and $t\cl = \lambda\cl\at{p}$ as well as $t=\lambda\at{p}$.
			\begin{itemize}
				\item
					Suppose that $t$ is a non-lifting variable.
					As by the induction hypothesis $\lifboth{t\cl} \simgeq t$, $t\cl$ is a non-lifting variable as well and $t = t\cl$.
					But then $\lifboth{t\cl\sigma} = \lifboth{t\sigma}$.
					If $\tau$ is trivial on $\lifboth{t\cl\sigma}$, we are done as then $\lifboth{t\cl\sigma}\tau = \lifboth{t\sigma}$, so assume that it is not.

					But by the definition of $\aiu$, the substitutions in $\tau$ only update lifting variables to correspond to the terms in the clause of the actual resolution derivation.
					More formally, $\lifboth{t\cl\sigma}\tau = z_s$ for some term $s$ implies that $\lifboth{\lambda\sigma}\at{p} = z_s$, but then $z_s = t$.
					\todo[inline]{outsource this thought to lemma after definition of $\aiu$ in case needed elsewhere}

				\item
					Suppose that $t$ is colored term.
					Then $\lifboth{t}$ is a lifting variable and by the induction hypothesis, $t\cl$ is one as well such that 
					$\lifboth{t}$ is a specialisation of $t\cl$.
					As lifting variables are not affected by the unifications occurring in resolution derivations, we only need to consider modifications by means of $\tau$. 
					But as we have seen in the previous case, if $\tau$ substitutes $\lifboth{t\cl\sigma}$, then it does so by $t$.
					\todo[inline]{lemma}
					Hence we obtain that $\lifboth{t\cl\sigma}\tau \simgeq \lifboth{t\sigma}$.

				\item
					Suppose that $t$ is a grey term of the form $f(s_1, \dots, s_n)$.
					Then $\lifboth{t} = f(\lifboth{s_1}, \dots, \lifboth{s_n})$ and by the induction hypothesis, $t\cl = f(r_1, \dots, r_n)$ such that 
					$\bigwedge_{i=1}^n r_i \simgeq \lifboth{s_i}$ .
					By the induction hypothesis applied to the parameters of $\lifboth{t}$ and $\lifboth{t\cl}$, we obtain that  $\lifboth{r_i\sigma}\tau \simgeq \lifboth{s_i\sigma}$ for $1\nolinebreak \leq\nolinebreak i\nolinebreak \leq\nolinebreak n$.
					Hence $  f(\lifboth{r_1\sigma}, \dots, \lifboth{r_n\sigma}) \simgeq f(\lifboth{s_1\sigma}, \dots, \lifboth{s_n\sigma})$, 
					which however is nothing else than 
					$\lifboth{t\cl\sigma} \simgeq \lifboth{t\sigma} $.

			\end{itemize}

		\item{Factorisation.}
			If the clause $C$ is the result of a factorisation, then we can argue analoguously as for resolution.
			%If the clause $C$ is the result of a factorisation of $C_1: l \lor l' \lor D$ using a unifier~$\sigma$ such that $l\sigma = l'\sigma$, then let $\tau = \aiu(\lifboth{l\cl\sigma}, \lifboth{l'\cl\sigma})$.
			%The rest of this proof resembles the case of resolution:
			%Every literal in $C$ is of the form $\lambda\sigma$ for some $\lambda \in C_1$.
			%By the induction hypothesis, there is a literal in $\AIcl(C_1)$ such that $\lambda\cl \simgeq \lifboth{\lambda}$.
			%As $\lambda \neq l$, by the definition of $\AIcl$, $\lifboth{\lambda\cl\sigma}\tau$ is contained in $\AIcl(C)$.
			%A similar induction argument as for the case of resolution shows that $\lifboth{\lambda\cl\sigma}\tau \simgeq \lifboth{\lambda\sigma}$.
			\qedhere
	\end{description}

\end{proof}

\begin{lemma}
	\label{lemma:lifted_literal_equal}
	Let $l$ and $l'$ be the resolved or factorised literals of a resolution derivation step employing the unifier $\sigma$ such that $l\sigma = l'\sigma$.
	Furthermore let $\tau =\nolinebreak \aiu(\lifboth{l\cl\sigma}, \lifboth{l'\cl\sigma})$.
	Then $\lifboth{l\cl\sigma}\tau = \lifboth{l\cl'\sigma}\tau$.
\end{lemma}
\begin{proof}
	As 
	$l\sigma = l'\sigma$, it also holds that 
	$\lifboth{l\sigma} = \lifboth{l'\sigma}$.
	By Lemma~\ref{lemma:literals_clause_simgeq}, we obtain that 
	$\lifboth{l\cl\sigma}\tau \simgeq \lifboth{l\sigma}$ and
	$\lifboth{l'\cl\sigma}\tau \simgeq \lifboth{l'\sigma}$. 
	Furthermore note that the $\simgeq$-relation guarantees that pairs of predicates and terms in this relation are equal up to the index of their lifting variables.
	Hence it only remains to show that the lifting variables of $\lifboth{l\cl\sigma}\tau$ and $\lifboth{l'\cl\sigma}\tau$ match.
	But by the definition of $\aiu$, $\tau$ substitutes any lifting variable at position $p$ of $\lifboth{l\cl\sigma}$ and $\lifboth{l'\cl\sigma}$ by the lifting variable $\lifboth{l\sigma}\at{p}$, 
	thus making them equal.
\end{proof}


\begin{lemma}
	Let $\pi$ be a resolution refutation of $\Gamma\cup\Delta$.
	Then for clauses $C$ in $\pi$,
	$\Gamma\entails\nolinebreak \AImatde(C) \lor\nolinebreak \AIclde(C)$.
\end{lemma}
\begin{proof}
	We proceed by induction of the strengthening $\Gamma\entails \AImatde(C) \lor \AIclde(C_\Gamma)$\footnotemark.\footnotetext{Recall that as in Lemma~\ref{lemma:gamma_entails_lifted_interpolant}, $D_\Phi$ denotes the clause created from the clause $D$ by removing all literals which are not contained $\Lang(\Phi)$.}

	\begin{description}
		\item{Base case.}
			For $C\in \Gamma$, $\AIclde(C_\Gamma) = \AIclde(C) = \lifdeltanovar{C} = C$, so $\Gamma \entails \AIclde(C_\Gamma)$.
			Otherwise $C \in \Delta$ and hence $\AImatde(C) = \top$.

		\item{Resolution.}
			Suppose the last rule application is an instance of resolution. Then it is of the following form:
			\begin{prooftree}
				\AxiomCm{C_1: D \lor l}
				\AxiomCm{C_2: E \lor \lnot l'}
				\RightLabelm{\quad l\sigma = l'\sigma}
				\BinaryInfCm{C: (D\lor E)\sigma}
			\end{prooftree}
			We introduce the following abbreviations:

			\newcommand{\clauseOnePrime}{\AIclausede((C_1)_\Gamma)^*}
			\newcommand{\clauseTwoPrime}{\AIclausede((C_2)_\Gamma)^*}

			$ \clauseOnePrime = \AIclausede((C_1)_\Gamma) \setminus \{{(l{\fromclausede})_\Gamma}\}$

			$ \clauseTwoPrime = \AIclausede((C_2)_\Gamma)\setminus \{{\lnot (l{\fromclausede'})_\Gamma}\}$

			Note that $\AIclde(C) = \lifdeltanovar{ \clauseOnePrime\sigma} \tau \lor \lifdeltanovar{ \clauseTwoPrime\sigma} \tau$, where $\tau$ is defined as in the interpolant extraction procedure as
			$\aiu ( \lifboth{ l\clde \sigma}, \lifboth{ l'\clde \sigma} )$.

			Employing these, the induction hypothesis yields 
			$\Gamma \entails \AImatrixde(C_1) \lor \clauseOnePrime \lor {(l{\fromclausede})_\Gamma}$
			as well as
			$\Gamma \entails \AImatrixde(C_2) \lor \clauseTwoPrime \lor {\lnot (l'{\fromclausede})_\Gamma}$.
			By Lemma~\ref{lemma:no_colored_terms}, $\AImatrixde(C_i)$ and $\AIclde(C_i)$ for $i\in\{1,2\}$ do not contain $\Delta$-colored symbols.
			Hence by Lemma~\ref{lemma:substitute_and_lift}, pulling the lifting inwards using Lemma~\ref{lemma:lift_logic_commute} and applying $\tau$, we obtain:

			$\Gamma \stackrel{\markA}\entails \lifboth{\AImatrixde(C_1)\sigma}\tau \lor \lifboth{\clauseOnePrime\sigma}\tau \lor \lifboth{(l{\fromclausede})_\Gamma\sigma}\tau$

			$\Gamma \stackrel{\markB}\entails \lifboth{\AImatrixde(C_2)\sigma}\tau \lor \lifboth{\clauseTwoPrime\sigma}\tau \lor \lnot \lifboth{(l{\fromclausede'})_\Gamma\sigma}\tau$

			We continue by a case distinction on the color of $l$:
			\begin{enumerate}
				\item Suppose that $l$ is $\Gamma$-colored. Then $\AImatde(C) = \lifboth{\AImatde(C_1)\sigma}\tau\spas\lor \lifboth{\AImatde(C_2)\sigma}\tau$.
					As $l$ is $\Gamma$-colored, $(l{\fromclausede})_\Gamma = l\clde$ and
					as $l\sigma = l'\sigma$, also $(l{\fromclausede'})_\Gamma = l'\clde$.
					By Lemma~\ref{lemma:lifted_literal_equal}, $\lifboth{l{\fromclausede}\sigma}\tau = \lifboth{l{\fromclausede'}\sigma}\tau$. 
					Hence we can perform a resolution step on \markA{} and \markB{} to arrive at
					$\Gamma \entails \lifboth{\AImatrixde(C_1)\sigma}\tau \lor \lifboth{\clauseOnePrime\sigma}\tau 
					\lor \lifboth{\AImatrixde(C_2)\sigma}\tau \lor \lifboth{\clauseTwoPrime\sigma}\tau$.
					This is however by Lemma~\ref{lemma:lift_logic_commute} nothing else than $\Gamma \entails \AImatde(C) \lor \AIclde(C)$.

				\item Suppose that $l$ is $\Delta$-colored. Then $\AImatde(C) = \lifboth{\AImatde(C_1)\sigma}\tau\spas\land \lifboth{\AImatde(C_2)\sigma}\tau$.
					As $l$ and $l'$ are $\Delta$-colored, \markA{} and \markB{} reduce to
					$\Gamma \entails \lifboth{\AImatrixde(C_1)\sigma}\tau \lor \lifboth{\clauseOnePrime\sigma}\tau $ and
					$\Gamma \entails \lifboth{\AImatrixde(C_2)\sigma}\tau \lor \lifboth{\clauseTwoPrime\sigma}\tau $ respectively.
					These however imply that 
					$\Gamma \entails (\lifboth{\AImatrixde(C_1)\sigma}\tau \land  \lifboth{\AImatrixde(C_2)\sigma}\tau) \spas\lor\allowbreak \lifboth{\clauseOnePrime\sigma}\tau \lor \lifboth{\clauseTwoPrime\sigma}\tau$,
					which in turn is nothing else than $\Gamma \entails\nolinebreak \AImatde(C) \lor \AIclde(C)$.

				\item Suppose that $l$ is grey. Then $\AImatde(C) = 
					(\lnot {\lifboth{l'\fromclausede\sigma}}\tau \land \lifboth{\AImatde(C_1)\sigma}\tau) \spam\lor\allowbreak
					(\lifboth{l\fromclausede\sigma}\tau \land \lifboth{\AImatde(C_2)\sigma}\tau)
					$.

					Let $M$ be a model of $\Gamma$. Suppose that $M \notentails \AIclde(C)$ as otherwise we are done. Hence $M \notentails \lifboth{\clauseOnePrime\sigma}\tau$ and $M \notentails \lifboth{\clauseTwoPrime\sigma}\tau$ and \markA{} and \markB{} reduce to 
					$\Gamma \entails \lifboth{\AImatrixde(C_1)\sigma}\tau \lor \lifboth{l{\fromclausede}\sigma}\tau$ 
					and 
					$\Gamma \entails \lifboth{\AImatrixde(C_2)\sigma}\tau \lor \lifboth{l{\fromclausede'}\sigma}\tau$ respectively.
					As by Lemma~\ref{lemma:lifted_literal_equal} $\lifboth{l{\fromclausede}\sigma}\tau = \lifboth{l{\fromclausede'}\sigma}\tau$, a case distinction on the truth value of $\lifboth{l{\fromclausede}\sigma}\tau$ in $M$ shows that $M\entails \AImatde(C)$.


			\end{enumerate}



		\item{Factorisation.}
			Suppose the last rule application is an instance of factorisation. Then it is of the following form:
			\begin{prooftree}
				\AxiomCm{C_1: l \lor l' \lor D}
				\RightLabelm{\quad \sigma = \mgu(l, l')}
				\UnaryInfCm{C: (l \lor D)\sigma}
			\end{prooftree}

			We introduce the abbreviation $\AIclde( (C_1)_\Gamma)^* \defeq \AIclde( (C_1)_\Gamma) \setminus \{ (l\cl)_\Gamma , (l'\cl)_\Gamma \}$ and express the induction hypothesis as follows:
			$\Gamma \entails \AImatde(C_1) \lor \AIclde( (C_1)_\Gamma)^* \lor (l\cl)_\Gamma \lor (l'\cl)_\Gamma $.
			By Lemma~\ref{lemma:no_colored_terms}, Lemma~\ref{lemma:substitute_and_lift} and Lemma~\ref{lemma:lift_logic_commute} and after applying $\tau$ to the induction hypothesis, we obtain that 
			$\Gamma \entails \lifboth{\AImatde(C_1)\sigma}\tau \lor \lifboth{\AIclde( (C_1)_\Gamma)^*\sigma}\tau \lor \lifboth{(l\cl)_\Gamma \sigma}\tau \lor \lifboth{(l'\cl)_\Gamma\sigma}\tau $.

			However by Lemma~\ref{lemma:lifted_literal_equal},
			$\lifboth{(l\cl)_\Gamma\sigma}\tau = 
			\lifboth{(l'\cl)_\Gamma\sigma}\tau$, hence we can perform a factorisation step to arrive at 
			$\Gamma \entails \lifboth{\AImatde(C_1)\sigma}\tau \lor \lifboth{\AIclde( (C_1)_\Gamma)^*\sigma}\tau \lor \lifboth{(l\cl)_\Gamma \sigma}\tau$.
			This however is nothing else than $\Gamma\entails \AImatde(C) \lor \AIclde(C)$.
			\qedhere

	\end{description}

\end{proof}


\begin{lemma}
	Let $\overline x$ be the $\Delta$-lifting variables and $\overline y$ be the $\Gamma$-lifting variables of $\AI(C)$.
	Let $\overline {x'}$ be the $\Delta$-lifting vairables of $\AIde(C)$.

	$\Gamma \entails \overline{\forall x} \AIde(C)$ implies
	$\Gamma \entails \overline{\forall x | \exists y} \AI(C)$.
\end{lemma}
\begin{proof}
	wie auf zettel

\end{proof}


\begin{thm}
	Let $\pi$ be a resolution refutation of $\Gamma\cup\Delta$.
	Then $\AImat( \pi )$ is an interpolant.
\end{thm}
\begin{proof}

	\todo[inline]{This needs too many things I don't yet know how to make precise, so let's start with $\Gamma \entails \dots$}
\end{proof}

\label{sec:arrow_quantifier_block} 

\end{document}
