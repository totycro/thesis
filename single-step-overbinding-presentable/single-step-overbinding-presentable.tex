\documentclass[,%fontsize=11pt,%
	paper=a4,% 
	%landscape,
	%DIV12, % mehr text pro seite als defaultyyp
	DIV18, 
	%DIV=calc,%
	%twoside=false,%
	liststotoc,
	bibtotoc,
	draft=false,% final|draft % draft ist platzsparender (kein code, bilder..)
	%titlepage,
	numbers=noendperiod
]{scrartcl}

\usepackage{lscape}
\usepackage{stackengine}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage{enumerate}
\usepackage{paralist}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,backgrounds,graphs,%
	matrix,patterns,arrows,decorations.pathmorphing,decorations.pathreplacing,%
	positioning,fit,calc,decorations.text,shadows%
}


\input{../latex_header.tex}

% subsections also in toc
\setcounter{tocdepth}{2}

%\declaretheorem[title=Theorem,qed=$\triangle$,parent=chapter]{thm}
\newcommand{\thmqed}{$\square$} % for thms without proof
\newcommand{\propqed}{$\square$} % for props without proof
\declaretheorem[title=Theorem]{thm}
\declaretheorem[title=Proposition,sibling=thm]{prop}
%\declaretheorem[title=Lemma,parent=chapter]{lemma}
\declaretheorem[sibling=thm]{lemma}
\declaretheorem[title=Corollary,sibling=thm]{corr}
\declaretheorem[sibling=thm,title=Definition,style=definition,qed=$\triangle$]{defi}
%\declaretheorem[title=Definition,qed=$\triangle$,parent=chapter]{defi}
\declaretheorem[title=Example,style=definition,qed=$\triangle$,sibling=thm]{exa}

\declaretheorem[sibling=thm,title=Conjecture]{conj}

\declaretheorem[title=Remark,style=remark,numbered=no,qed=$\triangle$]{remark}

%\def\proofSkipAmount{ \vskip -0.5em}



%\usepackage{bussproof}

%\usepackage{vaucanson-g}
\usepackage{amssymb}
\usepackage{latexsym}

% for color-highlighted code
%\usepackage{color} % for grey comments
%\usepackage{alltt}

%\usepackage[doublespacing]{setspace}
\usepackage[onehalfspacing]{setspace}
%\usepackage[singlespacing]{setspace}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{comment}
\usepackage{color}
\usepackage[final]{listings} % sourcecode in document
\usepackage{url}      % for urls
\usepackage{multicol}
\usepackage{float}
\usepackage{caption}
\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{graphicx}

\usepackage[authoryear]{natbib} % \cite ; square|round etc.
%\usepackage[numbers,square]{natbib}
%\usepackage[square, authoryear]{natbib}
%\usepackage[language=english]{biblatex}

%\bibliographystyle{plain}
\bibliographystyle{alpha}
%\bibliographystyle{alphadin}
%\bibliographystyle{dinat}
%\bibliographystyle{chicago}
%\bibliographystyle{plainnat}

\bibdata{bib.bib}

\renewcommand*{\partformat}{\partname\ \thepart\ -}
\let\partheadmidvskip\

\newcommand{\comp}{\ensuremath{\text{comp}}}
% smaller url style
\makeatletter
\def\url@leostyle{%
\@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
\urlstyle{leo}

\newcommand{\myfig}[5] {
	\begin{figure}[tbph]
		\centering
		\includegraphics[#3]{#1}
		\caption[#4]{#5}
		\label{fig:#2}
	\end{figure}
}

\setlength{\parindent}{0em}
%\usepackage{thmtools} % actually already in latex_header.tex ...

\usepackage{amsthm}


\usepackage{tikz-qtree}

%\newcommand{\sig}[1]{{#1}_\Sigma}
%\newcommand{\p}[1]{{#1}_\Pi}
\newcommand{\sig}[1]{\stackrel{\Sigma}{#1}}
\newcommand{\p}[1]{\stackrel{\Pi}{#1}}

\newcommand{\e}[1]{\vskip .7em   \subsection*{#1}}

\def\proofSkipAmount{ \vskip -0.3em}

\begin{document}

\newcommand{\lif}[1]{\lift{\Delta}{#1}{x}}


	%\newcommand{\lifboth}[1]{\lft{\Gamma\cup\Delta}{z}{#1}}

\section{Arrow-Algo}

\begin{enumerate}
	\item
		In the original clauses, find all occurrences of variables.

		Common case:
		If a variable appears as outermost symbol or only has grey ancestor-terms, add an arrow from it to all other occurrences.

		Uncommon case:
		if there is more than one occurrence of a variable under a $\Phi$-colored term, add a \emph{weak} dependency between them all (symmetric relation).


		NOTE: this creates double arrows for occurrences at same depth. This appears to be necessary for terms which are only variables, and doesn't hurt if the variable is contained in a term.

	\item For each step in the derivation:
		\begin{enumerate}
			\item Build propositional interpolant using $\PI(C_i)^*$, $i\in \{1,2\}$, i.e.~use ancestor $\PI$ without colored terms.
			\item If ancestors of atom added to $\PI(C)$ had arrows, merge them to atom in $\PI(C)$ (i.e.~arrows starting in and leading to this atom).
			\item Replace colored terms in $\PI(C)$ (from new atom and unifier applied to $\PI(C_i)^*$) with fresh variables, except if a term has a double ended arrow to another overbinding variable, then use that variable.

				An arrow starts (ends) in one of the new variables if it starts (ends) somewhere in the term it replaced.
			\item Collect quantifiers: from $\PI(C_i)^*$, $i\in \{1,2\}$ and ones from atom added to $\PI(C)$. Order such that arrows only point to variables to the right AND weakly connected variables appear in the same quantifier block.

				$\bar Q_n = \operatorname{sort}( Q_{n_1} \cup Q_{n_2} \cup \operatorname{colored-terms}(l))$
		\end{enumerate}
\end{enumerate}

\clearpage
\subsection{algo more formally}

Every literal in any initial clause set has a globally unique id/number

Ex: $P(y, a, f(z, g(y, b)) ) \lor Q(x)$

Term position:

$0.2.1.0$ means first literal, 3rd arg, 2nd arg, fst arg: $y$

$0.1$ is $a$

$0.2.1$ is $g(z, b)$

$\pos$ calculates the position of a term or the term of a position, depending on the argument type.

for a position $p_i$, $\pos(p_i)$ denotes whatever $p_i$ refers to in its respective clause.

for a term $t$, $\pos(t)$ denotes the position in $t$ in its respective clause.

for a position $p$, $\poslit(p)$ denotes the position of the literal

for a position $p$, $\posterm(p)$ denotes the position of the term in $p_i$ 

$\Ra$ $p = \poslit(p).\posterm(p)$

for a position $p$, $p \mod i$ denotes $p$ with $i$ least significant places cut off, $0.2.1.0 \mod 2 = 0.2$

\subsection{Arrows:}

$\arr$ is a set of ordered pairs of term positions which point to positions in terms in literals

$\warr$ is a set of unordered pairs of term positions which point to positions in terms in literals

w.r.t a refutation $\pi$ of $\Gamma \cup \Delta$:

\begin{enumerate}
	\item For each initial clause $C$ in $\Gamma \cup \Delta$:

		Add to $\arr$ all $(p_1, p_2)$ in $C$
		such that $p_1$ contains only grey symbol and $\pos(p_1)$ is a variable and $\pos(p_1) = \pos(p_2)$ but $p_1 \neq p_2$.

		Add to $\warr$ all $\{p_1, p_2\}$ such that there is a colored symbol in $p_1$ and a possible different one in $p_2$ and $\pos(p_1)$ is a var and $\pos(p_1) = \pos(p_2)$.

	\item 
		For each $C$ resulting from a resolution step from $C_1: D\lor l$ and $C_2: E\lor \lnot l$ to $C = D \lor E$ with prop interpolant $\PI(\cdot)$:

		Note: literals are added to the interpolant if they occur in both ancestors.

		Merge the respective ids of $l$ and $\lnot l$ , i.e. their arrows. Their term structure will be the same, so all arrows point to valid positions.

		%Each literal in $D$ ($E$) in $C$ is said to come from the respective literal in  $C_1$ ($C_2$). 
		%If $l$ and/or $l'$ is added to $\PI(C)$, it comes from both $l$ and $l'$.


		%Add $(p_1, p_2)$ to $\arr$ if $\poslit{p_i}$ comes from literal $l_i$ in a clause $D$ in an original clause set, $i\in\{1, 2\}$, (both from same $D$), and $(l_1.\posterm{p_1}, l_2.\posterm{p_2}) \in \arr{D}$ 

\end{enumerate}

\subsection{algo}

NOTE: for now, we assume that every colored-term has a globally unique id $i$ and will be replaced by a variable with this index. 
This restriction is useful now and could potentially be lifted later, but it's not severe anyway.

Note: when a literal is added to the interpolant, the colored terms in one literal might have already been replaced with a certain variable before. we definitely have to use the same variable for both literals, and if one literal has other dependencies, we should stick with the variable we have.

PROBLEM: terms already replaced by variables still change! need to use same variable anyway, so note above not accurate!


\subsubsection{$\AImatrix$ and $\AIclause$}

Here, we define $\AImatrix$, which represents the \emph{matrix} of what will be the interpolant, and $\AIclause$, which represents the \emph{clauses} in the refutation applied with the same unifications as $\AImatrix$.

\begin{enumerate}
	\item 
		For each initial clause $C$, $\AImatrix(C) = \PI(C)$ and $\AIclause(C) = \lifboth{C}$.

	\item
		For each $C$ resulting from a resolution step from $C_1: D\lor l$ and $C_2: E\lor \lnot l$ to $C = (D \lor E)\sigma$ with $l\sigma = l'\sigma$ with prop interpolant $\PI(\cdot)$:

		$l.\dotsc$ literal in original clause

		$l^*\dotsc$ literal in $\AIclause$ (with unifications and liftings carried over, such that ind hyp goes through)

		literal to put in $\AImatrix$ is defined as $x_i =\lifboth{l\sigma} = \lifboth{l'\sigma}$
		%$l^\circ\dotsc$ literal to put in $\AImatrix$ is defined as $x_i =\lifboth{l\sigma} = \lifboth{l'\sigma}$

		$l\sigma = l'\sigma$, but $l^*$ and ${l^*}'$ might have been overbound with different variables. Still, they in a sense refer to the same ground literal, so we ``can just'' ``unify'' them.
		
		Prose explanation of formal definition below: Shape must be the same in the sense that grey terms are the same, otherwise there is $\Phi$-replacing-var vs $\Phi$-replacing-var (let arbitrary one win) or $\Phi$-replacing-var vs $\Phi$-term (let var win) or $\Phi$-term and $\Phi$-term (replace both with same var). 
		Also apply this to liftings in $\AIclause$ and $\AImatrix$ here.

		$\aiu$ is defined on terms which are used as parameters for literals $l = A(a_1, \dotsc, a_n)$, $l' = A(b_1, \dotsc, b_n)$ which occur in $\AIclause(C_1)$, $\AIclause(C_2)$ such that $l\sigma = l'\sigma$. Note that if one of the arguments of $\aiu$ has assigned a color, the other one either has none or the same color. There cannot be a conflict as otherwise their original form would not be unifiable.
	%	\[
	%		\aiu ( a_i, b_i) =
	%		\begin{cases}
	%			f_s(\aiu(s_1, t_1), \dotsc, \aiu(s_n, t_n)) & \text{if $a_i=f_s(\bar s)$ grey and $b_i = f_t(\bar t)$ (include $f_s$ being a constant)} \\
	%			x_j & \parbox[t]{.4\textwidth}{ if $a_i = x_j$, where $x_j$ from lifting (then $b_i$ is either variable or term with same color) } \\
	%			x_j & \text{if $b_i = x_j$, if $x_j$ but not $a_i$ from lifting }\\
	%			x_j & \text{if $\lifboth{a_i\sigma} = \lifboth{b_i\sigma} = x_j$ }
	%		\end{cases}
	%	\]

		$\tau = \bigcup_{i=1}^n \aiu(a_i, b_i)$


		$
			\aiu (a, b) =
			\begin{cases}
				\bigcup_{j=1}^n \aiu(s_j, t_j) & \text{if $a=f_s(\bar s)$ grey and $b = f_t(\bar t)$ (includes $f_s$ being a constant)} \\
			\{x_j \mapsto x_k\} & \parbox[t]{.6\textwidth}{ if $a = x_j$ from lifting and $b$ colored term with $\lifboth{b\sigma} = x_k$} \\
			\{x_k \mapsto x_j\} & \parbox[t]{.6\textwidth}{ if $b = x_k$ from lifting and $a$ colored term with $\lifboth{a\sigma} = x_j$} \\
				\{x_j \mapsto x_m, x_k \mapsto x_m\} & \parbox[t]{.6\textwidth}{if $a = x_j$ and $b = x_k$, both from lifting, and $p = \pos(a) = \pos(b)$ and $\lifboth{l\sigma}.\posterm(p) = \lifboth{l'\sigma}.\posterm(p) = x_m$}\\
				\emptyset & \text{if $\lifboth{a\sigma} = \lifboth{b\sigma} = x_j$ }
			\end{cases}
		$




		$\AIclause(C) =
		\lifboth{\Big( (\AIclause(C_1) \setminus \{l^*\}) \lor (\AIclause(C_2)\setminus \{{l^*}'\}) \Big)\sigma} \tau$ 

		\begin{itemize}
			\item if $l$ and $l'$ don't have the same color:

				$\AImatrix(C) =
				(\lnot {\lifboth{l\sigma}} \land \lifboth{\AImatrix(C_1)\sigma}\tau) \lor
				(\lifboth{l\sigma} \land \lifboth{\AImatrix(C_2)\sigma) }\tau
				$


				%$\AImatrix(C) =
				%\lifboth{\Big( (\lnot l \land \AImatrix(C_1)) \lor (l \land \AImatrix(C_2)) \Big) \sigma} $


				%		$\left.\begin{tabular}{l}
				%		$\AImatrix(C) = \lifboth{\AImatrix(C)' \sigma}$\\

				%		$\AIclause(C) = \lifboth{\AIclause(C)' \sigma}$
				%\end{tabular}\right\} \lifboth $ with same overbinding!


				%				$\lifboth{ \AImatrix(C)' \lor \AIclause(C)' } = \underbrace{\lifboth{ \AImatrix(C)' }}_{\AImatrix(C)} \lor \underbrace{\lifboth{\AIclause(C)'}}_{\AIclause(C)}$ 


			\item if $l$ and $l'$ are $\Gamma$-colored :

				%$\AImatrix(C) = \lifboth{( \AImatrix(C_1) \lor/\land \AImatrix(C_2) )\sigma}$
				%as above but with  $\AImatrix(C)' = \Big(\AImatrix(C_1) \lor \AImatrix(C_2)\Big)\sigma$
				$\AImatrix(C) = \lifboth{\Big(\AImatrix(C_1) \lor \AImatrix(C_2)\Big)\sigma} \tau$
			\item if $l$ and $l'$ are $\Delta$-colored:

				%as above but with  $\AImatrix(C)' = \Big(\AImatrix(C_1) \land \AImatrix(C_2)\Big)\sigma$
				$\AImatrix(C) = \lifboth{\Big(\AImatrix(C_1) \land \AImatrix(C_2)\Big)\sigma} \tau$


		\end{itemize}

\end{enumerate}

\subsubsection{$\AI$}


$\AI(C) = Q_1 u_1 \ldots Q_m u_m \AImatrix(C)$

$u_1, \ldots, u_m$ are comprised of all $x_i$ and $y_i$ PLUS all free variables in $\AImatrix(C)$.

$Q_i$ is $\exists$ if $u_i = y_i$ for some $i$, $\forall$ if $u_i = x_i$ for some $i$.
For free variables, $Q_i$ as in $C_1/C_2$. if $u_i\sigma \neq u_i$, $u_i$ becomes one of $x_j$ or $y_j$ or grey term.

$(p_1, p_2) \in \operatorname{TransitiveClosure}(\arr)$ implies that $u_i < u_j$ if $u_i$ replaces $t_i$ and $u_j$ replaces $t_j$ and $p_1$ points into $t_i$ and $p_2$ points into $t_j$.


\clearpage

\section{proof of propositional aspect of $\AI$}

\begin{lemma}[Restated from proof without propositional refutation, lemma 1] 
	\label{lemma:lift_subst_commute}
	Let $C$ be a clause and $\sigma$ a substitution.
	Let $t_1,\ldots,t_n$ be all maximal $\Delta$-terms in this context, i.e.\ those that occur in $C$ or $C\sigma$,  and
	$x_1, \ldots, x_n$ the corresponding fresh variables to replace the $t_i$ (i.e.~none of the $x_i$ occur in $C$).
	Define $\sigma'$ such that for a variable $z$,
	\[
		z \sigma' =
		\begin{cases} 
			x_l & \text{ if } z = x_k \text{ and } t_k\sigma = t_l  \\
			\lif{z\sigma} & \text{ otherwise}
		\end{cases} 
	\]

	Then
	$\lif{C\sigma} =
	\lif{C}\sigma'$.
\end{lemma}

\begin{remark}[Restriction of Lemma \ref{lemma:lift_subst_commute}]
	Lemma \ref{lemma:lift_subst_commute} does not hold in case $x_i$ occurs in $C$.
	This can easily be seen using the following counterexample:


	Let $\sigma = \{x \mapsto a\}$ and $t_1 = f(x)$ and $t_2 = f(a)$. 
	Then clearly $t_1\sigma = t_2$ and therefore $x_1\sigma' = x_2$.

	But now consider $x_1 \sigma$. 
	As $x_1$ has its place in the domain of variables to replace colored terms, and $\sigma$ is taken from a resolution refutation, they do not affect each other. 
	Hence $x_1\sigma = x_1$ and therefore $\lifdelta{x_1\sigma} = x_1$, but $\lifdelta{x_1}\sigma' = \lifdelta{x_1}\sigma' = x_2$.
	

	However such a situation arises naturally if we lift colored terms after every step of the interpolant extraction procedure, as there, the intermediate relative interpolants clearly contains variables to overbind terms, but we also need to treat terms that enter the interpolant by means of unification.
\end{remark}

\begin{lemma}[corresponds to Lemma 4.8 in thesis and Lemma 11 in Huang]
	\label{lemma:lift_logic_commute}
	Let $A$ and $B$ be first-order formulas and $s$ and $t$ be terms. Then it holds that:
	\begin{enumerate}
		\item $\lift{\Phi}{\lnot A}{x} \semiff{} \lnot \lift{\Phi}{A}{x}$
		\item $\lift{\Phi}{A \circ B}{x} \semiff{} ( \lift{\Phi}{A}{x} \circ \lift{\Phi}{B}{x} )$ for  $\circ \in     \{\land, \lor\}$
		\item $\lift{\Phi}{s = t}{x} \semiff{} ( \lift{\Phi}{s}{x} = \lift{\Phi}{t}{x} )$
	\end{enumerate}
\end{lemma}



\begin{lemma}
	$\AImatrix(C)$ and $\AIclause(C)$ do not contain colored terms.
	\label{lemma:no_colored_terms}
	\comm{true}
\end{lemma}



\begin{corr}
  For a clause $C$ in a resolution refutation $\pi$ of $\Gamma \cup \Delta$:
  \begin{compactenum}
    \item $\AImatrix(C) = \lifboth{\AImatrix(C)}$.

    \item $\AIclause(C) = \lifboth{\AIclause(C)}$.
  \end{compactenum}
  \label{corr:lift_ai}
  \comm{true and used}
\end{corr}

\begin{lemma}
  The $x_i$, $y_i$ and $z_i$ do not occur in any substitution of a resolution refutation.
  \comm{true but unused}
\end{lemma}


\begin{lemma}
  Suppose no $\Gamma$-term occurs in $\Gamma$.
  Then
  $\Gamma \entails \AImatrix(C) \lor \AIclause(C)$.
\end{lemma}
\begin{proof}
  Proof by induction of the strenghtening:
  $\Gamma \entails \AImatrix(C) \lor \AIclause(C_\Gamma)$.

  Base case:

	For $C \in \Gamma$, $\AImatrix(C) = \bot$ and $\AIclause(C) = \lifboth{C_\Gamma} = \lifgamma{C}$. By the restriction, $\lifgamma{C} = C$ and $\Gamma \entails C$.\todo{restriction used here}

  For $C \in \Delta$, $\AImatrix(C) = \top$.

  Induction step:


  \begin{description}
    \item{Resolution.}
      \begin{prooftree}
        \AxiomCm{C_1: D \lor l}
        \AxiomCm{C_2: E \lor \lnot l'}
        \RightLabelm{\quad \sigma = \mgu(l, l')}
        \BinaryInfCm{C: (D\lor E)\sigma}
      \end{prooftree}
			We introduce the following abbreviations, where $l^*$ is the literal in $\AIclause$ which corresponds to $l$ (TODO: formalise):

			\newcommand{\clauseOnePrime}{\AIclause(C_1)^*}
			\newcommand{\clauseTwoPrime}{\AIclause(C_2)^*}

			$ \clauseOnePrime = \AIclause((C_1)_\Gamma) \setminus \{\lifboth{l^*_\Gamma}\}$

			$ \clauseTwoPrime = \AIclause((C_2)_\Gamma)\setminus \{\lifboth{\lnot l{^*_\Gamma}'}\}$

			{\color{red}

      Let $\sigma'$ as in Lemma \ref{lemma:lift_subst_commute}. Then by Lemma \ref{lemma:lift_subst_commute}{} and Lemma \ref{lemma:lift_logic_commute}:
      \begin{flalign*}
        \AIclause(C_\Gamma) &=
				\lifboth{\Big( \clauseOnePrime \lor \clauseTwoPrime \Big)\sigma} & \\
			&=
				\lifboth{\clauseOnePrime}\sigma' \lor \lifboth{\clauseTwoPrime}\sigma' 
				%\lifboth{(\AIclause((C_1)_\Gamma) \setminus \{\lifboth{l_\Gamma}\})}\sigma'
				%\lor \lifboth{(\AIclause((C_2)_\Gamma)\setminus \{\lifboth{\lnot l'_\Gamma}\})}\sigma'
			\end{flalign*}
		}
      By the induction hypothesis,
      $\Gamma \entails \AImatrix(C_i) \lor \AIclause({C_i}_\Gamma)$, $i\in\{1,2\}$, or expressed differently:


      $\Gamma \stackrel{\markA}\entails \AImatrix(C_1) \lor \clauseOnePrime \lor \lifboth{l_\Gamma}$

      $\Gamma \stackrel{\markB}\entails \AImatrix(C_2) \lor \clauseTwoPrime \lor \lnot \lifboth{l'_\Gamma}$



      Furthermore,
      $\sigma = \mgu(l, l')$, so $\lifboth{l\sigma} = \lifboth{l'\sigma}$ and $\lifboth{l}\sigma' = \lifboth{l'}\sigma'$ by Lemma \ref{lemma:lift_subst_commute}.

      \begin{itemize}


        \item Suppose that $l$ and $l'$ are $\Gamma$-colored.
          \begin{flalign*}
            \AImatrix(C) &=
            \lifboth{\Big( (\AImatrix(C_1) \lor \AImatrix(C_2)) \Big) \sigma} & \\ 
                                                                             &= \lifboth{\AImatrix(C_1)}\sigma' \lor            \lifboth{\AImatrix(C_2)}\sigma'
          \end{flalign*}
          By Corollary~\ref{corr:lift_ai} and applying $\sigma'$ to \markA{} and \markB, we obtain:

          $\Gamma \entails \lifboth{\AImatrix(C_1)}\sigma' \lor                                                                 \lifboth{\clauseOnePrime}\sigma' \lor \lifboth{l}\sigma'$

          $\Gamma \entails \lifboth{\AImatrix(C_2)}\sigma' \lor                                                                 \lifboth{\clauseTwoPrime}\sigma' \lnot \lifboth{l'}\sigma'$

          As $\lifboth{l}\sigma' = \lifboth{l'}\sigma'$, we can perform a resolution step to arrive at:

          $\Gamma \entails \lifboth{\AImatrix(C_1)}\sigma' \spas\lor                                                             \lifboth{\clauseOnePrime}\sigma' \spas\lor
          \lifboth{\AImatrix(C_2)}\sigma' \spas\lor \lifboth{\clauseTwoPrime}\sigma' $

          But this is nothing else than $\Gamma \entails \AImatrix(C) \lor \AIclause(C_\Gamma)$.



        \item Suppose that $l$ and $l'$ are $\Delta$-colored.
          \begin{flalign*}
            \AImatrix(C) &=
            \lifboth{\Big( (\AImatrix(C_1) \land \AImatrix(C_2)) \Big) \sigma} & \\ 
                                                                              &= \lifboth{\AImatrix(C_1)}\sigma' \land          \lifboth{\AImatrix(C_2)}\sigma'
          \end{flalign*}
          \markA{} and \markB{} then reduce to:

      $\Gamma \entails \AImatrix(C_1) \lor \clauseOnePrime$

      $\Gamma \entails \AImatrix(C_2) \lor \clauseTwoPrime$

      But this implies that
      $\Gamma \entails (\AImatrix(C_1)\land \AImatrix(C_2))\spas\lor 
      \clauseOnePrime \spas\lor \clauseTwoPrime$,
			which by Corollary~\ref{corr:lift_ai} and applying $\sigma'$ gives
			$\Gamma \entails (\lifboth{\AImatrix(C_1)}\sigma' \land \lifboth{\AImatrix(C_2)}\sigma')\spas\lor 
			\lifboth{\clauseOnePrime}\sigma' \spas\lor \lifboth{\clauseTwoPrime}\sigma'$.
			This however is nothing else than
      $\Gamma \entails \AImatrix(C) \lor \AIclause(C)$.


        \item
          Suppose that $l$ and $l'$ are grey:
          \begin{flalign*}
            \AImatrix(C) &=
            \lifboth{\Big( (\lnot l \land \AImatrix(C_1)) \lor (l \land \AImatrix(C_2)) \Big) \sigma} &\\
                                                                                                      &= (\lifboth{\lnot        l}\sigma' \land \lifboth{\AImatrix(C_1)}\sigma') \lor (\lifboth{l}\sigma' \land \lifboth{\AImatrix(C_2)}\sigma')
          \end{flalign*}

          Note that $l_\Gamma = l$ and $l'_\Gamma = l'$.

          Let $M$ be a model of $\Gamma$.
          Suppose that $M\notentails \AIclause(C)$ as otherwise we would be done.

          Then by \markA{} and \markB{}:

          $\Gamma \entails \AImatrix(C_1) \lor \lifboth{l}$

          $\Gamma \entails \AImatrix(C_2) \lor \lnot \lifboth{l'}$

          By Corollary~\ref{corr:lift_ai} and applying $\sigma'$:

          $\Gamma \entails \lifboth{\AImatrix(C_1)}\sigma' \lor \lifboth{l}\sigma'$

          $\Gamma \entails \lifboth{\AImatrix(C_2)}\sigma' \lor \lnot \lifboth{l'}\sigma'$

          As $\lifboth{l}\sigma' = \lifboth{l'}\sigma'$, we can deduce that $M \entails \Big(\lnot \lifboth{l}\sigma' \land     \lifboth{\AImatrix(C_1)}\sigma'\Big) \lor \Big(\lifboth{l}\sigma' \land \lifboth{\AImatrix(C_2)}\sigma'\Big)$, i.e.~$M \entails \AImatrix(C)$.
					\qedhere
      \end{itemize}
  \end{description}
\end{proof}





\clearpage
\section{arrow proof}

\begin{lemma}
	\label{lemma:arrow_for_same_variables}
	Whenever the same variable appears multiple times in $\PI(C)\lor C$ for $C \in \pi$, there are arrows.

	\begin{itemize}
		\item if both variables are contained only in grey terms, there is a double arrow \comm{they unify to exactly the same}
		\item if only one variable is only contained in grey terms, there is an arrow from it to the other one \comm{either unify the one in grey term, then other one must be overbound later. if otherwise var in the colored term is unified, we can still overbind the grey one first. }
		\item otherwise there are weak arrows between them \comm{have same quantifier, so order does not matter, but want to keep dependencies on both the same}
	\end{itemize}
\end{lemma}
\begin{proof}
	By induction. Note: As required by resolution, all initial clauses are variable disjoint.

	Base case:
	In the initial clause sets, consider for a clause $C$ two different positions $p_1$ and $p_2$ pointing to the same variable. 
	Then either:
	\begin{itemize}
		\item $p_1$ and $p_2$ contain only grey symbols. Then $(p_1, p_2) \in \arr$.
		\item Only $p_i$, $i\in\{1,2\}$ contains only grey symbols. Then $(p_i, p_{(i \mod 2)+1}) \in \arr$.
		\item There are not only grey symbols in both $p_1$ and $p_2$, i.e.~both contain at least a colored symbol. Then $\{p_1, p_2\} \in \warr$. 
	\end{itemize}

	Induction step:
	Suppose a clause $C$ is the result of a resolution of $C_1: D \lor l$ and $C_2: E \lor \lnot l$ with $l\sigma = l'\sigma$.
	$\PI(C)$ is $[\PI(C_1) \circ \PI(C)]\sigma$ or $[(l \land \PI(C_2)) \lor (\lnot l \land \PI(C_1)) ] \sigma $.

	Assumption: $C_1$ and $C_2$ are variable disjoint, i.e.~variables are renamed in case $C_1$ and $C_2$ are derived from some common original clause and share variables.

	By the induction hypothesis, there are appropriate arrows in both $\PI(C_i) \lor C_i$, $i \in \{1,2\}$.

	If the variables were present in $C_1$ or $C_2$, the arrow is still there, either in $\PI(C)$ (in the case of $l$ or $l'$), $C$ (in case of $D$ and $E$) or in currently not shown literal (in case $l$ and $l'$ have the same color).

	Otherwise, it was introduced by unification in $l\sigma$ or $\PI(C_i)\sigma$.
	In this case, there is some term position $q$ in with $\pos(l).q$ a variable and $\pos(l').q$ a variable or a term containing variables (or other way around).
	Hence unification maps a variable to a variable or a term containing variables.
	The variable being unified is in $\PI(C_i)\lor C_i$ for some $i\in\{1,2\}$.
	But by the induction hypothesis, all occurrences of each variable does already have appropriate arrows, which are still present. 
\end{proof}



\begin{lemma}
	In $\PI(C)\lor C$ for $C \in \pi$, if there is a $\Delta$-colored term $s$ in a $\Gamma$-term $t$, then there is an arrow from $p_1$ to $p_2$ such that $\pos(p_1) = s$ and $\pos(p_2) = s$ and for some $i$, $\pos( p_2 \mod i ) = t$.
\end{lemma}
Note: $p_1$ might be in some clause, the prop interpolant or none of both. 
\begin{proof}
	By induction.

	Base case: There are no foreign terms in the initial clause sets, so no arrows necessary.

	Induction step:

	\begin{itemize}
		\item[Resolution.]
			Suppose a clause $C$ is the result of a resolution of $C_1: D \lor l$ and $C_2: E \lor \lnot l$ with $l\sigma = l'\sigma$.

			\begin{enumerate}
				\item Suppose $l$ is colored. 
					This case is similar to the grey one, with the exception that the cases applying to $l$ in $\PI$ do not apply.

				\item Suppose $l$ is grey. Then  $\PI(C) = [(l \land \PI(C_2)) \lor (\lnot l \land \PI(C_1)) ] \sigma $

					By the induction hypothesis, there are appropriate arrows in $\PI(C_1) \lor C_1$ and $\PI(C_2) \lor C_2$.

					We show that for all maximal $\Gamma$-terms in $\PI(C)\lor C$ with $\Delta$-terms in them which were not present in $\PI(C_i)\lor C_i$, $i \in \{1,2\}$, there is an arrow.

					$\Gamma$-terms and $\Delta$-terms are not unifiable.
					%Hence all pairs of terms $(t_1, t_2)$ in the same positions in $l$ and $l'$ (if both positions exist) are both grey, or w.l.o.g.~$t_1$ is a variable and $t_2$ is a colored/grey term.
					Hence all pairs of terms $(t_1, t_2)$ in the same positions in $l$ and $l'$ (if both positions exist) either point to the same symbol or (w.l.o.g.) $t_1$ is a variable and $t_2$ is a term.
					If there are $\Delta$-terms in $\Gamma$-terms in the prefix, they are present in both ancestors and handled by the induction hypothesis.

					The only way a $\Delta$-colored term may enter a $\Gamma$-colored term is in the situation where $t_1$ is a variable and $t_2$ a colored term.
					But then $\mgu(t_1, t_2)$ applied to $t_1$ yields $t_2$, i.e.~``the parts of $\sigma$ concerned with unifying $t_1$ and $t_2$'' do not introduce new $\Delta$-terms in $\Gamma$-terms.
					In other words, all such situation have been present in $\PI(C_i) \lor C_i$ for $i \in \{1,2\}$ and since the arrows for $l$ and $l'$ are merged, they are present for $l\sigma$ in $\PI(C)$.

					This handles the case where terms $t_1$ and $t_2$ are unified. 
					But unification also affects all other occurrences of variables, this means ``the parts of $\sigma$ not concerned with unifying $t_1$ and $t_2$''.
					The relevant case for this lemma is when a $\Gamma$-term contains a variable, that is substituted by a term containing $\Delta$-terms.
					But in this case, by Lemma \ref{lemma:arrow_for_same_variables}, there is an arrow from the other occurrence of the variable to the one in the $\Gamma$-term: either double arrow in $\arr$ if both prefixes are grey, one in $\arr$ if one of the prefixes is grey or one in $\warr$ if both prefixes contain a colored symbol.
					\qedhere
			\end{enumerate}
	\end{itemize}
\end{proof}


\end{document}
