\documentclass[,%fontsize=11pt,%
	paper=a4,% 
	%landscape,
	DIV12, % mehr text pro seite als defaultyyp
	%DIV10, 
	%DIV=calc,%
	twoside=false,%
	liststotoc,
	bibtotoc,
	draft=false,% final|draft % draft ist platzsparender (kein code, bilder..)
	%titlepage,
	numbers=noendperiod
]{scrartcl}

\usepackage{lscape}
\usepackage{stackengine}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage{enumerate}
\usepackage{paralist}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,backgrounds,graphs,%
	matrix,patterns,arrows,decorations.pathmorphing,decorations.pathreplacing,%
	positioning,fit,calc,decorations.text,shadows%
}


\input{../latex_header.tex}

% subsections also in toc
\setcounter{tocdepth}{2}

%\declaretheorem[title=Theorem,qed=$\triangle$,parent=chapter]{thm}
\newcommand{\thmqed}{$\square$} % for thms without proof
\newcommand{\propqed}{$\square$} % for props without proof
\declaretheorem[title=Theorem]{thm}
\declaretheorem[title=Proposition,sibling=thm]{prop}
%\declaretheorem[title=Lemma,parent=chapter]{lemma}
\declaretheorem[sibling=thm]{lemma}
\declaretheorem[title=Corollary,sibling=thm]{corr}
\declaretheorem[sibling=thm,title=Definition,style=definition,qed=$\triangle$]{defi}
%\declaretheorem[title=Definition,qed=$\triangle$,parent=chapter]{defi}
\declaretheorem[title=Example,style=definition,qed=$\triangle$,sibling=thm]{exa}

\declaretheorem[sibling=thm,title=Conjecture]{conj}

\declaretheorem[title=Remark,style=remark,numbered=no,qed=$\triangle$]{remark}

%\def\proofSkipAmount{ \vskip -0.5em}



%\usepackage{bussproof}

%\usepackage{vaucanson-g}
\usepackage{amssymb}
\usepackage{latexsym}

% for color-highlighted code
%\usepackage{color} % for grey comments
%\usepackage{alltt}

%\usepackage[doublespacing]{setspace}
\usepackage[onehalfspacing]{setspace}
%\usepackage[singlespacing]{setspace}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{comment}
\usepackage{color}
\usepackage[final]{listings} % sourcecode in document
\usepackage{url}      % for urls
\usepackage{multicol}
\usepackage{float}
\usepackage{caption}
\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{graphicx}

\usepackage[authoryear]{natbib} % \cite ; square|round etc.
%\usepackage[numbers,square]{natbib}
%\usepackage[square, authoryear]{natbib}
%\usepackage[language=english]{biblatex}

%\bibliographystyle{plain}
\bibliographystyle{alpha}
%\bibliographystyle{alphadin}
%\bibliographystyle{dinat}
%\bibliographystyle{chicago}
%\bibliographystyle{plainnat}

\bibdata{bib.bib}

\renewcommand*{\partformat}{\partname\ \thepart\ -}
\let\partheadmidvskip\

\newcommand{\comp}{\ensuremath{\text{comp}}}
% smaller url style
\makeatletter
\def\url@leostyle{%
\@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
\urlstyle{leo}

\newcommand{\myfig}[5] {
	\begin{figure}[tbph]
		\centering
		\includegraphics[#3]{#1}
		\caption[#4]{#5}
		\label{fig:#2}
	\end{figure}
}

\setlength{\parindent}{0em}
%\usepackage{thmtools} % actually already in latex_header.tex ...

\usepackage{amsthm}


\usepackage{tikz-qtree}

%\newcommand{\sig}[1]{{#1}_\Sigma}
%\newcommand{\p}[1]{{#1}_\Pi}
\newcommand{\sig}[1]{\stackrel{\Sigma}{#1}}
\newcommand{\p}[1]{\stackrel{\Pi}{#1}}

\newcommand{\e}[1]{\vskip .7em   \subsection*{#1}}

\def\proofSkipAmount{ \vskip -0.3em}

\usepackage{refcheck}

\begin{document}

\newcommand{\lif}[1]{\lift{\Delta}{#1}{x}}


	%\newcommand{\lifboth}[1]{\lft{\Gamma\cup\Delta}{z}{#1}}

\section{Arrow-Algo}

\begin{enumerate}
	\item
		In the original clauses, find all occurrences of variables.

		Common case:
		If a variable appears as outermost symbol or only has grey ancestor-terms, add an arrow from it to all other occurrences.

		Uncommon case:
		if there is more than one occurrence of a variable under a $\Phi$-colored term, add a \emph{weak} dependency between them all (symmetric relation).


		NOTE: this creates double arrows for occurrences at same depth. This appears to be necessary for terms which are only variables, and doesn't hurt if the variable is contained in a term.

	\item For each step in the derivation:
		\begin{enumerate}
			\item Build propositional interpolant using $\PI(C_i)^*$, $i\in \{1,2\}$, i.e.~use ancestor $\PI$ without colored terms.
			\item If ancestors of atom added to $\PI(C)$ had arrows, merge them to atom in $\PI(C)$ (i.e.~arrows starting in and leading to this atom).
			\item Replace colored terms in $\PI(C)$ (from new atom and unifier applied to $\PI(C_i)^*$) with fresh variables, except if a term has a double ended arrow to another overbinding variable, then use that variable.

				An arrow starts (ends) in one of the new variables if it starts (ends) somewhere in the term it replaced.
			\item Collect quantifiers: from $\PI(C_i)^*$, $i\in \{1,2\}$ and ones from atom added to $\PI(C)$. Order such that arrows only point to variables to the right AND weakly connected variables appear in the same quantifier block.

				$\bar Q_n = \operatorname{sort}( Q_{n_1} \cup Q_{n_2} \cup \operatorname{colored-terms}(l))$
		\end{enumerate}
\end{enumerate}

\clearpage
\subsection{algo more formally}

Every literal in any initial clause set has a globally unique id/number

Ex: $P(y, a, f(z, g(y, b)) ) \lor Q(x)$

Term position:

$0.2.1.0$ means first literal, 3rd arg, 2nd arg, fst arg: $y$

$0.1$ is $a$

$0.2.1$ is $g(z, b)$

$\pos$ calculates the position of a term or the term of a position, depending on the argument type.

for a position $p_i$, $\pos(p_i)$ denotes whatever $p_i$ refers to in its respective clause.

for a term $t$, $\pos(t)$ denotes the position in $t$ in its respective clause.

for a position $p$, $\poslit(p)$ denotes the position of the literal

for a position $p$, $\posterm(p)$ denotes the position of the term in $p_i$ 

$\Ra$ $p = \poslit(p).\posterm(p)$

for a position $p$, $p \mod i$ denotes $p$ with $i$ least significant places cut off, $0.2.1.0 \mod 2 = 0.2$

\subsection{Arrows:}

$\arr$ is a set of ordered pairs of term positions which point to positions in terms in literals

$\warr$ is a set of unordered pairs of term positions which point to positions in terms in literals

w.r.t a refutation $\pi$ of $\Gamma \cup \Delta$:

\begin{enumerate}
	\item For each initial clause $C$ in $\Gamma \cup \Delta$:

		Add to $\arr$ all $(p_1, p_2)$ in $C$
		such that $p_1$ contains only grey symbol and $\pos(p_1)$ is a variable and $\pos(p_1) = \pos(p_2)$ but $p_1 \neq p_2$.

		Add to $\warr$ all $\{p_1, p_2\}$ such that there is a colored symbol in $p_1$ and a possible different one in $p_2$ and $\pos(p_1)$ is a var and $\pos(p_1) = \pos(p_2)$.

	\item 
		For each $C$ resulting from a resolution step from $C_1: D\lor l$ and $C_2: E\lor \lnot l$ to $C = D \lor E$ with prop interpolant $\PI(\cdot)$:

		Note: literals are added to the interpolant if they occur in both ancestors.

		Merge the respective ids of $l$ and $\lnot l$ , i.e. their arrows. Their term structure will be the same, so all arrows point to valid positions.

		%Each literal in $D$ ($E$) in $C$ is said to come from the respective literal in  $C_1$ ($C_2$). 
		%If $l$ and/or $l'$ is added to $\PI(C)$, it comes from both $l$ and $l'$.


		%Add $(p_1, p_2)$ to $\arr$ if $\poslit{p_i}$ comes from literal $l_i$ in a clause $D$ in an original clause set, $i\in\{1, 2\}$, (both from same $D$), and $(l_1.\posterm{p_1}, l_2.\posterm{p_2}) \in \arr{D}$ 

\end{enumerate}

\subsection{algo}

NOTE: for now, we assume that every colored-term has a globally unique id $i$ and will be replaced by a variable with this index. 
This restriction is useful now and could potentially be lifted later, but it's not severe anyway.

Note: when a literal is added to the interpolant, the colored terms in one literal might have already been replaced with a certain variable before. we definitely have to use the same variable for both literals, and if one literal has other dependencies, we should stick with the variable we have.

PROBLEM: terms already replaced by variables still change! need to use same variable anyway, so note above not accurate!


\subsubsection{$\AImatrix$ and $\AIclause$}

Here, we define $\AImatrix$, which represents the \emph{matrix} of what will be the interpolant, and $\AIclause$, which represents the \emph{clauses} in the refutation applied with the same unifications as $\AImatrix$.

\begin{enumerate}
	\item 
		For each initial clause $C$, $\AImatrix(C) = \PI(C)$ and $\AIclause(C) = \lifboth{C}$.

	\item
		For each $C$ resulting from a resolution step from $C_1: D\lor l$ and $C_2: E\lor \lnot l$ to $C = (D \lor E)\sigma$ with $l\sigma = l'\sigma$ with prop interpolant $\PI(\cdot)$:

		$l.\dotsc$ literal in original clause

		$l\fromclause\dotsc$ literal in $\AIclause$ (with unifications and liftings carried over, such that ind hyp goes through)

		%literal to put in $\AImatrix$ is defined as $x_i =\lifboth{l\sigma} = \lifboth{l'\sigma}$
		%$l^\circ\dotsc$ literal to put in $\AImatrix$ is defined as $x_i =\lifboth{l\sigma} = \lifboth{l'\sigma}$

		$l\sigma = l'\sigma$, but $l\fromclause$ and $l\fromclause'$ might have been overbound with different variables. Still, they in a sense refer to the same ground literal, so we ``can just'' ``unify'' them.
		
		Prose explanation of formal definition below: Shape must be the same in the sense that grey terms are the same, otherwise there is $\Phi$-replacing-var vs $\Phi$-replacing-var (let arbitrary one win) or $\Phi$-replacing-var vs $\Phi$-term (let var win) or $\Phi$-term and $\Phi$-term (replace both with same var). 
		Also apply this to liftings in $\AIclause$ and $\AImatrix$ here.

		$\aiu$ is defined on terms which are used as parameters for literals $l\fromclause$ and $l\fromclause'$
		which occur in $\AIclause(C_1)$, $\AIclause(C_2)$ such that for their corresponding $l$ and $l'$, $l\sigma = l'\sigma$.
		Note that if one of the arguments of $\aiu$ has assigned a color, the other one either has none or the same color.
		There cannot be a conflict as otherwise their original form would not be unifiable.
	%	\[
	%		\aiu ( a_i, b_i) =
	%		\begin{cases}
	%			f_s(\aiu(s_1, t_1), \dotsc, \aiu(s_n, t_n)) & \text{if $a_i=f_s(\bar s)$ grey and $b_i = f_t(\bar t)$ (include $f_s$ being a constant)} \\
	%			x_j & \parbox[t]{.4\textwidth}{ if $a_i = x_j$, where $x_j$ from lifting (then $b_i$ is either variable or term with same color) } \\
	%			x_j & \text{if $b_i = x_j$, if $x_j$ but not $a_i$ from lifting }\\
	%			x_j & \text{if $\lifboth{a_i\sigma} = \lifboth{b_i\sigma} = x_j$ }
	%		\end{cases}
	%	\]
		Note that $\aiu(a, b)$ is well-defined, i.e.~never maps a variable to two different values as each occurrence of some $x_j$ refers to a term with possible free variables, and since across the definition of $\aiu$, always the same substitution $\sigma$ is used as reference, every occurrence of $x_j$ will be mapped to the same variable. (NOTE: this is what yet unproven conjectures in the other pdf are trying to formalize.)

		Let 
		$l\fromclause = A(a_1, \dotsc, a_n)$, $l\fromclause' = A(b_1, \dotsc, b_n)$

		$\aiu(A(a_1, \dotsc, a_n), A(b_1, \dotsc, b_n)) = \bigcup_{i=1}^n \aiu(a_i, b_i)$

		$ \aiu (a, b) =
			\begin{cases}
				\bigcup_{j=1}^n \aiu(s_j, t_j) & \text{if $a=f_s(\bar s)$ grey and $b = f_t(\bar t)$ (includes $f_s$ being a constant)} \\
				\{x_j \mapsto x_k\} & \parbox[t]{.6\textwidth}{ if $a = x_j$ from lifting and $b$ a term with $\lifboth{b\sigma} = x_k$ (note that $b$ is a variable as otherwise it would be colored and lifted)} \\
			\{x_k \mapsto x_j\} & \parbox[t]{.6\textwidth}{  if $b = x_k$ from lifting and $a$ a term with $\lifboth{a\sigma} = x_j$ (note that $a$ is a variable as otherwise it would be colored and lifted)} \\
				\{x_j \mapsto x_m, x_k \mapsto x_m\} & \parbox[t]{.6\textwidth}{if $a = x_j$ and $b = x_k$, both from lifting, and $x_m$ is the lifted term in the unified literal. More formally, $p = \pos(a) = \pos(b)$ and $\pos(\poslit(\lifboth{l\sigma}).\posterm(p)) = \pos(\poslit(\lifboth{l'\sigma}).\posterm(p)) = t_m$ and $\lifboth{t_m} = x_m$.}\\
				\emptyset & \text{if $\lifboth{a\sigma} = \lifboth{b\sigma} = x_j$ }
			\end{cases} $

		$\AIclause(C) =
		\lifboth{\Big( (\AIclause(C_1) \setminus \{l\fromclause\}) \lor (\AIclause(C_2)\setminus \{l\fromclause'\}) \Big)\sigma} \tau$ 

		

		\begin{itemize}
			\item if $l$ and $l'$ don't have the same color:

				$\AImatrix(C) =
				(\lnot {\lifboth{l\fromclause\sigma}\tau} \land \lifboth{\AImatrix(C_1)\sigma}\tau) \lor
				(\lifboth{l\fromclause\sigma}\tau \land \lifboth{\AImatrix(C_2)\sigma) }\tau
				$


				%$\AImatrix(C) =
				%\lifboth{\Big( (\lnot l \land \AImatrix(C_1)) \lor (l \land \AImatrix(C_2)) \Big) \sigma} $


				%		$\left.\begin{tabular}{l}
				%		$\AImatrix(C) = \lifboth{\AImatrix(C)' \sigma}$\\

				%		$\AIclause(C) = \lifboth{\AIclause(C)' \sigma}$
				%\end{tabular}\right\} \lifboth $ with same overbinding!


				%				$\lifboth{ \AImatrix(C)' \lor \AIclause(C)' } = \underbrace{\lifboth{ \AImatrix(C)' }}_{\AImatrix(C)} \lor \underbrace{\lifboth{\AIclause(C)'}}_{\AIclause(C)}$ 


			\item if $l$ and $l'$ are $\Gamma$-colored :

				%$\AImatrix(C) = \lifboth{( \AImatrix(C_1) \lor/\land \AImatrix(C_2) )\sigma}$
				%as above but with  $\AImatrix(C)' = \Big(\AImatrix(C_1) \lor \AImatrix(C_2)\Big)\sigma$
				$\AImatrix(C) = \lifboth{\Big(\AImatrix(C_1) \lor \AImatrix(C_2)\Big)\sigma} \tau$
			\item if $l$ and $l'$ are $\Delta$-colored:

				%as above but with  $\AImatrix(C)' = \Big(\AImatrix(C_1) \land \AImatrix(C_2)\Big)\sigma$
				$\AImatrix(C) = \lifboth{\Big(\AImatrix(C_1) \land \AImatrix(C_2)\Big)\sigma} \tau$


		\end{itemize}

\end{enumerate}

\subsubsection{$\AI$}


$\AI(C) = Q_1 u_1 \ldots Q_m u_m \AImatrix(C)$

$u_1, \ldots, u_m$ are comprised of all $x_i$ and $y_i$ PLUS all free variables in $\AImatrix(C)$.

$Q_i$ is $\exists$ if $u_i = y_i$ for some $i$, $\forall$ if $u_i = x_i$ for some $i$.
For free variables, $Q_i$ as in $C_1/C_2$. if $u_i\sigma \neq u_i$, $u_i$ becomes one of $x_j$ or $y_j$ or grey term.

$(p_1, p_2) \in \operatorname{TransitiveClosure}(\arr)$ implies that $u_i < u_j$ if $u_i$ replaces $t_i$ and $u_j$ replaces $t_j$ and $p_1$ points into $t_i$ and $p_2$ points into $t_j$.


\clearpage

\section{proof of propositional aspect of $\AI$}

\begin{lemma}[Restated from proof without propositional refutation, lemma 1] 
	\label{lemma:lift_subst_commute}
	Let $C$ be a clause and $\sigma$ a substitution.
	Let $t_1,\ldots,t_n$ be all maximal $\Delta$-terms in this context, i.e.\ those that occur in $C$ or $C\sigma$,  and
	$x_1, \ldots, x_n$ the corresponding fresh variables to replace the $t_i$ (i.e.~none of the $x_i$ occur in $C$).
	Define $\sigma'$ such that for a variable $z$,
	\[
		z \sigma' =
		\begin{cases} 
			x_l & \text{ if } z = x_k \text{ and } t_k\sigma = t_l  \\
			\lif{z\sigma} & \text{ otherwise}
		\end{cases} 
	\]

	Then
	$\lif{C\sigma} =
	\lif{C}\sigma'$.
\end{lemma}

\begin{remark}[Restriction of Lemma \ref{lemma:lift_subst_commute}]
	Lemma \ref{lemma:lift_subst_commute} does not hold in case $x_i$ occurs in $C$.
	This can easily be seen using the following counterexample:


	Let $\sigma = \{x \mapsto a\}$ and $t_1 = f(x)$ and $t_2 = f(a)$. 
	Then clearly $t_1\sigma = t_2$ and therefore $x_1\sigma' = x_2$.

	But now consider $x_1 \sigma$. 
	As $x_1$ has its place in the domain of variables to replace colored terms, and $\sigma$ is taken from a resolution refutation, they do not affect each other. 
	Hence $x_1\sigma = x_1$ and therefore $\lifdelta{x_1\sigma} = x_1$, but $\lifdelta{x_1}\sigma' = \lifdelta{x_1}\sigma' = x_2$.


	However such a situation arises naturally if we lift colored terms after every step of the interpolant extraction procedure, as there, the intermediate relative interpolants clearly contains variables to overbind terms, but we also need to treat terms that enter the interpolant by means of unification.
\end{remark}

\begin{lemma}[corresponds to Lemma 4.8 in thesis and Lemma 11 in Huang]
	\label{lemma:lift_logic_commute}
	Let $A$ and $B$ be first-order formulas and $s$ and $t$ be terms. Then it holds that:
	\begin{enumerate}
		\item $\lift{\Phi}{\lnot A}{x} \semiff{} \lnot \lift{\Phi}{A}{x}$
		\item $\lift{\Phi}{A \circ B}{x} \semiff{} ( \lift{\Phi}{A}{x} \circ \lift{\Phi}{B}{x} )$ for  $\circ \in     \{\land, \lor\}$
		\item $\lift{\Phi}{s = t}{x} \semiff{} ( \lift{\Phi}{s}{x} = \lift{\Phi}{t}{x} )$
	\end{enumerate}
\end{lemma}



\begin{lemma}
	\label{lemma:no_colored_terms}
	$\AImatrix(C)$ and $\AIclause(C)$ contain only grey terms and variables replacing colored terms. They do not contain colored terms.
	\comm{true and used}
\end{lemma}



\begin{corr}
	\label{corr:lift_ai}
	For a clause $C$ in a resolution refutation $\pi$ of $\Gamma \cup \Delta$:
	\begin{compactenum}
	\item $\AImatrix(C) = \lifboth{\AImatrix(C)}$.

	\item $\AIclause(C) = \lifboth{\AIclause(C)}$.
	\end{compactenum}
	\comm{true and unused}
\end{corr}

\begin{lemma}
	\label{lemma:no_lifting_vars_in_subst}
	Lifting variables do not occur in any substitution of a resolution refutation.
	\comm{true and used, also generally relevant}
\end{lemma}

\begin{lemma}
	\label{lemma:substitute_and_lift}
	Let $F$ be a formula without colored terms such that for a set of formulas $\Phi$, $\Phi \entails F$.
	Then $\Phi \entails \lifboth{F\sigma}$ for a substitution $\sigma$.
\end{lemma}
\begin{proof}
	Note that substitutions only replace variables. Term positions, which are replaced by grey terms by $\sigma$ are not affected by the lifting and hold due to being special cases of~$F$.

	Term positions, which are replaced by colored term by $\sigma$ are again reduced to variables.
	All occurrences of a certain variable in $F$ are substituted by the same term, so as the lifting replaces a certain term always be the same variables, all these occurrences of the variable are replaced by the same variable.
\end{proof}


\begin{lemma} 
	\label{lemma:literal_in_clause_similar}
	If a literal $l$ occurs in a clause $C$ from a resolution refutation,
	then $\AIclause(C)$ contains corresponding a literal $l\fromclause$ such that $l\fromclause \sim \lifboth{l}$, where $\sim$ means equal up to the index of the variables which replace colored terms.
\comm{true and somewhat used}
\end{lemma}
\begin{proof}
	Base case: By Definition of $\AIclause$.

	Let $C$ be the result of a resolution step from $C_1: D\lor l$ and $C_2: E\lor \lnot l'$ to $C = (D \lor E)\sigma$.
	Every literal of $C$ is derived from a literal in $C_1$ or $C_2$. Let $\lambda$ be a literal in $C_1$. The case for a literal in $C_2$ is analogous.
	Note that $\lambda \neq l$ as otherwise $\lambda$ would not be contained in $C$.

	By assumption $\lambda \in C_1$. Then by the resolution rule application, $\lambda\sigma \in C$.

	\newcommand{\lclOne}{\lambda\cl}
	By the induction hypothesis, there is a $\lclOne \in \AIclause(C_1)$ such that $\lclOne \sim \lifboth{\lambda}$.
	By the definition of $\AIclause$, $\lifboth{\lclOne\sigma}\tau \in \AIclause(C)$ 
	with $\tau = \aiu(l, l')$.

	So we have to show that $\lifboth{ \lambda \sigma }  \sim \lifboth{\lambda\cl\sigma}\tau$.

	Remark on $\tau$: $\tau$ only replaces lifting terms by other lifting by other lifting terms
				\NB{this is where variable indices may not match.}

				We perform an induction on the depth of terms in $\lambda$ (except the non-maximal colored terms).
	\begin{itemize}
			\item Suppose $t$ is a term of size $1$ in $\lambda$ and it is a lifting variable, say $z_i$.
				Then by Lemma~\ref{lemma:no_lifting_vars_in_subst}, $t\sigma = t$ and also $\lifboth{t\sigma} = t$.

				As by the induction hypothesis $t\fromclause \sim \lifboth{t}$, $t\fromclause =z_j$.
				Hence, $\lifboth{t\cl\sigma} = t\cl$.
				By the remark on~$\tau$,
				$\lifboth{t\sigma} \sim \lifboth{t\cl\sigma}\tau$.

			\item Suppose $t$ is a term of size $1$ in $\lambda$ and it is a non-lifting variable, say $u$.
				%Suppose that $\sigma$ is trivial on $u$. Then $\lifboth{u\sigma} = u \sim u\cl = \lifboth{u\cl\sigma} = \lifboth{u\cl\sigma}\tau$.

				%Otherwise suppose that $\sigma$ is not trival on $u$.
				As $\lifboth{u}\sim u\cl$ and $u$ is a variable, $u = u\cl$.
				But then $u\sigma = u\cl\sigma$ and also $\lifboth{u \sigma} = \lifboth{u\cl\sigma}$ and
				$\lifboth{u\sigma} \sim \lifboth{u\cl\sigma}\tau$.

				%Note that by the induction hypothesis, we get the desired relation for possible subterms of $u\sigma$.
				%Suppose that $u\sigma$ is a grey term. Then $\lifboth{u\sigma} = u\sigma$. 
				%Furthermore as $\lifboth{u} = u$, $\lifboth{u}\sigma = u\sigma$. Hence $\lifboth{u\sigma} = \lifboth{\lifboth{u}\sigma}$. 
				%As $\tau$ again only replaces variables which replace colored terms by other variables of the same kind, the induction holds in this case. \NB{$\tau$ stuff again}

			\item Suppose $t$ is a term of size $1$ in $\lambda$ and it is a constant.
				Suppose $t$ is grey. Then it is unaffected by both liftings and substitutions.
				Otherwise suppose $t$ is colored.
				Then $\lifboth{t\sigma}$ is a lifting variable, but 
				as $t\cl = \lifboth{t}$, so is $\lifboth{t\fromclause\sigma}\tau$.

				\NB{From the point on where $t$ was lifted, $t\cl$ even always refers to exactly the lifting var $\lifboth{t} = x_k$ for some $k$. Cf.\ Lemma~\ref{lemma:jka5a5halat}. Hence this case is no obstacle to showing the statement with $\lifboth{t}=t\fromclause$ (and not just $\lifboth{t}\sim t\cl$).}
				

			\item Suppose $t$ is of the form $f(t_1, \dotsc, t_n)$ in $\lambda$.
				Then by the induction hypothesis, $\lifboth{t_i\sigma} \sim \lifboth{(t_i)\fromclause\sigma}\tau$ for $1 \leq i \leq n$.
				\begin{compactitem}
					\item Suppose $f$ is grey.
						Then $f$ is neither affected by substitutions nor by liftings.

					\item Suppose $f$ is colored.
						We only consider the case of occurrences of maximal colored terms as the other ones are discarded by the lifting.
						As $t\cl \sim \lifboth{t}$, $t\cl$ is a lifting variable. Hence also $\lifboth{t\cl\sigma}\tau$ is a lifting variable.
						But so is $\lifboth{t\sigma}$.
						\qedhere

				\NB{Note that even if it was the case that $\lifboth{t}=t\fromclause$ (and not just $\lifboth{t}\sim t\cl$), $\lifboth{t\sigma}$ might not be equal to $\lifboth{t\fromclause\sigma}$, but only $\lifboth{t\sigma} \sim \lifboth{t\fromclause\sigma}$.
				
					E.g.\ $t = f(x)$, $\lifboth{t} = x_1$, $t\cl = x_1$, $\sigma = \{x\mapsto a\}$. 
					Then $\lifboth{t\sigma} = \lifboth{f(a)} = x_2$, but $\lifboth{t\cl\sigma} = x_1$.
					$\tau$ does not fix this, but could potentially if it is more careful than $\sigma'$.
					See also Example~\ref{exa:lifting_var_refers_to_different_term}.
				}

				\end{compactitem}
	\end{itemize}
\end{proof}


\begin{changebar}
\begin{lemma}
	\label{lemma:tau_is_specialisation}
	$(z_j \mapsto z_k) \in \tau$ implies that there is a substitution $\rho$ such that $t_j \rho = t_k$.
\end{lemma}
\begin{proof}
	Note that when $z_j$ is first introduced, it actually is $t_j$. 
	If $t_j$ contains a var which also appears elsewhere, it might be changed but still referred to as $z_j$. Then it is $t_j\rho'$ for some $\rho'$.
	(this was the base case)

	induction:
	suppose there is a substituion $\rho'$ from the original introduction of $t_j$ to the point where $z_j$ is first changed.
	We show that if $z_j$ is changed to $z_k$, then $t_j\rho'\sigma = t_k$, hence by transitivity of the specialisation-relation, $t_k$ is still a specialisation of the original introduction.
	
	$l\sigma = l'\sigma$

	\begin{itemize}
		\item Suppose first kind of $\tau$ entry.
			Then 

			$a\cl \in l\cl$, $a\cl=z_j$. Let $a=t_j\rho'$ for some $\rho'$, see note above.

			$b\cl \in l\cl$, same position as $a\cl$, $\lifboth{b\cl\sigma} = z_k$. $b\cl$ is a non-lifting variable and by $\lifboth{b} \sim b\cl$, $b=b\cl$.

			But $a\sigma = b\sigma$, so $t_j\rho'\sigma = b\sigma$.
			But $b\cl \sigma = t_k$, so $b\sigma = t_k$, so $t_j\rho'\sigma = t_k$.

		\item Suppose second kind of $\tau$ entry.\nopagebreak

			$a\cl \in l\cl$, $a\cl=z_j$. Let $a=t_j\rho'$ for some $\rho'$, see note above.

			$t_k$ here is actually even $a$.
			\qedhere
	\end{itemize}
\end{proof}
\end{changebar}

\cbstart
\begin{lemma}[Strenghtening of \ref{lemma:literal_in_clause_similar}]
	\label{lemma:literal_in_clause_similar_strenghtened}
	If for term $s$ in $l$ and the corresponding $s\cl$ in $l\cl$ we have that $s\cl = z_i$ and $\lifboth{s} = z_j$ (i.e.\ $s=t_j$),
	then there is a substitution $\rho$ such that $t_i\rho = t_j$.
\end{lemma} 
\begin{proof}
	Note that if $i=j$, the $\rho$ is the identity function.

	Note that by Lemma~\ref{lemma:literal_in_clause_similar}, $s\cl \sim \lifboth{s}$.

	At some point in the resolution proof, $s\cl = z_i$ was introduced in $\AIclause(C^*)$ for a clause $C^*$. 
	Hence the corresponding term in $C^*$ is $t_i$.

	In the resolution derivation, $t_i$ is, in general, changed by means of substitution, so $s$ in later stages of the proof refers to $t_i\sigma^*$ for some $\sigma^*$.

	If $z_i$ is never affected by $\tau$, we are done.

	Suppose that at the position of $s\cl$, $z_k$ is introduced and later changed to $z_i$.
	We have to show that there is a substitution $\rho$ such that $t_k\rho = t_i$.
	See Lemma~\ref{lemma:tau_is_specialisation}.
\end{proof}
\cbend



\begin{lemma}
	\label{lemma:tau_only_for_variable_terms}
	$(x_j \mapsto x_k) \in \aiu(l\fromclause, l\fromclause')$ with $j\neq k$ implies that $t_j$ (corresponding to $x_j$) contains a free variable.

	In other words: If $t_j$ does not contain a free variable, then if it is lifted to $x_j$, $\tau$ will never change it to some $x_k$ with $k\neq j$.
	\comm{true but unused in actual proof of the procedure}
\end{lemma}
\begin{proof}
	Let  $\aiu(s\fromclause, r\fromclause)$ introduce $\{x_j \mapsto x_k\}$.
	We perform a case distinction:
	\begin{itemize}
		\item Suppose $s\fromclause$ is a lifting variable and but $r\fromclause$ is not.
			Then by the definition of $\aiu$, $s\fromclause = x_j$ and $\lifboth{r\fromclause\sigma} = x_k$.
			Suppose that $t_j$ does not have a free variable.
			Then in the resolution derivation, from the point on as it is lifted by $x_j$ the original term does not change, hence $s = t_j$. As in consequence $s$ does not contain free variables, $s\sigma = s$.
			As $s\sigma = r\sigma$ by the resolution rule application, we have that $s = r\sigma$.
			But as $\lifboth{s} = \lifboth{s_j} = x_j$, we must also have that $\lifboth{r\sigma} = x_j$.
			Hence $r\sigma = t_j$.

			As $r\fromclause$ occurs in $\AIclause(C)$ for some $C$, it is not a colored term, but as it is not a lifting variable and $r\fromclause\sigma$ is a colored term, $r\fromclause$ must be a variable.
			By Lemma~\ref{lemma:literal_in_clause_similar}, as $r \in C$, $r\fromclause$ is equal to $s$ up to the index of lifting variables, hence $r = r\fromclause$.

			But then $r\fromclause\sigma = r\sigma = t_j$, so $\lifboth{r\fromclause\sigma} = x_j$. But then $j=k$, a contradiction.

		\item Suppose $r\fromclause$ is a lifting variable but $s\fromclause$ is not. This case can be argued analogously.

		\item Suppose that both $s\fromclause$ and $r\fromclause$ are a lifting variables.
			Then by the definition of $\aiu$, $s = r = t_k$ such that $\lifboth{t_k} = x_k$.
			Suppose that $t_j$ does not contain a free variable. Then from the point on where $s\fromclause$ has been lifted, $t_j$ does not change. Therefore $s = t_j$. But then $k=j$, a contradiction.
			\qedhere
	\end{itemize}
\end{proof}

\begin{lemma}
	\label{lemma:jka5a5halat}
	If a grey or maximal colored term $t$ in a clause $C$ does not contain a free variable, then for $t\cl$ in $\AIclause$, we have that $\lifboth{t}=t\cl$. 
	\comm{this is more of a comment, prove properly before actually using it}
\end{lemma}
\begin{proof}
	Either $t$ is there from beginning, then $t\cl = \lifboth{t}$.
	Otherwise it was introduced by a substitution, but then it was also introduced in $\AIclause(C)$ and lifted there.

	Substitutions do not affect $t\cl$ due to Lemma~\ref{lemma:no_lifting_vars_in_subst}.
	Hence also liftings do not affect $t\cl$.
	By Lemma~\ref{lemma:tau_only_for_variable_terms}, $\tau$ does not change $t\cl$.

	$\Ra$ $t$ as well as $t\cl$ remain invariant
\end{proof}

\cbstart
\begin{lemma}
	\label{lemma:just_introduced_lifting_vars_not_affected_by_tau}
	Let $u$ be a variable in a literal $l$ being unified in a resolution step with $l'$ using $\sigma$ and let $\lifboth{u\sigma} = z_k$.
	Then $z_k\tau = z_k$.
	\comm{true and used}
\end{lemma}
\begin{proof}

	\NB{much weird stuff here, but last two paragraphs of first item seem to make sense}

	\NB{possibly try to show that $u\sigma = t_j$ in first item}

	$u\sigma = t_k$.

	as $l\sigma = l'\sigma$, in $l'$ there is $t$ with $u\sigma = t\sigma$, so $t\sigma = t_k$.


	\begin{itemize}
			\item
				Suppose that $(z_k\mapsto z_j) \in \tau$ (first kind). Suppose that $k\neq j$ as otherwise we are done.
				Then we have a pair of corresponding terms $(a\cl, b\cl)$ in $l\cl$ and $l\cl'$ respectively such that  
				$a\cl = z_k$ and $b\cl$ is such that $\lifboth{b\cl\sigma} = z_j$ but $b\cl$ is not a lifting variable. As by Lemma~\ref{lemma:no_colored_terms} $b\cl$ is not colored, it must be a variable.
				and as by Lemma~\ref{lemma:literal_in_clause_similar} $b\cl \sim \lifboth{b}$, $b = b\cl$.
				Also $b = t_j$

				By Lemma~\ref{lemma:literal_in_clause_similar} $a\cl \sim \lifboth{a}$. 
				By Lemma~\ref{lemma:literal_in_clause_similar_strenghtened}, there is a substitution $\rho$ such that $t_k\rho = a$.
				So $a$ is a specialisation of $t_k$.

				Furthermore due to $l\sigma = l'\sigma$, $a\sigma = b\sigma$.
				Hence $\lifboth{b\cl\sigma} = \lifboth{b\sigma} = \lifboth{a\sigma}$.

				$a\sigma = b\sigma$, so $t_k\rho\sigma = b\sigma = t_j$. 
				

				%As $u$ is a variable and by Lemma~\ref{lemma:literal_in_clause_similar} $u\cl \sim \lifboth{u}$, $u = u\cl$.
				\bigskip


				By Lemma~\ref{lemma:tau_only_for_variable_terms}, $t_k$ contains a free variable.
				As each incomparable clause is variable disjoint, $C_1$ and $C_2$ are variable disjoint\todo{really?}.
				Hence $t_k$ can only occur in one of them, w.l.o.g.\ let it occur in $C_1$ say at $p$.

				$u\sigma = t\sigma = t_k$

				we only have $(z_k \mapsto z_j)$ if the underlying term is unified, i.e.\ the variable is replaced.
				This variable only occurs in this clause (or related ones).
				But $t\sigma=t_k$, i.e.~either $t$ still contains this variable or $\sigma$ introduces it.

				$t$ cannot still contain it as $t_k\sigma$ removes it, and $\sigma$ cannot introduce it as $C_1$ and $C_2$ are variable disjoint, and it could only add it if a variable from the other clause is unified with it, but that variabel then cannot occur in $t$ as it's from the other clause.


			\item
				Suppose that $(z_k\mapsto z_j) \in \tau$ (second kind). Suppose that $k\neq j$ as otherwise we are done.

				Similar reasoning: there is a variable in $t_k$ occurring at least twice (as $z_k$).
				but then it must be unified to the same variable. so there, the same terms are present and the lifting variables are set accordingly by this crude method.

				So $u$ is substituted for whatever happens on this other side, i.e. $u\sigma = t_j$
	\end{itemize}
\end{proof}
\cbend

\begin{lemma}
	\label{lemma:disjoint_lifting_variables}
	The set of lifting variables, which refer to terms which have free variables, is disjoint for every incomparable clause.
	\comm{true but ok to have unused}
\end{lemma}
\begin{proof}
	The free variables for every inital clause is disjoint.
\end{proof}

Apparently, $\tau$ establishes equality for the terms in the literals being resolved on and quasi-equality for other literals in the remaining clause:
\begin{lemma}
	\label{lemma:literals_clauses_equal}
	Let $l\fromclause$, $l\fromclause'$ be the literal in $\AIclause(C_1)$ and $\AIclause(C_2)$ corresponding to $l$ and $l'$ where 
	$C$ is the result of a resolution step from $C_1: D\lor l$ and $C_2: E\lor \lnot l'$ to $C = (D \lor E)\sigma$
	(i.e.~$l\sigma=l'\sigma$).
	Let $\tau = \aiu(l\fromclause\sigma, l\fromclause'\sigma)$. Then $\lifboth{l\fromclause\sigma}\tau = \lifboth{l\fromclause'\sigma}\tau$.
	\comm{true and used}
\end{lemma}
\begin{proof} 
	Let $s\fromclause$ be a (sub-)term of a parameter of $l\fromclause\sigma$ and $t\cl$ the term at the same term position in $l\fromclause'\sigma$.
	Let $s$ and $t$ be their corresponding (sub)-term at the same term position in $l\sigma$ and $l'\sigma$.
	We show that $\lifboth{s\fromclause\sigma}\tau = \lifboth{t\fromclause\sigma}\tau$ by induction on the structure of $s\fromclause$ and $t\fromclause$ respectively.

	Note that by Lemma~\ref{lemma:no_colored_terms}, $s\fromclause$ and $t\fromclause$ do not contain colored terms. This also implies that only grey terms can contain subterms.

	By Lemma~\ref{lemma:literal_in_clause_similar}, $l\cl \sim \lifboth{l}$ and
	$l'\cl \sim \lifboth{l'}$. 

	\begin{description}
		\item[Lifting variables.]

			Suppose that $s\fromclause = z_i$ and/or $t\fromclause = z_j$ for some $i$ and $j$.
			Suppose that $s\fromclause \neq t\fromclause$ as otherwise we are done.
			%Hence $s\neq t$, but
			By the resolution rule application $s\sigma = t\sigma$. Cases:
			\begin{compactitem}
			\item $s\fromclause = z_i$ and $t\fromclause = z_j$ with $i\neq j$.
				As $\sigma$ affects neither $s\fromclause$ nor $t\fromclause$,
				$\lifboth{s\fromclause \sigma}  = s\fromclause$ and
				$\lifboth{t\fromclause \sigma}  = t\fromclause$.
				We show that $s\fromclause\tau = t\fromclause\tau$.

				Note that the function $\aiu$ visits all subterms and combines all mappings it encounters.
				Hence $\aiu(s\fromclause, t\fromclause)$ is part of the final substitution $\tau$.
				However due to the just established circumstances, $\aiu(s\fromclause, t\fromclause) = \{z_i \mapsto z_m, z_j \mapsto z_m\}$ with $m$ as in the definition of $\aiu$, so $s\fromclause\tau = t\fromclause\tau$.
				\NB{this is the somewhat crude step where all lifting variables in the resolved literal are just reset.}

			\item W.l.o.g.~$s\fromclause = z_i$ and $t\fromclause$ is not a lifting variable.
				As $t\cl \sim \lifboth{t}$, $t$ is not a colored term.
				But due to $s\cl \sim \lifboth{s}$, $s$ is a colored term.
				As $s\sigma = t\sigma$, $t$ must be a variable and $t\sigma$ a colored term.
				So $\lifboth{t\sigma} = z_k$ for some $k$.
				Note that the function $\aiu$ visits all subterms and combines all mappings it encounters.
				By the construction of $\aiu$, at $\aiu(s\fromclause, t\fromclause)$, $\{ z_i \mapsto z_k \}$ is added.
				Therefore $\lifboth{s\fromclause\sigma}\tau = \lifboth{z_i\sigma}\tau = \lifboth{z_i}\tau = z_i\tau = z_k$.

				Due to $t\cl \sim \lifboth{t}$ and as $t$ is a variable, $t=t\cl$.
				Then $\lifboth{t\cl\sigma}\tau = \lifboth{t\sigma}\tau = z_k\tau$. By Lemma~\ref{lemma:just_introduced_lifting_vars_not_affected_by_tau}, $z_k\tau = z_k$.

				%			But as $t\fromclause = \lifboth{t}$ and $t$ is a variable, $t\fromclause\sigma = s$.
				%Note that $\sigma$ does not affect $s\fromclause$.
				%So $\lifboth{t\fromclause\sigma} = \lifboth{s} =  s\fromclause = s\fromclause\sigma = \lifboth{s\fromclause\sigma}$ and also 
				%$\lifboth{t\fromclause\sigma}\tau = \lifboth{s\fromclause\sigma}\tau$.
			\end{compactitem}

		\item[Grey terms.]
			Suppose that at least one of $s\cl$ and $t\cl$ is a grey term.
			\begin{itemize}
				\item
					Suppose that both $s\fromclause$ and $t\fromclause$ are grey terms:
					By $s\fromclause = \lifboth{s}$ and 
					$t\fromclause = \lifboth{t}$, and as $s\sigma = t\sigma$, their outermost symbol is the same in all these terms.
					The equality of the parameters is established by the induction hypothesis.
					Note that grey constants can be treated as grey functions without parameters.

				\item
					Suppose that exactly one of $s\fromclause$ and $t\fromclause$ is a grey terms. W.l.o.g.~let $s\fromclause$ be a grey term. Then as $s\sigma=t\sigma$, $s\fromclause = \lifboth{s}$ and $t\fromclause = \lifboth{t}$, $t\fromclause$ is a variable and $t=t\cl$.
					Furthermore, $t\fromclause\sigma$ is a grey term. 
					Even more, their outermost symbol is the same due to $s\sigma = t\sigma$.
					Equality of potential parameters in $s\fromclause$ is established by the induction hypothesis.
			\end{itemize}


		\item[Variables.]
			Suppose that both $s\fromclause$ and $t\fromclause$ are variables. 
			Suppose that $\sigma$ is non-trivial on at least $s\fromclause$ or $t\fromclause$, as otherwise we would be done.
			Due to $s\fromclause = \lifboth{s}$ and $t\fromclause = \lifboth{t}$, $s = s\fromclause$ and $t=t\fromclause$.
			As $s\sigma=t\sigma$,  the outermost symbol of both $s\fromclause\sigma$ is the same as the one of $t\fromclause\sigma$. As the equality of potential parameters of $s\fromclause\sigma$ and $t\fromclause\sigma$ is established by the induction hypothesis, we are done.
			\qedhere
	\end{description}
\end{proof}

\begin{exa} 
	\label{exa:lifting_var_refers_to_different_term}
	We illustrate that the given procedure, if a lifting variable $x_k$ occurs in $\AIclause(C)$, it does not necessaily mean that $t_k$ occurs in $C$:

	$\Gamma = \{P(f(x))\lor Q(x)\}$

	$\Delta = \{\lnot P(y), \lnot Q(a)\}$
	\begin{prooftree}
		\AxiomCm{ \bot \mid P(f(x))\lor Q(x) }
		\AxiomCm{ \top \mid \lnot P(y) }

		\BinaryInfCm{ P(x_1) \mid Q(x) }

		\AxiomCm{ \top \mid \lnot Q(a) }

		\BinaryInfCm{  Q(y_2) \lor P(x_1) \mid \square }
	\end{prooftree}
	Here, $x_1$ first refers to $f(x)$ and later to $f(a)$.
	This however is not essential for the correctness of the procedure, and it would be tedious to fix all such $x_1$ see also corresponding remark in case distinction in Lemma~\ref{lemma:literal_in_clause_similar}.
\end{exa} 


\begin{lemma}
  Suppose no $\Gamma$-term occurs in $\Gamma$.
  Then
  $\Gamma \entails \AImatrix(C) \lor \AIclause(C)$.
\end{lemma}
\begin{proof}
  Proof by induction of the strenghtening:
  $\Gamma \entails \AImatrix(C) \lor \AIclause(C_\Gamma)$.

  Base case:

	For $C \in \Gamma$, $\AImatrix(C) = \bot$ and $\AIclause(C) = \lifboth{C_\Gamma} = \lifgamma{C}$. By the restriction, $\lifgamma{C} = C$ and $\Gamma \entails C$.\todo{restriction used here}

  For $C \in \Delta$, $\AImatrix(C) = \top$.

  Induction step:


  \begin{description}
    \item{Resolution.}
      \begin{prooftree}
        \AxiomCm{C_1: D \lor l}
				\AxiomCm{C_2: E \lor \lnot l'}
				\RightLabelm{\quad \sigma = \mgu(l, l')}
				\BinaryInfCm{C: (D\lor E)\sigma}
			\end{prooftree}
			We introduce the following abbreviations, where $l^*$ is the literal in $\AIclause$ which corresponds to $l$:

			\newcommand{\clauseOnePrime}{\AIclause(C_1)^*}
			\newcommand{\clauseTwoPrime}{\AIclause(C_2)^*}

			$ \clauseOnePrime = \AIclause((C_1)_\Gamma) \setminus \{\lifboth{(l{\fromclause})_\Gamma}\}$

			$ \clauseTwoPrime = \AIclause((C_2)_\Gamma)\setminus \{\lifboth{\lnot (l{\fromclause'})_\Gamma}\}$

			$\tau  = \aiu((l{\fromclause})_\Gamma, (l{\fromclause'})_\Gamma)$

			$\AIclause(C_\Gamma) =
			\lifboth{\Big( \clauseOnePrime \lor \clauseTwoPrime \Big)\sigma} \tau$.

			By Lemma~\ref{lemma:lift_logic_commute},
			$\AIclause(C_\Gamma) =
			\lifboth{\clauseOnePrime\sigma}\tau \lor \lifboth{\clauseTwoPrime\sigma} \tau$.

			By the induction hypothesis,
			$\Gamma \entails \AImatrix(C_i) \lor \AIclause({C_i}_\Gamma)$, $i\in\{1,2\}$, or expressed differently:


			$\Gamma \entails \AImatrix(C_1) \lor \clauseOnePrime \lor {(l{\fromclause})_\Gamma}$

			$\Gamma \entails \AImatrix(C_2) \lor \clauseTwoPrime \lor {\lnot (l{\fromclause'})_\Gamma}$

					By Lemma~\ref{lemma:no_colored_terms}, $\AImatrix(C_1)$ and $\AIclause(C_1)$ as well as $\AImatrix(C_2)$ and $\AIclause(C_2)$ do not contain colored terms.
					Hence by Lemma~\ref{lemma:substitute_and_lift}, Lemma~\ref{lemma:lift_logic_commute} and applying $\tau$, we get that 

					$\Gamma \stackrel{\markA}\entails \lifboth{\AImatrix(C_1)\sigma}\tau \lor \lifboth{\clauseOnePrime\sigma}\tau \lor \lifboth{(l{\fromclause})_\Gamma\sigma}\tau$

					$\Gamma \stackrel{\markB}\entails \lifboth{\AImatrix(C_2)\sigma}\tau \lor \lifboth{\clauseTwoPrime\sigma}\tau \lor \lnot \lifboth{(l{\fromclause'})_\Gamma\sigma}\tau$

			
			%Furthermore,
			%$\sigma = \mgu(l, l')$, so $\lifboth{l\sigma} = \lifboth{l'\sigma}$ and $\lifboth{l}\sigma' = \lifboth{l'}\sigma'$ by Lemma \ref{lemma:lift_subst_commute}.

			By Lemma~\ref{lemma:literals_clauses_equal}, $\lifboth{(l\fromclause)_\Gamma\sigma}\tau = \lifboth{(l{\fromclause'})_\Gamma\sigma} \tau$.

			\begin{itemize}
				\item If $l$ and $l'$ grey:

					$\AImatrix(C) =
					(\lnot {\lifboth{l\fromclause\sigma}\tau} \land \lifboth{\AImatrix(C_1)\sigma}\tau) \lor
					(\lifboth{l\fromclause\sigma}\tau \land \lifboth{\AImatrix(C_2)\sigma) }\tau
					$

					Suppose for a model $M$ of $\Gamma$ that $M \notentails \AIclause(C)$,
					i.e.~$M \notentails \lifboth{\AIclause(C_1)\sigma}\tau$ and $M \notentails\nolinebreak \lifboth{\AIclause(C_2)\sigma}\tau$ as otherwise we would be done.
					Then by \markA{} and \markB:

					$M \entails \lifboth{\AImatrix(C_1)\sigma}\tau \lor \lifboth{l{\fromclause}\sigma}\tau$

					$M \entails \lifboth{\AImatrix(C_2)\sigma}\tau \lor \lnot \lifboth{l{\fromclause'}\sigma}\tau$

					By Lemma~\ref{lemma:literals_clauses_equal}, $\lifboth{l\fromclause\sigma}\tau = \lifboth{l{\fromclause'}\sigma} \tau$.
					By a case distinction on the truth value of $\lifboth{l\fromclause\sigma}\tau$ in $M$, we obtain that $M \entails \AImatrix(C)$.


				\item If $l$ and $l'$ are $\Gamma$-colored:
					$\AImatrix(C) = \lifboth{\Big(\AImatrix(C_1) \lor \AImatrix(C_2)\Big)\sigma} \tau$

					By Lemma~\ref{lemma:literals_clauses_equal}, we can do a resolution step on $\lifboth{l\fromclause\sigma}\tau$ of \markA{} and \markB{} to arrive at 

					$\Gamma \entails \lifboth{\AImatrix(C_1)\sigma}\tau \spam\lor \lifboth{\clauseOnePrime\sigma}\tau\spam\lor 
					\lifboth{\AImatrix(C_2)\sigma}\tau\spam\lor \lifboth{\clauseTwoPrime\sigma}\tau $

					This however is by Lemma~\ref{lemma:lift_logic_commute} nothing else than
					$\Gamma \entails \AImatrix(C) \lor \AIclause(C)$

				\item If $l$ and $l'$ are $\Delta$-colored:
					$\AImatrix(C) = \lifboth{\Big(\AImatrix(C_1) \land \AImatrix(C_2)\Big)\sigma} \tau$

					As $l$ is $\Delta$-colored, \markA{} and \markB{} reduce to:

					$\Gamma \entails \lifboth{\AImatrix(C_1)\sigma}\tau \lor \lifboth{\clauseOnePrime\sigma}\tau$

					$\Gamma \entails \lifboth{\AImatrix(C_2)\sigma}\tau \lor \lifboth{\clauseTwoPrime\sigma}\tau$

					But this implies that 

					$\Gamma \entails \Big(\lifboth{\AImatrix(C_1)\sigma}\tau \land \lifboth{\clauseOnePrime\sigma}\tau\Big) 
\spam\lor \lifboth{\clauseOnePrime\sigma}\tau
\spam\lor \lifboth{\clauseTwoPrime\sigma}\tau$

					This however is by Lemma~\ref{lemma:lift_logic_commute} nothing else than 
					$\Gamma \entails \AImatrix(C) \lor \AIclause(C)$.
					\qedhere
			\end{itemize}

	\end{description}


\end{proof}


\clearpage
\section{thoughts}

\begin{conj}
	Double ended arrows are not important as terms are overbound with same variable anyway as always same unifier applies.
\end{conj}

\clearpage
\section{arrow proof}

\begin{lemma}
	\label{lemma:arrow_for_same_variables}
	Whenever the same variable appears multiple times in $\PI(C)\lor C$ for $C \in \pi$, there are arrows.

	\begin{itemize}
		\item If both variables are contained only in grey terms, there is a double arrow \comm{they unify to exactly the same}
		\item If only one variable is only contained in grey terms, there is an arrow from it to the other one \comm{either unify the one in grey term, then other one must be overbound later. if otherwise var in the colored term is unified, we can still overbind the grey one first. }
		\item otherwise there are weak arrows between them \comm{have same quantifier, so order does not matter, but want to keep dependencies on both the same}
	\end{itemize}
\end{lemma}
\begin{proof}
	By induction. Note: As required by resolution, all initial clauses are variable disjoint.

	Base case:
	In the initial clause sets, consider for a clause $C$ two different positions $p_1$ and $p_2$ pointing to the same variable. 
	Then either:
	\begin{itemize}
		\item $p_1$ and $p_2$ contain only grey symbols. Then $(p_1, p_2) \in \arr$.
		\item Only $p_i$, $i\in\{1,2\}$ contains only grey symbols. Then $(p_i, p_{(i \mod 2)+1}) \in \arr$.
		\item There are not only grey symbols in both $p_1$ and $p_2$, i.e.~both contain at least a colored symbol. Then $\{p_1, p_2\} \in \warr$. 
	\end{itemize}

	Induction step:
	Suppose a clause $C$ is the result of a resolution of $C_1: D \lor l$ and $C_2: E \lor \lnot l$ with $l\sigma = l'\sigma$.
	$\PI(C)$ is $[\PI(C_1) \circ \PI(C)]\sigma$ or $[(l \land \PI(C_2)) \lor (\lnot l \land \PI(C_1)) ] \sigma $.

	Assumption: $C_1$ and $C_2$ are variable disjoint, i.e.~variables are renamed in case $C_1$ and $C_2$ are derived from some common original clause and share variables.

	By the induction hypothesis, there are appropriate arrows in both $\PI(C_i) \lor C_i$, $i \in \{1,2\}$.

	If the variables were present in $C_1$ or $C_2$, the arrow is still there, either in $\PI(C)$ (in the case of $l$ or $l'$), $C$ (in case of $D$ and $E$) or in currently not shown literal (in case $l$ and $l'$ have the same color).

	Otherwise, it was introduced by unification in $l\sigma$ or $\PI(C_i)\sigma$.
	In this case, there is some term position $q$ in with $\pos(l).q$ a variable and $\pos(l').q$ a variable or a term containing variables (or other way around).
	Hence unification maps a variable to a variable or a term containing variables.
	The variable being unified is in $\PI(C_i)\lor C_i$ for some $i\in\{1,2\}$.
	But by the induction hypothesis, all occurrences of each variable does already have appropriate arrows, which are still present. 
\end{proof}



\begin{lemma}
	In $\PI(C)\lor C$ for $C \in \pi$, if there is a $\Delta$-colored term $s$ in a $\Gamma$-term $t$, then there is an arrow from $p_1$ to $p_2$ such that $\pos(p_1) = s$ and $\pos(p_2) = s$ and for some $i$, $\pos( p_2 \mod i ) = t$.
\end{lemma}
Note: $p_1$ might be in some clause, the prop interpolant or none of both. 
\begin{proof}
	By induction.

	Base case: There are no foreign terms in the initial clause sets, so no arrows necessary.

	Induction step:

	\begin{itemize}
		\item[Resolution.]
			Suppose a clause $C$ is the result of a resolution of $C_1: D \lor l$ and $C_2: E \lor \lnot l$ with $l\sigma = l'\sigma$.

			\begin{enumerate}
				\item Suppose $l$ is colored. 
					This case is similar to the grey one, with the exception that the cases applying to $l$ in $\PI$ do not apply.

				\item Suppose $l$ is grey. Then  $\PI(C) = [(l \land \PI(C_2)) \lor (\lnot l \land \PI(C_1)) ] \sigma $

					By the induction hypothesis, there are appropriate arrows in $\PI(C_1) \lor C_1$ and $\PI(C_2) \lor C_2$.

					We show that for all maximal $\Gamma$-terms in $\PI(C)\lor C$ with $\Delta$-terms in them which were not present in $\PI(C_i)\lor C_i$, $i \in \{1,2\}$, there is an arrow.

					$\Gamma$-terms and $\Delta$-terms are not unifiable.
					%Hence all pairs of terms $(t_1, t_2)$ in the same positions in $l$ and $l'$ (if both positions exist) are both grey, or w.l.o.g.~$t_1$ is a variable and $t_2$ is a colored/grey term.
					Hence all pairs of terms $(t_1, t_2)$ in the same positions in $l$ and $l'$ (if both positions exist) either point to the same symbol or (w.l.o.g.) $t_1$ is a variable and $t_2$ is a term.
					If there are $\Delta$-terms in $\Gamma$-terms in the prefix, they are present in both ancestors and handled by the induction hypothesis.

					The only way a $\Delta$-colored term may enter a $\Gamma$-colored term is in the situation where $t_1$ is a variable and $t_2$ a colored term.
					But then $\mgu(t_1, t_2)$ applied to $t_1$ yields $t_2$, i.e.~``the parts of $\sigma$ concerned with unifying $t_1$ and $t_2$'' do not introduce new $\Delta$-terms in $\Gamma$-terms.
					In other words, all such situation have been present in $\PI(C_i) \lor C_i$ for $i \in \{1,2\}$ and since the arrows for $l$ and $l'$ are merged, they are present for $l\sigma$ in $\PI(C)$.

					This handles the case where terms $t_1$ and $t_2$ are unified. 
					But unification also affects all other occurrences of variables, this means ``the parts of $\sigma$ not concerned with unifying $t_1$ and $t_2$''.
					The relevant case for this lemma is when a $\Gamma$-term contains a variable, that is substituted by a term containing $\Delta$-terms.
					But in this case, by Lemma \ref{lemma:arrow_for_same_variables}, there is an arrow from the other occurrence of the variable to the one in the $\Gamma$-term: either double arrow in $\arr$ if both prefixes are grey, one in $\arr$ if one of the prefixes is grey or one in $\warr$ if both prefixes contain a colored symbol.
					\qedhere
			\end{enumerate}
	\end{itemize}
\end{proof}


\end{document}
