\documentclass[,%fontsize=11pt,%
	paper=a4,% 
	%landscape,
	%DIV12, % mehr text pro seite als defaultyyp
	%DIV10, 
	%DIV=calc,%
	twoside=false,%
	liststotoc,
	bibtotoc,
	draft=false,% final|draft % draft ist platzsparender (kein code, bilder..)
	%titlepage,
	numbers=noendperiod
]{scrartcl}

\usepackage{lscape}
\usepackage{stackengine}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

\usepackage{enumerate}
\usepackage{paralist}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,backgrounds,graphs,%
	matrix,patterns,arrows,decorations.pathmorphing,decorations.pathreplacing,%
	positioning,fit,calc,decorations.text,shadows%
}


\input{../latex_header.tex}

% subsections also in toc
\setcounter{tocdepth}{2}

%\declaretheorem[title=Theorem,qed=$\triangle$,parent=chapter]{thm}
\newcommand{\thmqed}{$\square$} % for thms without proof
\newcommand{\propqed}{$\square$} % for props without proof
\declaretheorem[title=Theorem]{thm}
\declaretheorem[title=Proposition,sibling=thm]{prop}
%\declaretheorem[title=Lemma,parent=chapter]{lemma}
\declaretheorem[sibling=thm]{lemma}
\declaretheorem[title=Corollary,sibling=thm]{corr}
\declaretheorem[sibling=thm,title=Definition,style=definition,qed=$\triangle$]{defi}
%\declaretheorem[title=Definition,qed=$\triangle$,parent=chapter]{defi}
\declaretheorem[title=Example,style=definition,qed=$\triangle$,sibling=thm]{exa}

\declaretheorem[sibling=thm,title=Conjecture]{conj}

\declaretheorem[title=Remark,style=remark,numbered=no,qed=$\triangle$]{remark}

%\def\proofSkipAmount{ \vskip -0.5em}



%\usepackage{bussproof}

%\usepackage{vaucanson-g}
\usepackage{amssymb}
\usepackage{latexsym}

% for color-highlighted code
%\usepackage{color} % for grey comments
%\usepackage{alltt}

%\usepackage[doublespacing]{setspace}
\usepackage[onehalfspacing]{setspace}
%\usepackage[singlespacing]{setspace}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{comment}
\usepackage{color}
\usepackage[final]{listings} % sourcecode in document
\usepackage{url}      % for urls
\usepackage{multicol}
\usepackage{float}
\usepackage{caption}
\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{graphicx}

\usepackage[authoryear]{natbib} % \cite ; square|round etc.
%\usepackage[numbers,square]{natbib}
%\usepackage[square, authoryear]{natbib}
%\usepackage[language=english]{biblatex}

%\bibliographystyle{plain}
\bibliographystyle{alpha}
%\bibliographystyle{alphadin}
%\bibliographystyle{dinat}
%\bibliographystyle{chicago}
%\bibliographystyle{plainnat}

\bibdata{bib.bib}

\renewcommand*{\partformat}{\partname\ \thepart\ -}
\let\partheadmidvskip\

\newcommand{\comp}{\ensuremath{\text{comp}}}
% smaller url style
\makeatletter
\def\url@leostyle{%
\@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
\urlstyle{leo}

\newcommand{\myfig}[5] {
	\begin{figure}[tbph]
		\centering
		\includegraphics[#3]{#1}
		\caption[#4]{#5}
		\label{fig:#2}
	\end{figure}
}

\setlength{\parindent}{0em}
%\usepackage{thmtools} % actually already in latex_header.tex ...

\usepackage{amsthm}


\usepackage{tikz-qtree}

%\newcommand{\sig}[1]{{#1}_\Sigma}
%\newcommand{\p}[1]{{#1}_\Pi}
\newcommand{\sig}[1]{\stackrel{\Sigma}{#1}}
\newcommand{\p}[1]{\stackrel{\Pi}{#1}}

\newcommand{\e}[1]{\vskip .7em   \subsection*{#1}}

\def\proofSkipAmount{ \vskip -0.3em}

\usepackage{refcheck}

\begin{document}

\newcommand{\lif}[1]{\lift{\Delta}{#1}{x}}


	%\newcommand{\lifboth}[1]{\lft{\Gamma\cup\Delta}{z}{#1}}

\section{Arrow-Algo}

\begin{enumerate}
	\item
		In the original clauses, find all occurrences of variables.

		Common case:
		If a variable appears as outermost symbol or only has grey ancestor-terms, add an arrow from it to all other occurrences.

		Uncommon case:
		if there is more than one occurrence of a variable under a $\Phi$-colored term, add a \emph{weak} dependency between them all (symmetric relation).


		NOTE: this creates double arrows for occurrences at same depth. This appears to be necessary for terms which are only variables, and doesn't hurt if the variable is contained in a term.

	\item For each step in the derivation:
		\begin{enumerate}
			\item Build propositional interpolant using $\PI(C_i)^*$, $i\in \{1,2\}$, i.e.~use ancestor $\PI$ without colored terms.
			\item If ancestors of atom added to $\PI(C)$ had arrows, merge them to atom in $\PI(C)$ (i.e.~arrows starting in and leading to this atom).
			\item Replace colored terms in $\PI(C)$ (from new atom and unifier applied to $\PI(C_i)^*$) with fresh variables, except if a term has a double ended arrow to another overbinding variable, then use that variable.

				An arrow starts (ends) in one of the new variables if it starts (ends) somewhere in the term it replaced.
			\item Collect quantifiers: from $\PI(C_i)^*$, $i\in \{1,2\}$ and ones from atom added to $\PI(C)$. Order such that arrows only point to variables to the right AND weakly connected variables appear in the same quantifier block.

				$\bar Q_n = \operatorname{sort}( Q_{n_1} \cup Q_{n_2} \cup \operatorname{colored-terms}(l))$
		\end{enumerate}
\end{enumerate}

\clearpage
\subsection{algo more formally}

Every literal in any initial clause set has a globally unique id/number

Ex: $P(y, a, f(z, g(y, b)) ) \lor Q(x)$

Term position:

$0.2.1.0$ means first literal, 3rd arg, 2nd arg, fst arg: $y$

$0.1$ is $a$

$0.2.1$ is $g(z, b)$

$\pos$ calculates the position of a term or the term of a position, depending on the argument type.

for a position $p_i$, $\pos(p_i)$ denotes whatever $p_i$ refers to in its respective clause.

for a term $t$, $\pos(t)$ denotes the position in $t$ in its respective clause.

for a position $p$, $\poslit(p)$ denotes the position of the literal

for a position $p$, $\posterm(p)$ denotes the position of the term in $p_i$ 

$\Ra$ $p = \poslit(p).\posterm(p)$

for a position $p$, $p \mod i$ denotes $p$ with $i$ least significant places cut off, $0.2.1.0 \mod 2 = 0.2$

\subsection{Arrows:}

$\arr$ is a set of ordered pairs of term positions which point to positions in terms in literals

$\warr$ is a set of unordered pairs of term positions which point to positions in terms in literals

w.r.t a refutation $\pi$ of $\Gamma \cup \Delta$:

\begin{enumerate}
	\item For each initial clause $C$ in $\Gamma \cup \Delta$:

		Add to $\arr$ all $(p_1, p_2)$ in $C$
		such that $p_1$ contains only grey symbol and $\pos(p_1)$ is a variable and $\pos(p_1) = \pos(p_2)$ but $p_1 \neq p_2$.

		Add to $\warr$ all $\{p_1, p_2\}$ such that there is a colored symbol in $p_1$ and a possible different one in $p_2$ and $\pos(p_1)$ is a var and $\pos(p_1) = \pos(p_2)$.

	\item 
		For each $C$ resulting from a resolution step from $C_1: D\lor l$ and $C_2: E\lor \lnot l$ to $C = D \lor E$ with prop interpolant $\PI(\cdot)$:

		Note: literals are added to the interpolant if they occur in both ancestors.

		Merge the respective ids of $l$ and $\lnot l$ , i.e. their arrows. Their term structure will be the same, so all arrows point to valid positions.

		%Each literal in $D$ ($E$) in $C$ is said to come from the respective literal in  $C_1$ ($C_2$). 
		%If $l$ and/or $l'$ is added to $\PI(C)$, it comes from both $l$ and $l'$.


		%Add $(p_1, p_2)$ to $\arr$ if $\poslit{p_i}$ comes from literal $l_i$ in a clause $D$ in an original clause set, $i\in\{1, 2\}$, (both from same $D$), and $(l_1.\posterm{p_1}, l_2.\posterm{p_2}) \in \arr{D}$ 

\end{enumerate}

\subsection{algo}

NOTE: for now, we assume that every colored-term has a globally unique id $i$ and will be replaced by a variable with this index. 
This restriction is useful now and could potentially be lifted later, but it's not severe anyway.

Note: when a literal is added to the interpolant, the colored terms in one literal might have already been replaced with a certain variable before. we definitely have to use the same variable for both literals, and if one literal has other dependencies, we should stick with the variable we have.

PROBLEM: terms already replaced by variables still change! need to use same variable anyway, so note above not accurate!


\subsubsection{$\AImatrix$ and $\AIclause$}

Here, we define $\AImatrix$, which represents the \emph{matrix} of what will be the interpolant, and $\AIclause$, which represents the \emph{clauses} in the refutation applied with the same unifications as $\AImatrix$.

\begin{enumerate}
	\item 
		For each initial clause $C$, $\AImatrix(C) = \PI(C)$ and $\AIclause(C) = \lifboth{C}$.

	\item
		For each $C$ resulting from a resolution step from $C_1: D\lor l$ and $C_2: E\lor \lnot l$ to $C = (D \lor E)\sigma$ with $l\sigma = l'\sigma$ with prop interpolant $\PI(\cdot)$:

		$l.\dotsc$ literal in original clause

		$l\fromclause\dotsc$ literal in $\AIclause$ (with unifications and liftings carried over, such that ind hyp goes through)

		%literal to put in $\AImatrix$ is defined as $x_i =\lifboth{l\sigma} = \lifboth{l'\sigma}$
		%$l^\circ\dotsc$ literal to put in $\AImatrix$ is defined as $x_i =\lifboth{l\sigma} = \lifboth{l'\sigma}$

		$l\sigma = l'\sigma$, but $l\fromclause$ and $l\fromclause'$ might have been overbound with different variables. Still, they in a sense refer to the same ground literal, so we ``can just'' ``unify'' them.
		
		Prose explanation of formal definition below: Shape must be the same in the sense that grey terms are the same, otherwise there is $\Phi$-replacing-var vs $\Phi$-replacing-var (let arbitrary one win) or $\Phi$-replacing-var vs $\Phi$-term (let var win) or $\Phi$-term and $\Phi$-term (replace both with same var). 
		Also apply this to liftings in $\AIclause$ and $\AImatrix$ here.

		$\aiu$ is defined on terms which are used as parameters for literals $l\fromclause$ and $l\fromclause'$
		which occur in $\AIclause(C_1)$, $\AIclause(C_2)$ such that for their corresponding $l$ and $l'$, $l\sigma = l'\sigma$.
		Note that if one of the arguments of $\aiu$ has assigned a color, the other one either has none or the same color.
		There cannot be a conflict as otherwise their original form would not be unifiable.
	%	\[
	%		\aiu ( a_i, b_i) =
	%		\begin{cases}
	%			f_s(\aiu(s_1, t_1), \dotsc, \aiu(s_n, t_n)) & \text{if $a_i=f_s(\bar s)$ grey and $b_i = f_t(\bar t)$ (include $f_s$ being a constant)} \\
	%			x_j & \parbox[t]{.4\textwidth}{ if $a_i = x_j$, where $x_j$ from lifting (then $b_i$ is either variable or term with same color) } \\
	%			x_j & \text{if $b_i = x_j$, if $x_j$ but not $a_i$ from lifting }\\
	%			x_j & \text{if $\lifboth{a_i\sigma} = \lifboth{b_i\sigma} = x_j$ }
	%		\end{cases}
	%	\]
		Note that $\aiu(a, b)$ is well-defined, i.e.~never maps a variable to two different values as each occurrence of some $x_j$ refers to a term with possible free variables, and since across the definition of $\aiu$, always the same substitution $\sigma$ is used as reference, every occurrence of $x_j$ will be mapped to the same variable.

		Let 
		$l\fromclause = A(a_1, \dotsc, a_n)$, $l\fromclause' = A(b_1, \dotsc, b_n)$

		$\aiu(A(a_1, \dotsc, a_n), A(b_1, \dotsc, b_n)) = \bigcup_{i=1}^n \aiu(a_i, b_i)$

		$ \aiu (a, b) =
			\begin{cases}
				\bigcup_{j=1}^n \aiu(s_j, t_j) & \text{if $a=f_s(\bar s)$ grey and $b = f_t(\bar t)$ (includes $f_s$ being a constant)} \\
				\{x_j \mapsto x_k\} & \parbox[t]{.6\textwidth}{ if $a = x_j$ from lifting and $b$ a term with $\lifboth{b\sigma} = x_k$ (note that $b$ is a variable as otherwise it would be colored and lifted)} \\
			\{x_k \mapsto x_j\} & \parbox[t]{.6\textwidth}{  if $b = x_k$ from lifting and $a$ a term with $\lifboth{a\sigma} = x_j$ (note that $a$ is a variable as otherwise it would be colored and lifted)} \\
				\{x_j \mapsto x_m, x_k \mapsto x_m\} & \parbox[t]{.6\textwidth}{if $a = x_j$ and $b = x_k$, both from lifting, and $x_m$ is the lifted term in the unified literal. More formally, $p = \pos(a) = \pos(b)$ and $\pos(\poslit(\lifboth{l\sigma}).\posterm(p)) = \pos(\poslit(\lifboth{l'\sigma}).\posterm(p)) = x_m$.}\\
				\emptyset & \text{if $\lifboth{a\sigma} = \lifboth{b\sigma} = x_j$ }
			\end{cases} $

		$\AIclause(C) =
		\lifboth{\Big( (\AIclause(C_1) \setminus \{l\fromclause\}) \lor (\AIclause(C_2)\setminus \{l\fromclause'\}) \Big)\sigma} \tau$ 

		

		\begin{itemize}
			\item if $l$ and $l'$ don't have the same color:

				$\AImatrix(C) =
				(\lnot {\lifboth{l\fromclause\sigma}\tau} \land \lifboth{\AImatrix(C_1)\sigma}\tau) \lor
				(\lifboth{l\fromclause\sigma}\tau \land \lifboth{\AImatrix(C_2)\sigma) }\tau
				$


				%$\AImatrix(C) =
				%\lifboth{\Big( (\lnot l \land \AImatrix(C_1)) \lor (l \land \AImatrix(C_2)) \Big) \sigma} $


				%		$\left.\begin{tabular}{l}
				%		$\AImatrix(C) = \lifboth{\AImatrix(C)' \sigma}$\\

				%		$\AIclause(C) = \lifboth{\AIclause(C)' \sigma}$
				%\end{tabular}\right\} \lifboth $ with same overbinding!


				%				$\lifboth{ \AImatrix(C)' \lor \AIclause(C)' } = \underbrace{\lifboth{ \AImatrix(C)' }}_{\AImatrix(C)} \lor \underbrace{\lifboth{\AIclause(C)'}}_{\AIclause(C)}$ 


			\item if $l$ and $l'$ are $\Gamma$-colored :

				%$\AImatrix(C) = \lifboth{( \AImatrix(C_1) \lor/\land \AImatrix(C_2) )\sigma}$
				%as above but with  $\AImatrix(C)' = \Big(\AImatrix(C_1) \lor \AImatrix(C_2)\Big)\sigma$
				$\AImatrix(C) = \lifboth{\Big(\AImatrix(C_1) \lor \AImatrix(C_2)\Big)\sigma} \tau$
			\item if $l$ and $l'$ are $\Delta$-colored:

				%as above but with  $\AImatrix(C)' = \Big(\AImatrix(C_1) \land \AImatrix(C_2)\Big)\sigma$
				$\AImatrix(C) = \lifboth{\Big(\AImatrix(C_1) \land \AImatrix(C_2)\Big)\sigma} \tau$


		\end{itemize}

\end{enumerate}

\subsubsection{$\AI$}


$\AI(C) = Q_1 u_1 \ldots Q_m u_m \AImatrix(C)$

$u_1, \ldots, u_m$ are comprised of all $x_i$ and $y_i$ PLUS all free variables in $\AImatrix(C)$.

$Q_i$ is $\exists$ if $u_i = y_i$ for some $i$, $\forall$ if $u_i = x_i$ for some $i$.
For free variables, $Q_i$ as in $C_1/C_2$. if $u_i\sigma \neq u_i$, $u_i$ becomes one of $x_j$ or $y_j$ or grey term.

$(p_1, p_2) \in \operatorname{TransitiveClosure}(\arr)$ implies that $u_i < u_j$ if $u_i$ replaces $t_i$ and $u_j$ replaces $t_j$ and $p_1$ points into $t_i$ and $p_2$ points into $t_j$.


\clearpage

\section{proof of propositional aspect of $\AI$}

\begin{lemma}[Restated from proof without propositional refutation, lemma 1] 
	\label{lemma:lift_subst_commute}
	Let $C$ be a clause and $\sigma$ a substitution.
	Let $t_1,\ldots,t_n$ be all maximal $\Delta$-terms in this context, i.e.\ those that occur in $C$ or $C\sigma$,  and
	$x_1, \ldots, x_n$ the corresponding fresh variables to replace the $t_i$ (i.e.~none of the $x_i$ occur in $C$).
	Define $\sigma'$ such that for a variable $z$,
	\[
		z \sigma' =
		\begin{cases} 
			x_l & \text{ if } z = x_k \text{ and } t_k\sigma = t_l  \\
			\lif{z\sigma} & \text{ otherwise}
		\end{cases} 
	\]

	Then
	$\lif{C\sigma} =
	\lif{C}\sigma'$.
\end{lemma}

\begin{remark}[Restriction of Lemma \ref{lemma:lift_subst_commute}]
	Lemma \ref{lemma:lift_subst_commute} does not hold in case $x_i$ occurs in $C$.
	This can easily be seen using the following counterexample:


	Let $\sigma = \{x \mapsto a\}$ and $t_1 = f(x)$ and $t_2 = f(a)$. 
	Then clearly $t_1\sigma = t_2$ and therefore $x_1\sigma' = x_2$.

	But now consider $x_1 \sigma$. 
	As $x_1$ has its place in the domain of variables to replace colored terms, and $\sigma$ is taken from a resolution refutation, they do not affect each other. 
	Hence $x_1\sigma = x_1$ and therefore $\lifdelta{x_1\sigma} = x_1$, but $\lifdelta{x_1}\sigma' = \lifdelta{x_1}\sigma' = x_2$.
	

	However such a situation arises naturally if we lift colored terms after every step of the interpolant extraction procedure, as there, the intermediate relative interpolants clearly contains variables to overbind terms, but we also need to treat terms that enter the interpolant by means of unification.
\end{remark}

\begin{lemma}[corresponds to Lemma 4.8 in thesis and Lemma 11 in Huang]
	\label{lemma:lift_logic_commute}
	Let $A$ and $B$ be first-order formulas and $s$ and $t$ be terms. Then it holds that:
	\begin{enumerate}
		\item $\lift{\Phi}{\lnot A}{x} \semiff{} \lnot \lift{\Phi}{A}{x}$
		\item $\lift{\Phi}{A \circ B}{x} \semiff{} ( \lift{\Phi}{A}{x} \circ \lift{\Phi}{B}{x} )$ for  $\circ \in     \{\land, \lor\}$
		\item $\lift{\Phi}{s = t}{x} \semiff{} ( \lift{\Phi}{s}{x} = \lift{\Phi}{t}{x} )$
	\end{enumerate}
\end{lemma}



\begin{lemma}
	$\AImatrix(C)$ and $\AIclause(C)$ contain only grey terms and variables replacing colored terms. They do not contain colored terms.
	\label{lemma:no_colored_terms}
	\comm{true and used}
\end{lemma}



\begin{corr}
  For a clause $C$ in a resolution refutation $\pi$ of $\Gamma \cup \Delta$:
  \begin{compactenum}
    \item $\AImatrix(C) = \lifboth{\AImatrix(C)}$.

    \item $\AIclause(C) = \lifboth{\AIclause(C)}$.
  \end{compactenum}
  \label{corr:lift_ai}
  \comm{true and unused}
\end{corr}

\begin{lemma}
  The $x_i$, $y_i$ and $z_i$ do not occur in any substitution of a resolution refutation.
  \comm{true but unused}
\end{lemma}

\begin{lemma}
	Let $F$ be a formula without colored terms such that for a set of formulas $\Phi$, $\Phi \entails F$.
	Then $\Phi \entails \lifboth{F\sigma}$ for a substitution $\sigma$.
	\label{lemma:substitute_and_lift}
\end{lemma}
\begin{proof}
	Note that substitutions only replace variables. Term positions, which are replaced by grey terms by $\sigma$ are not affected by the lifting and hold due to being special cases of~$F$.

	Term positions, which are replaced by colored term by $\sigma$ are again reduced to variables.
	All occurrences of a certain variable in $F$ are substituted by the same term, so as the lifting replaces a certain term always be the same variables, all these occurrences of the variable are replaced by the same variable.
\end{proof}

\begin{prop}
	$\aiu$ is well-defined, i.e.~if it maps a variable $x$ to another variable $y$, then $y$ is unique.
\end{prop}


Apparently, $\tau$ establishes equality for the terms in the literals being resolved on and quasi-equality for other literals in the remaining clause.
\begin{lemma}
	Let $l\fromclause$, $l\fromclause'$ be the literal in $\AIclause(C_1)$ and $\AIclause(C_2)$ corresponding to $l$ and $l'$ where 
	$C$ is the result of a resolution step from $C_1: D\lor l$ and $C_2: E\lor \lnot l'$ to $C = (D \lor E)\sigma$
(i.e.~$l\sigma=l'\sigma$).
Let $\tau = \aiu(l\fromclause\sigma, l\fromclause'\sigma)$. Then $\lifboth{l\fromclause\sigma}\tau = \lifboth{l\fromclause'\sigma}\tau$.
\label{lemma:literals_clauses_equal}
\comm{true and used}
\end{lemma}
\begin{proof} 
	Let $s\fromclause$ be a (sub-)term of a parameter of $l\fromclause\sigma$ and $t\fromclause\sigma$ the term at the same term position in $l\fromclause'\sigma$. Let $s$ and $t$ be their corresponding (sub)-term at the same term position in $l\sigma$ and $l'\sigma$.
We show that $\lifboth{s\fromclause\sigma}\tau = \lifboth{t\fromclause\sigma}\tau$ by induction on the structure of $s\fromclause$ and $t\fromclause$ respectively.

	Note that by Lemma~\ref{lemma:no_colored_terms}, $s\fromclause$ and $t\fromclause$ do not contain colored terms. Hence only grey terms can contain subterms.

	Suppose that $s\fromclause = z_i$ and/or $t\fromclause = z_j$ for some $i$ and $j$.
	Suppose that $s\fromclause \neq t\fromclause$ as otherwise we are done.
	Hence $s\neq t$, but by the resolution rule application $s\sigma = t\sigma$. Cases:
	\begin{compactitem}
		\item $s\fromclause = z_i$ and $t\fromclause = z_j$ with $i\neq j$.
					As $\sigma$ affects neither $s\fromclause$, nor $t\fromclause$,
					$\lifboth{s\fromclause \sigma}  = s\fromclause$ and
					$\lifboth{t\fromclause \sigma}  = t\fromclause$.
					We show that $s\fromclause\tau = t\fromclause\tau$.

					Note that the function $\aiu$ visits all subterms and combines all mappings it encounters.
					Hence $\aiu(s\fromclause, t\fromclause)$ is part of the final substitution $\tau$.
					However due to the just established circumstances, $\aiu(s\fromclause, t\fromclause) = \{z_i \mapsto z_m, z_j \mapsto z_m\}$ with $m$ as in the definition of $\aiu$, so $s\fromclause\tau = t\fromclause\tau$.

		\item W.l.o.g.~$s\fromclause = z_i$ and $t\fromclause \neq z_j$ for any $j$.
			Then as $s\sigma = t\sigma$ and $s$ is a $\Delta$-term, $t$ must be a variable which is substituted for a $\Delta$-term by $\sigma$.
			So $\lifboth{t\sigma} = z_k$ for some $k$.
			Note that the function $\aiu$ visits all subterms and combines all mappings it encounters.
			At $\aiu(s\fromclause, t\fromclause)$, $\{ z_i \mapsto z_k \}$ is added.
			Therefore $\lifboth{s\fromclause\sigma}\tau = \lifboth{z_i\sigma}\tau = \lifboth{z_i}\tau = z_i\tau = z_k$.
			As the $\Delta$-term which is replaced by $z_k$ occurs in the unified literal, none of its occurrences are modified any further, so $z_k$ is not updated to some $z_l$, $l\neq k$ by the substitution $\tau$.
			Therefore $z_k = z_k \tau = \lifboth{t\fromclause\sigma}\tau = z_k \tau$. 
%			But as $t\fromclause = \lifboth{t}$ and $t$ is a variable, $t\fromclause\sigma = s$.
			%Note that $\sigma$ does not affect $s\fromclause$.
			%So $\lifboth{t\fromclause\sigma} = \lifboth{s} =  s\fromclause = s\fromclause\sigma = \lifboth{s\fromclause\sigma}$ and also 
			%$\lifboth{t\fromclause\sigma}\tau = \lifboth{s\fromclause\sigma}\tau$.
	\end{compactitem}

	Suppose that $s\fromclause$ and $t\fromclause$ are grey terms:
	Then their outermost symbol is unaffected by the lifting and as $s\sigma = t\sigma$, the outermost symbol is the same under $\sigma$ in $s\fromclause \sigma$ and $t\fromclause\sigma$.
	The equality of the parameters is established by the induction hypothesis.
	Note that grey constants can be treated as grey functions without parameters.

	Suppose that one of $s\fromclause$ and $t\fromclause$ are grey terms. W.l.o.g.~Let $s\fromclause$ be a grey term. Then as $s\sigma=t\sigma$, $t\fromclause$ is a variable such that $t\fromclause\sigma$ is a grey term. 
	Even more, their outermost symbol is the same due to $s\sigma = t\sigma$.
	Equality of the children is established by the induction hypothesis.


	Suppose that both $s\fromclause$ and $t\fromclause$ are variables. 
	Suppose that $\sigma$ is non-trivial on at least $s\fromclause$ or $t\fromclause$, as otherwise we would be done.
	Note that due to $s\sigma = t\sigma$, the outermost symbol of both $s\fromclause\sigma$ is the same as the one of $t\fromclause\sigma$. As the equality of the children of $s\fromclause\sigma$ and $t\fromclause\sigma$ is established by the induction hypothesis, we are done.
\end{proof}


\begin{lemma} 
	If a literal $l$ occurs in a clause $C$ from a resolution refutation,
	then $\AIclause(C)$ contains a literal $l\fromclause$ such that $l\fromclause \sim \lifboth{l}$, where $\sim$ means equal up to the index of the variables which replace colored terms.
\comm{true but unused}
\end{lemma}
\begin{proof}
	Base case: By Definition of $\AIclause$.

	Let $C$ be the result of a resolution step from $C_1: D\lor l$ and $C_2: E\lor \lnot l'$ to $C = (D \lor E)\sigma$.
	Every literal of $C$ is derived from a literal in $C_1$ or $C_2$. Let $\lambda$ be a literal in $C_1$. The case for a literal in $C_2$ is analogous.
	Note that $\lambda \neq l$ as otherwise it would not be contained in $C$.

	By assumption $\lambda \in C_1$. Then by the resolution rule application, $\lambda\sigma \in C$.

	By the induction hypothesis, $\lifboth{\lambda} \in \AIclause(C_1)$.
	By the definition of $\AIclause$, $\lifboth{\lifboth{\lambda}\sigma}\tau \in \AIclause(C)$ 
	with $\tau = \aiu(l, l')$.

	So we have to show that $\lifboth{ \lambda \sigma }  \sim \lifboth{\lifboth{\lambda}\sigma}\tau$.

	We perform an induction on the depth of terms in $\lambda$.
	\begin{itemize}
			\item Suppose $t$ is a term of size $1$ in $\lambda$ and  it is a variable.

				Suppose the variable $t$ was introduced by a lifting, say $z_i$.
				Then $t\sigma = t$ and $\lifboth{t\sigma} = t$.
				Furthermore, $\lifboth{t} = t$, $\lifboth{t}\sigma = t$ and $\lifboth{\lifboth{t}\sigma} = t$.
				As $\tau$ only replaces variables which replace colored terms by other variables of the same type, $\lifboth{\lambda \sigma} \sim \lifboth{\lifboth{\lambda}\sigma}\tau$.
				\NB{this is where variable indices may not match.}

				Otherwise suppose the variable $t$ occurs in the resolution refutation, say $u$.
				Suppose that $\sigma$ is not trival on $u$ as otherwise we are done.
				Note that by the induction hypothesis, we get the desired relation for possible subterms of $u\sigma$.
				Suppose that $u\sigma$ is a grey term. Then $\lifboth{u\sigma} = u\sigma$. 

				Furthermore as $\lifboth{u} = u$, $\lifboth{u}\sigma = u\sigma$. Hence $\lifboth{u\sigma} = \lifboth{\lifboth{u}\sigma}$. 
				As $\tau$ again only replaces variables which replace colored terms by other variables of the same kind, the induction holds in this case. \NB{$\tau$ stuff again}

			\item Suppose $t$ is a term of size $1$ in $\lambda$ and  it is a constant.
				Suppose $t$ is grey. Then it is unaffected by both liftings and substitutions.
				Otherwise suppose $t$ is colored. Then $\lifboth{t\sigma} = \lifboth{t} = \lifboth{t}\sigma = \lifboth{\lifboth{t}\sigma}$.
				As $\tau$ again only replaces variables which replace colored terms by other variables of the same kind, the induction holds in this case. \NB{$\tau$ stuff again}


			\item Suppose $t$ is of the form $f(t_1, \dotsc, t_n)$.
				Then by the induction hypothesis, $\lifboth{t_i\sigma} = \lifboth{\lifboth{t_i}\sigma}\tau$ for $1 \leq i \leq n$.
				\begin{compactitem}
					\item Suppose $f$ is grey.
						Then $f$ is neither affected by substitutions nor by liftings.

					\item Suppose $f$ is colored.
						We only consider the case of occurrences of maximal colored terms as the other ones are discarded by the lifting.
						Then $\lifboth{t\sigma} = z_i$ for some $i$ and
						$\lifboth{t} = z_j$ for some $j$. 
						Furthermore $\lifboth{t}\sigma = z_j$ and  $\lifboth{\lifboth{t}\sigma} = z_j$.
						Hence $\lifboth{t\sigma} \sim \lifboth{\lifboth{t}\sigma}$.
						\qedhere
				\end{compactitem}
	\end{itemize}


\end{proof}


\begin{lemma}
  Suppose no $\Gamma$-term occurs in $\Gamma$.
  Then
  $\Gamma \entails \AImatrix(C) \lor \AIclause(C)$.
\end{lemma}
\begin{proof}
  Proof by induction of the strenghtening:
  $\Gamma \entails \AImatrix(C) \lor \AIclause(C_\Gamma)$.

  Base case:

	For $C \in \Gamma$, $\AImatrix(C) = \bot$ and $\AIclause(C) = \lifboth{C_\Gamma} = \lifgamma{C}$. By the restriction, $\lifgamma{C} = C$ and $\Gamma \entails C$.\todo{restriction used here}

  For $C \in \Delta$, $\AImatrix(C) = \top$.

  Induction step:


  \begin{description}
    \item{Resolution.}
      \begin{prooftree}
        \AxiomCm{C_1: D \lor l}
				\AxiomCm{C_2: E \lor \lnot l'}
				\RightLabelm{\quad \sigma = \mgu(l, l')}
				\BinaryInfCm{C: (D\lor E)\sigma}
			\end{prooftree}
			We introduce the following abbreviations, where $l^*$ is the literal in $\AIclause$ which corresponds to $l$:

			\newcommand{\clauseOnePrime}{\AIclause(C_1)^*}
			\newcommand{\clauseTwoPrime}{\AIclause(C_2)^*}

			$ \clauseOnePrime = \AIclause((C_1)_\Gamma) \setminus \{\lifboth{(l{\fromclause})_\Gamma}\}$

			$ \clauseTwoPrime = \AIclause((C_2)_\Gamma)\setminus \{\lifboth{\lnot (l{\fromclause'})_\Gamma}\}$

			$\tau  = \aiu((l{\fromclause})_\Gamma, (l{\fromclause'})_\Gamma)$

			$\AIclause(C_\Gamma) =
			\lifboth{\Big( \clauseOnePrime \lor \clauseTwoPrime \Big)\sigma} \tau$.

			By Lemma~\ref{lemma:lift_logic_commute},
			$\AIclause(C_\Gamma) =
			\lifboth{\clauseOnePrime\sigma}\tau \lor \lifboth{\clauseTwoPrime\sigma} \tau$.

			By the induction hypothesis,
			$\Gamma \entails \AImatrix(C_i) \lor \AIclause({C_i}_\Gamma)$, $i\in\{1,2\}$, or expressed differently:


			$\Gamma \entails \AImatrix(C_1) \lor \clauseOnePrime \lor {(l{\fromclause})_\Gamma}$

			$\Gamma \entails \AImatrix(C_2) \lor \clauseTwoPrime \lor {\lnot (l{\fromclause'})_\Gamma}$

					By Lemma~\ref{lemma:no_colored_terms}, $\AImatrix(C_1)$ and $\AIclause(C_1)$ as well as $\AImatrix(C_2)$ and $\AIclause(C_2)$ do not contain colored terms.
					Hence by Lemma~\ref{lemma:substitute_and_lift}, Lemma~\ref{lemma:lift_logic_commute} and applying $\tau$, we get that 

					$\Gamma \stackrel{\markA}\entails \lifboth{\AImatrix(C_1)\sigma}\tau \lor \lifboth{\clauseOnePrime\sigma}\tau \lor \lifboth{(l{\fromclause})_\Gamma\sigma}\tau$

					$\Gamma \stackrel{\markB}\entails \lifboth{\AImatrix(C_2)\sigma}\tau \lor \lifboth{\clauseTwoPrime\sigma}\tau \lor \lnot \lifboth{(l{\fromclause'})_\Gamma\sigma}\tau$

			
			%Furthermore,
			%$\sigma = \mgu(l, l')$, so $\lifboth{l\sigma} = \lifboth{l'\sigma}$ and $\lifboth{l}\sigma' = \lifboth{l'}\sigma'$ by Lemma \ref{lemma:lift_subst_commute}.

			By Lemma~\ref{lemma:literals_clauses_equal}, $\lifboth{(l\fromclause)_\Gamma\sigma}\tau = \lifboth{(l{\fromclause'})_\Gamma\sigma} \tau$.

			\begin{itemize}
				\item If $l$ and $l'$ grey:

					$\AImatrix(C) =
					(\lnot {\lifboth{l\fromclause\sigma}\tau} \land \lifboth{\AImatrix(C_1)\sigma}\tau) \lor
					(\lifboth{l\fromclause\sigma}\tau \land \lifboth{\AImatrix(C_2)\sigma) }\tau
					$

					Suppose for a model $M$ of $\Gamma$ that $M \notentails \AIclause(C)$,
					i.e.~$M \notentails \lifboth{\AIclause(C_1)\sigma}\tau$ and $M \notentails\nolinebreak \lifboth{\AIclause(C_2)\sigma}\tau$ as otherwise we would be done.
					Then by \markA{} and \markB:

					$M \entails \lifboth{\AImatrix(C_1)\sigma}\tau \lor \lifboth{l{\fromclause}\sigma}\tau$

					$M \entails \lifboth{\AImatrix(C_2)\sigma}\tau \lor \lnot \lifboth{l{\fromclause'}\sigma}\tau$

					By Lemma~\ref{lemma:literals_clauses_equal}, $\lifboth{l\fromclause\sigma}\tau = \lifboth{l{\fromclause'}\sigma} \tau$.
					By a case distinction on the truth value of $\lifboth{l\fromclause\sigma}\tau$ in $M$, we obtain that $M \entails \AImatrix(C)$.


				\item If $l$ and $l'$ are $\Gamma$-colored:
					$\AImatrix(C) = \lifboth{\Big(\AImatrix(C_1) \lor \AImatrix(C_2)\Big)\sigma} \tau$

					By Lemma~\ref{lemma:literals_clauses_equal}, we can do a resolution step on $\lifboth{l\fromclause\sigma}\tau$ of \markA{} and \markB{} to arrive at 

					$\Gamma \entails \lifboth{\AImatrix(C_1)\sigma}\tau \spam\lor \lifboth{\clauseOnePrime\sigma}\tau\spam\lor 
					\lifboth{\AImatrix(C_2)\sigma}\tau\spam\lor \lifboth{\clauseTwoPrime\sigma}\tau $

					This however is by Lemma~\ref{lemma:lift_logic_commute} nothing else than
					$\Gamma \entails \AImatrix(C) \lor \AIclause(C)$

				\item If $l$ and $l'$ are $\Delta$-colored:
					$\AImatrix(C) = \lifboth{\Big(\AImatrix(C_1) \land \AImatrix(C_2)\Big)\sigma} \tau$

					As $l$ is $\Delta$-colored, \markA{} and \markB{} reduce to:

					$\Gamma \entails \lifboth{\AImatrix(C_1)\sigma}\tau \lor \lifboth{\clauseOnePrime\sigma}\tau$

					$\Gamma \entails \lifboth{\AImatrix(C_2)\sigma}\tau \lor \lifboth{\clauseTwoPrime\sigma}\tau$

					But this implies that 

					$\Gamma \entails \Big(\lifboth{\AImatrix(C_1)\sigma}\tau \land \lifboth{\clauseOnePrime\sigma}\tau\Big) 
\spam\lor \lifboth{\clauseOnePrime\sigma}\tau
\spam\lor \lifboth{\clauseTwoPrime\sigma}\tau$

					This however is by Lemma~\ref{lemma:lift_logic_commute} nothing else than 
					$\Gamma \entails \AImatrix(C) \lor \AIclause(C)$.
					\qedhere
			\end{itemize}

	\end{description}


\end{proof}


\clearpage
\section{thoughts}

\begin{conj}
	Double ended arrows are not important as terms are overbound with same variable anyway as always same unifier applies.
\end{conj}

\clearpage
\section{arrow proof}

\begin{lemma}
	\label{lemma:arrow_for_same_variables}
	Whenever the same variable appears multiple times in $\PI(C)\lor C$ for $C \in \pi$, there are arrows.

	\begin{itemize}
		\item If both variables are contained only in grey terms, there is a double arrow \comm{they unify to exactly the same}
		\item If only one variable is only contained in grey terms, there is an arrow from it to the other one \comm{either unify the one in grey term, then other one must be overbound later. if otherwise var in the colored term is unified, we can still overbind the grey one first. }
		\item otherwise there are weak arrows between them \comm{have same quantifier, so order does not matter, but want to keep dependencies on both the same}
	\end{itemize}
\end{lemma}
\begin{proof}
	By induction. Note: As required by resolution, all initial clauses are variable disjoint.

	Base case:
	In the initial clause sets, consider for a clause $C$ two different positions $p_1$ and $p_2$ pointing to the same variable. 
	Then either:
	\begin{itemize}
		\item $p_1$ and $p_2$ contain only grey symbols. Then $(p_1, p_2) \in \arr$.
		\item Only $p_i$, $i\in\{1,2\}$ contains only grey symbols. Then $(p_i, p_{(i \mod 2)+1}) \in \arr$.
		\item There are not only grey symbols in both $p_1$ and $p_2$, i.e.~both contain at least a colored symbol. Then $\{p_1, p_2\} \in \warr$. 
	\end{itemize}

	Induction step:
	Suppose a clause $C$ is the result of a resolution of $C_1: D \lor l$ and $C_2: E \lor \lnot l$ with $l\sigma = l'\sigma$.
	$\PI(C)$ is $[\PI(C_1) \circ \PI(C)]\sigma$ or $[(l \land \PI(C_2)) \lor (\lnot l \land \PI(C_1)) ] \sigma $.

	Assumption: $C_1$ and $C_2$ are variable disjoint, i.e.~variables are renamed in case $C_1$ and $C_2$ are derived from some common original clause and share variables.

	By the induction hypothesis, there are appropriate arrows in both $\PI(C_i) \lor C_i$, $i \in \{1,2\}$.

	If the variables were present in $C_1$ or $C_2$, the arrow is still there, either in $\PI(C)$ (in the case of $l$ or $l'$), $C$ (in case of $D$ and $E$) or in currently not shown literal (in case $l$ and $l'$ have the same color).

	Otherwise, it was introduced by unification in $l\sigma$ or $\PI(C_i)\sigma$.
	In this case, there is some term position $q$ in with $\pos(l).q$ a variable and $\pos(l').q$ a variable or a term containing variables (or other way around).
	Hence unification maps a variable to a variable or a term containing variables.
	The variable being unified is in $\PI(C_i)\lor C_i$ for some $i\in\{1,2\}$.
	But by the induction hypothesis, all occurrences of each variable does already have appropriate arrows, which are still present. 
\end{proof}



\begin{lemma}
	In $\PI(C)\lor C$ for $C \in \pi$, if there is a $\Delta$-colored term $s$ in a $\Gamma$-term $t$, then there is an arrow from $p_1$ to $p_2$ such that $\pos(p_1) = s$ and $\pos(p_2) = s$ and for some $i$, $\pos( p_2 \mod i ) = t$.
\end{lemma}
Note: $p_1$ might be in some clause, the prop interpolant or none of both. 
\begin{proof}
	By induction.

	Base case: There are no foreign terms in the initial clause sets, so no arrows necessary.

	Induction step:

	\begin{itemize}
		\item[Resolution.]
			Suppose a clause $C$ is the result of a resolution of $C_1: D \lor l$ and $C_2: E \lor \lnot l$ with $l\sigma = l'\sigma$.

			\begin{enumerate}
				\item Suppose $l$ is colored. 
					This case is similar to the grey one, with the exception that the cases applying to $l$ in $\PI$ do not apply.

				\item Suppose $l$ is grey. Then  $\PI(C) = [(l \land \PI(C_2)) \lor (\lnot l \land \PI(C_1)) ] \sigma $

					By the induction hypothesis, there are appropriate arrows in $\PI(C_1) \lor C_1$ and $\PI(C_2) \lor C_2$.

					We show that for all maximal $\Gamma$-terms in $\PI(C)\lor C$ with $\Delta$-terms in them which were not present in $\PI(C_i)\lor C_i$, $i \in \{1,2\}$, there is an arrow.

					$\Gamma$-terms and $\Delta$-terms are not unifiable.
					%Hence all pairs of terms $(t_1, t_2)$ in the same positions in $l$ and $l'$ (if both positions exist) are both grey, or w.l.o.g.~$t_1$ is a variable and $t_2$ is a colored/grey term.
					Hence all pairs of terms $(t_1, t_2)$ in the same positions in $l$ and $l'$ (if both positions exist) either point to the same symbol or (w.l.o.g.) $t_1$ is a variable and $t_2$ is a term.
					If there are $\Delta$-terms in $\Gamma$-terms in the prefix, they are present in both ancestors and handled by the induction hypothesis.

					The only way a $\Delta$-colored term may enter a $\Gamma$-colored term is in the situation where $t_1$ is a variable and $t_2$ a colored term.
					But then $\mgu(t_1, t_2)$ applied to $t_1$ yields $t_2$, i.e.~``the parts of $\sigma$ concerned with unifying $t_1$ and $t_2$'' do not introduce new $\Delta$-terms in $\Gamma$-terms.
					In other words, all such situation have been present in $\PI(C_i) \lor C_i$ for $i \in \{1,2\}$ and since the arrows for $l$ and $l'$ are merged, they are present for $l\sigma$ in $\PI(C)$.

					This handles the case where terms $t_1$ and $t_2$ are unified. 
					But unification also affects all other occurrences of variables, this means ``the parts of $\sigma$ not concerned with unifying $t_1$ and $t_2$''.
					The relevant case for this lemma is when a $\Gamma$-term contains a variable, that is substituted by a term containing $\Delta$-terms.
					But in this case, by Lemma \ref{lemma:arrow_for_same_variables}, there is an arrow from the other occurrence of the variable to the one in the $\Gamma$-term: either double arrow in $\arr$ if both prefixes are grey, one in $\arr$ if one of the prefixes is grey or one in $\warr$ if both prefixes contain a colored symbol.
					\qedhere
			\end{enumerate}
	\end{itemize}
\end{proof}


\end{document}
