\documentclass[,fontsize=10pt,%
	paper=27cm:25cm,% 
	%a4paper,
	%landscape,
	%DIV12, % mehr text pro seite als defaultyyp
	DIV22,
	%DIV=calc,%
	%twoside=false,%
	liststotoc,
	bibtotoc,
	draft=false,% final|draft % draft ist platzsparender (kein code, bilder..)
	%titlepage,
	numbers=noendperiod
]{scrartcl}


\usepackage{lscape}
\usepackage{stackengine}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}


%\input{../latex_header.tex}
\usepackage{bm}

%\usepackage[doublespacing]{setspace}
\usepackage[onehalfspacing]{setspace}
%\usepackage[singlespacing]{setspace}
\usepackage{comment}
\usepackage{color}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bussproofs}


\newcommand{\true}[0]{\textbf{1}}
\newcommand{\false}[0]{\textbf{0}}
\newcommand{\tr}{\true}
\newcommand{\fa}{\false}

\newcommand{\ra}{\rightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\La}{\Leftarrow}

\newcommand{\lra}{\leftrightarrow}
\newcommand{\Lra}{\Leftrightarrow}




\newcommand{\mymark}[1]{\ensuremath{(#1)}}
\newcommand{\markA}{\mymark \circ}
\newcommand{\markB}{\mymark *}
\newcommand{\markC}{\mymark \divideontimes}

\newcommand{\wrong}[1]{{\color{red}WRONG: #1}}
\newcommand{\NB}[1]{{\color{blue}NB: #1}}
\newcommand{\mytodo}[1]{{\color{red}TODO: #1}}
\newcommand{\largered}[1]{{

		    \LARGE\bfseries\color{red}
				    #1

				}}



\usepackage{tikz}
\usetikzlibrary{shapes,arrows,backgrounds,graphs,%
	matrix,patterns,arrows,decorations.pathmorphing,decorations.pathreplacing,%
	positioning,fit,calc,decorations.text,shadows%
}


\newcommand{\UICm}[1]{\UnaryInfCm{#1}}
\newcommand{\UnaryInfCm}[1]{\UnaryInfC{$#1$}}
\newcommand{\BICm}[1]{\BinaryInfCm{#1}}
\newcommand{\BinaryInfCm}[1]{\BinaryInfC{$#1$}}
\newcommand{\RightLabelm}[1]{\RightLabel{$#1$}}
\newcommand{\LeftLabelm}[1]{\LeftLabel{$#1$}}
\newcommand{\AXCm}[1]{\AxiomCm{#1}}
\newcommand{\AxiomCm}[1]{\AxiomC{$#1$}}
\newcommand{\mt}[1]{\textnormal{#1}}


\newcommand{\lkrule}[2]{\ensuremath{\operatorname{#1}:#2}} % operatorname fixes spacing issues for =

\newcommand{\parti}[4]{\ensuremath{ \langle (#1; #2), (#3; #4)\rangle  }}

\newcommand{\partisym}{\ensuremath{\chi}}

\newcommand{\occur}[1]{\ensuremath{[#1]}}
\newcommand{\occ}[1]{\occur{#1}}

\newcommand{\occurat}[2]{\ensuremath{{\occur{#1}_{#2}}}}
\newcommand{\occat}[2]{\occurat{#1}{#2}}

\newcommand{\colterm}[1]{\zeta_{#1}}



\newcommand{\UnaryInfm}[1]{\UnaryInf$#1$}
\newcommand{\BinaryInfm}[1]{\BinaryInf$#1$}
\newcommand{\Axiomm}[1]{\Axiom$#1$}


% http://tex.stackexchange.com/questions/35717/how-to-draw-arrows-between-parts-of-an-equation-to-show-the-math-distributive-pr
\tikzset{square arrow/.style={to path={ -- ++(.0,-.15)  -| (\tikztotarget)}}}
\tikzset{square arrow2/.style={to path={ -- ++(.0,-.25)  -| (\tikztotarget)}}}
%\tikzset{square arrow/.style={to path={ -- ++(00,-.01) -- ++(0.5,-0.1) -- ++(0.5,-0.1) -| (\tikztotarget)},color=red}}


% have arrows from a to b and from c to d here
% just use: texttext\arrowA texttest \arrowB texttext
\newcommand{\arrowA}{\tikz[overlay,remember picture] \node (a) {};}
\newcommand{\arrowB}{\tikz[overlay,remember picture] \node (b) {};}
\newcommand{\drawAB}{
	\tikz[overlay,remember picture]
	{\draw[->,bend left=5,color=red] (a.south) to (b.south);}
	%{\draw[->,square arrow,color=red] (a.south) to (b.south);}
}

\newcommand{\arrowAP}{\tikz[overlay,remember picture] \node (ap) {};}
\newcommand{\arrowBP}{\tikz[overlay,remember picture] \node (bp) {};}
\newcommand{\drawABP}{
	\tikz[overlay,remember picture]
	{\draw[->,bend right=5,color=red] (ap.south) to (bp.south);}
	%{\draw[->,square arrow,color=red] (ap.south) to (bp.south);}
}


\newcommand{\arrowAB}{\tikz[overlay,remember picture] \node (ab) {};}
\newcommand{\arrowBA}{\tikz[overlay,remember picture] \node (ba) {};}
\newcommand{\drawAABB}{
	\tikz[overlay,remember picture]
	%{\draw[->,bend left=80] (a.north) to (b.north);}
	{\draw[->,square arrow,color=brown] (ab.south) to (ba.south);
	\draw[->,square arrow,color=brown] (ba.south) to (ab.south);}
}


\newcommand{\arrowCD}{\tikz[overlay,remember picture] \node (cd) {};}
\newcommand{\arrowDC}{\tikz[overlay,remember picture] \node (dc) {};}
\newcommand{\drawCCDD}{
	\tikz[overlay,remember picture]
	%{\draw[->,bend left=80] (a.north) to (b.north);}
	{\draw[<->,dashed,square arrow,color=green] (cd.south) to (dc.south); }
}



\newcommand{\arrowC}{\tikz[overlay,remember picture] \node (c) {};}
\newcommand{\arrowD}{\tikz[overlay,remember picture] \node (d) {};}
\newcommand{\drawCD}{
	\tikz[overlay,remember picture]
	{\draw[->,square arrow,color=blue] (c.south) to (d.south);}
}

\newcommand{\arrowE}{\tikz[overlay,remember picture] \node (e) {};}
\newcommand{\arrowF}{\tikz[overlay,remember picture] \node (f) {};}
\newcommand{\drawEF}{
	\tikz[overlay,remember picture]
	{\draw[->,square arrow2,color=orange] (e.south) to (f.south);}
}


\newcommand{\arrAP}{\arrowAP}
\newcommand{\arrBP}{\arrowBP}



\newcommand{\arrA}{\arrowA}
\newcommand{\arrB}{\arrowB}
\newcommand{\arrC}{\arrowC}
\newcommand{\arrD}{\arrowD}
\newcommand{\arrE}{\arrowE}
\newcommand{\arrF}{\arrowF}

\newcommand{\refsub}[2]{\hyperref[#2]{\ref*{#1}.\ref*{#2}}}


%\def\fCenter{\ \proves\ }
\def\fCenter{\proves}



%\usepackage[square, authoryear]{natbib}
%\usepackage[language=english]{biblatex}

%\bibliographystyle{plain}
%\bibliographystyle{alphadin}
%\bibliographystyle{dinat}
%\bibliographystyle{chicago}
%\bibliographystyle{plainnat}

\renewcommand*{\partformat}{\partname\ \thepart\ -}
\let\partheadmidvskip\

\newcommand{\comp}{\ensuremath{\text{comp}}}
% smaller url style
\makeatletter
\def\url@leostyle{%
\@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
%\urlstyle{leo}

\newcommand{\myfig}[5] {
	\begin{figure}[tbph]
		\centering
		\includegraphics[#3]{#1}
		\caption[#4]{#5}
		\label{fig:#2}
	\end{figure}
}

\setlength{\parindent}{0em}
%\usepackage{thmtools} % actually already in latex_header.tex ...


%\newcommand{\sig}[1]{{#1}_\Sigma}
%\newcommand{\p}[1]{{#1}_\Pi}
\newcommand{\sig}[1]{\stackrel{\Sigma}{#1}}
\newcommand{\p}[1]{\stackrel{\Pi}{#1}}

\newcommand{\e}[1]{\vskip .7em   \subsection*{#1}}

\def\proofSkipAmount{ \vskip -1em}

\begin{document}

\newcommand{\ha}[1]{ {\color{red} #1} }
\newcommand{\hb}[1]{ {\color{blue} #1} }
\newcommand{\hc}[1]{ {\color{violet} #1} }
\section*{border cases: arrows not within supposedly connected components}

\e{211a}

\begin{prooftree}
	\AxiomCm{Q(\hb x) \lor P(f(\hb x, a))}
	\AxiomCm{\lnot Q(\ha y) \lor R(f(\ha y, b))}
	\BinaryInfCm{Q(\arrowA\,\arrowE x) \mid P(\arrowB f(x, a))  \lor R(\arrowF f(x, b))}\drawAB\drawEF
	\noLine\UnaryInfC{}\noLine\UnaryInfC{$\Ra$ no arr between $P$ and $R$}
\end{prooftree}

\e{211a'}

\begin{prooftree}
	\AxiomCm{\sig{Q(\hb x) \lor P(f(\hb x, a))}}
	\AxiomCm{\sig{\lnot Q(\ha y) \lor R(f(\ha y, b))}}
	\BinaryInfCm{Q(\arrowA\,\arrowE x) \mid P(\arrowB f(x, a))  \lor R(\arrowF f(x, b))}\drawAB\drawEF
	\noLine\UnaryInfC{}

	\AxiomCm{\sig{ \lnot P(\arrowD f(\hc u, z)) \lor S(\arrowC \hc u))}} \drawCD
	\noLine\UnaryInfC{}
	\AxiomCm{\p{\lnot S(c) }}
	\BinaryInfCm{{ S(\arrowC c) \mid \lnot P(\arrowD f(c, z)) }} \drawCD
	\noLine\UnaryInfC{}
	\BinaryInfCm{ (P(f(c, a) \land S(c)) \lor (\lnot P(f(c, a)) \land Q(c))) \mid R(f(c, b))}
\end{prooftree}

\begin{multicols}{6}
$ c \sim x_1$

$ f(c, a) \sim y_2$

$ f(c, b) \sim y_3$
\end{multicols}
$ (P(\arrowD y_2) \land S(\arrowC x_1)) \lor (\lnot P(\arrowF y_2) \land Q(\arrowA\,\arrowE x_1)) \mid R(\arrowB y_3) $ \drawAB \drawEF \drawCD NOTE: arrow merge on resolution is not drawn here (but is necessary)

$ \forall x_1 \exists y_2 \exists y_3$

this is not valid per se as the left hand side only contains $\Sigma$-formulas, but it probably could be fixed by adding some $\Pi$-inferences

Lesson is: no extra arrows needed, if a term enters, it does so via $x$, but there is a variable from the grey $x$ to both colored $x$.

\e{211b}
\begin{prooftree}
	\AxiomCm{Q(\hb x) \lor P(f(\hb x))}
	\AxiomCm{R(\ha y) \lor \lnot P(f(\ha y))}
	\BinaryInfCm{ P(\arrowB\,\arrowF f(x)) \mid Q(\arrowA x) \lor R(\arrowE x)  }\drawAB\drawEF
	\noLine\UnaryInfC{}\noLine\UnaryInfC{$\Ra$ no arr between $Q$ and $R$}
\end{prooftree}
\NB{should be fixed by backwards merging special case}

\e{211b'}
\begin{prooftree}
	\AxiomCm{\sig{Q(\hb x) \lor P(f(\hb x))}}
	\AxiomCm{\sig{R(\ha y) \lor \lnot P(f(\ha y))}}
	\BinaryInfCm{ P(\arrowB\,\arrowF f(x)) \mid Q(\arrowA x) \lor R(\arrowE x)  }\drawAB\drawEF
	\noLine\UnaryInfC{}
	\AxiomCm{\p{\lnot Q(a)}}
	\BinaryInfCm{ P(\arrowB\,\arrowF f(a)) \lor  Q(\arrowA a) \mid  R(\arrowE a)  }\drawAB\drawEF
	\noLine\UnaryInfC{}\noLine\UnaryInfC{\wrong{conjecture: $Q$ and $R$ do not need arrows as they are lifted by the same variable anyway, so constraints on $Q$ do the work}}
\end{prooftree}

\e{211c}
\begin{prooftree}
	\AxiomCm{ \sig{ Q(\arrowB f(x))\lor R(\arrowA x) } }\drawAB
	\noLine\UnaryInfC{}
	\AxiomCm{ \p{ \lnot R(g(y)) } }
	\BinaryInfCm{ Q(\arrowB f(g(y))) \lor R(\arrowA g(y)) }\drawAB
	\noLine\UnaryInfC{}
\end{prooftree}
Have same var but no merge arrow. The whole term $g(y)$ is somehow the ``travelling term'', there is no ``renaming''.

\e{211d -- problem cases with lemma grey->colored}

{\color{red} currently not clear what the connetion between the arguments of $R$ on the RHS is}
If we use factorisation, not sure how to handle yet, but could be like: $R(\arrD t\occ{x}, \arrB s\occ{x}) \lor Q(\arrowA\,\arrowC x)$ \drawAB \drawCD


~

\begin{prooftree}
	\AxiomCm{ Q(\arrA\,\arrC y) \lor Q'(\arrE z) \lor P(\arrB f(y)) \lor R(\arrD g(y), \arrF g'(z)) } \drawAB \drawEF\drawCD
	\noLine\UnaryInfC{}
	\AxiomCm{ \lnot R(g(h(x)), g'(x)) }
	\noLine\UnaryInfC{}
	\RightLabelm{y \mapsto h(x), z \mapsto x}
	\BinaryInfCm{ R(g(h(x)), g'(x)) \mid Q( h(x)) \lor Q'(x) \lor P(f(h(x))) }
	\noLine\UnaryInfC{\NB{this is different since $x$ occurs grey as well (example not finished)}}
\end{prooftree}


~

~

Problem case 1: $x$ grey and colored, but not connection

~

\begin{prooftree}
	\AxiomCm{  Q'(\arrA z) \lor P(\arrC f(y)) \lor R(\arrD g(f(y)), \arrB g'(z)) } \drawAB\drawCD
	\noLine\UnaryInfC{}
	\AxiomCm{ \lnot R(g(f(h(x))), g'(x)) }
	\noLine\UnaryInfC{}
	\RightLabelm{y \mapsto h(x), z \mapsto x}
	\BinaryInfCm{ R(\arrD g(f(h(x))), \arrB g'(x)) \mid Q\arrA ( x) \lor  P(\arrC f(h(x))) } \drawAB\drawCD
	\noLine\UnaryInfC{}
	\noLine\UnaryInfC{\NB{no connection between Q and P}}
	\noLine\UnaryInfC{{$\Ra$ backwards merging }}
\end{prooftree}


Problem case 2: $x$ colored and colored, not sure what the connection is supposed to be

~

\begin{prooftree}
	\AxiomCm{ Q'(\arrA k(z)) \lor  P(f(y)) \lor R(g(y), \arrB g'(z)) } \drawAB 
	\noLine\UnaryInfC{}
	\AxiomCm{ \lnot R(g(h(x)), g'(x)) }
	\noLine\UnaryInfC{}
	\RightLabelm{y \mapsto h(x), z \mapsto x}
	\BinaryInfCm{ R(\arrB g(h(x)), g'(x)) \mid Q'(\arrA k(x)) \lor P(f(h(x))) } \drawAB
\end{prooftree}


\clearpage

\section*{lifting var doesn't correspond to actual term exactly in context of  unifier arrows}

\e{212a}

\begin{prooftree}
	\AxiomCm{ \sig{Q(u) \lor  \lnot P(h(u)) } }

	\AxiomCm{ \p{ R(g(x)) \lor S(x) } }
	\AxiomCm{ \p{ \lnot S(a) } }

	\RightLabelm{ x\mapsto a}
	\BinaryInfCm{ S(a) \mid \mid R(g(a)) }

	\AxiomCm{ \sig{ P(h(f(y))) \lor \lnot R(y) } }

	\RightLabelm{ y\mapsto g(a)}
	\BinaryInfCm{ S(a) \mid R(g(a)) \mid P(h(f(g(a)))) }

	\RightLabelm{ u\mapsto g(f(g(a)))}
	\BinaryInfCm{ S(a) \mid R(g(a)),  P(h(f(g(a)))) \mid Q(f(g(a))) }

\end{prooftree}

lifted:
\begin{prooftree}
	\AxiomCm{ \sig{Q(u) \lor  \lnot P(y_{h(u)}) } }

	\AxiomCm{ \p{ R(x_{g(x)}) \lor S(x) } }
	\AxiomCm{ \p{ \lnot S(x_a) } }

	\RightLabelm{ x\mapsto a}
	\BinaryInfCm{ S(x_a) \mid \mid R(x_{g(x)}) }

	\AxiomCm{ \sig{ P(y_{h(f(y))}) \lor \lnot R(y) } }

	\RightLabelm{ y\mapsto g(a)\; \bm\ast}
	\BinaryInfCm{ S(x_a) \mid R(x_{g(a)}) \mid P(y_{h(f(y))}) }

	\RightLabelm{ u\mapsto g(f(g(a)))}
	\BinaryInfCm{ S(x_a) \mid R(x_{g(a)}),  P(y_{h(f(g(a)))}) \mid Q(y_{f(g(a))}) }

\end{prooftree}

\textbf{at $\bm\ast$, $R(x_g(x))$ is not known to refer to $g(a)$. can we resort to check grey occurrences of $g(a)$?}

\textbf{need arrow from $R$ to $P$ (this situation should be more critical if it is a backwards arrow)}

\textbf{thought: concerns only stuff in literal, maybe can leverage something here (all lifting vars $x_i$ point to same term or so)}

\e{212b -- same but more info not present}

\begin{prooftree}
	\AxiomCm{ \p{ R(g'(g(x))) \lor S(x) } }
	\AxiomCm{ \p{ \lnot S(a) } }

	\RightLabelm{ x\mapsto a}
	\BinaryInfCm{ S(a) \mid \mid R(g'(g(a))) }

	\AxiomCm{ \sig{ P({h(f(y))}) \lor \lnot T(y) } }
	\AxiomCm{ \p{ T(z) \lor \lnot R(g'(z))}}
	\RightLabelm{ z\mapsto y}

	\BinaryInfCm{ T(y) \mid P({h(f(y))}) \lor \lnot R(g'(y)) }

	\RightLabelm{y \mapsto g(a)\;\bm\ast}

	\BinaryInfCm{ S(a) \mid \lnot R(g'(g(a))) \lor T(g(a)) \mid P(h(f(g(a))))   }
\end{prooftree}

lifted w unifier arrows:

\begin{prooftree}
	\AxiomCm{ \p{ R(x_{g'(g(x))}) \lor S(x) } }
	\AxiomCm{ \p{ \lnot S(x_a) } }

	\RightLabelm{ x\mapsto a}
	\BinaryInfCm{ S(x_a) \mid \mid R(x_{g'(g(x))}) }

	\AxiomCm{ \sig{ P(y_{h(f(y))}) \lor \lnot T(y) } }
	\AxiomCm{ \p{ T(z) \lor \lnot R(x_{g'(z)})}}
	\RightLabelm{ z\mapsto y}

	\BinaryInfCm{ T(y) \mid P(y_{h(f(y))}) \lor \lnot R(x_{g'(y)}) }

	\RightLabelm{y \mapsto g(a)\;\bm\ast}

	\BinaryInfCm{ S(x_a) \mid \lnot R(x_{g'(g(a))}) \lor T(x_{g(a)}) \mid P(y_{h(f(y))})    }
\end{prooftree}

\textbf{$\bm\ast$ is similar here, but the grey occurrence of $y$ isn't even in the literal}

\clearpage

\e{212c -- other approach}

\begin{prooftree}
	\AxiomCm{ \sig{ P(f(x), u) \lor Q(x) \lor R(u) }}
	\AxiomCm{ \p{\lnot Q(g(z)) \lor R(z) }}
	\RightLabelm{ x\mapsto g(z)}
	\BinaryInfCm{ Q(\arrowAP g(z)) \mid P(\arrowBP f(g(z)), u) \lor R(u) \lor R(z) } \drawABP
	\RightLabelm{ u\mapsto z}
	\UnaryInfCm{ Q(\arrowAP g(z)) \mid P(\arrBP f(g(z)), z) \lor R(z) }\drawABP

	\AxiomCm{ \sig{ \mathbf S(h(u)) \lor \lnot P(f(u), c) } }
	\RightLabelm{ u\mapsto g(c), z\mapsto c}
	\BinaryInfCm{ P(\arrowB f(g(c)), c) \mid Q(\arrowA\,\arrE g(c)) \mid S(\arrF h(g(c))) \lor R(c) } \drawAB\drawEF
	\noLine\UnaryInfC{}
	\noLine\UnaryInfC{(arrows for $c$ not shown)}

\end{prooftree}
(the bold $S$ receives the $\Delta$-term here, the rest is technical details. it's about how $S$ receives the arrow)

lifted:
\begin{prooftree}
	\AxiomCm{ \sig{ P(y_{f(x)}, u) \lor Q(x) \lor R(u) }}
	\AxiomCm{ \p{\lnot Q(x_{g(z)}) \lor R(z) }}
	\BinaryInfCm{ Q(x_{g(z)}) \mid P(y_{f(g(z))}, u) \lor R(u) \lor R(z) }
	\UnaryInfCm{ Q(x_{g(z)}) \mid P(y_{f(g(z)}), z) \lor R(z) }

	\AxiomCm{ \sig{ S(y_{h(u)}) \lor \lnot P(y_{f(u)}, y_c) } }
	\BinaryInfCm{ P(y_{f(g(c))}, y_c) \mid Q(x_{g(z)}) \mid S(y_{h(u)})) \lor R(y_c) }

\end{prooftree}

{\color{red}\bfseries

{Need arrow to $S$. possibly work in $C$, not lifted variants.}

{Problem 2: lifting var in $P$ is updated, but the one in $Q$ is not, hence index of lifting vars don't match, which per se isn't a problem}

}

$\Delta$-lifted:
\begin{prooftree}
	\AxiomCm{ \sig{ P(f(x), u) \lor Q(x) \lor R(u) }}
	\AxiomCm{ \p{\lnot Q(x_{g(z)}) \lor R(z) }}
	\BinaryInfCm{ Q(x_{g(z)}) \mid P(f(x_{g(z)}), u) \lor R(u) \lor R(z) }
	\UnaryInfCm{ Q(x_{g(z)}) \mid P(f(x_{g(z)}), z) \lor R(z) }

	\AxiomCm{ \sig{ S(h(u)) \lor \lnot P(f(u), c) } }
	\BinaryInfCm{ P(f(x_{g(c)}), y_c) \mid Q(x_{g(c)}) \mid S(h(x_{g(c)})) \lor R(c) }
	\noLine\UnaryInfC{ \textbf{ lifting var in $Q$ is fixed here } }

\end{prooftree}





\clearpage

\section*{term unified which is just produced}
~
\begin{prooftree}
	\AxiomCm{ P(g(x), x) }
	\AxiomCm{ \lnot P(y, a) }
	\RightLabelm{y \mapsto g(a), x\mapsto a}
	\BinaryInfCm{ P(g(a), a) }
\end{prooftree}

$\Ra$ can only add arrow from terms in $C$, as they do not exist before.

~

~

\section*{old examples with unifier arrows}

\e{214a (210f)}

\begin{prooftree}
  \AxiomCm{\sig{\bot \mid P(f(\ha x)) \lor Q(\ha x)}}
  \AxiomCm{\sig{\bot \mid \lnot Q(\hb y) \lor R(g(\hb y))}}
	\RightLabelm{ y\mapsto x }
  \BinaryInfCm{ Q(x) \mid \bot \mid P(f(x)) \lor R(g(x)) }
  \AxiomCm{ \sig{\bot \mid \lnot P(f(\hc z)) \lor S(\hc z)}}
  \AxiomCm{ \p{\top \mid \lnot S(a)}}
	\RightLabelm{ z\mapsto a}
  \BinaryInfCm{ S(a) \mid \lnot P(f(a))} 
  %\noLine\UnaryInfC{}
	\RightLabelm{ x\mapsto a}
  \BinaryInfCm{ Q(a), P(f(a) \mid  S(a)  \mid R(g(a))}
  \AxiomCm{\p{\top \mid \lnot R(u)}}
  \BinaryInfCm{ Q(a), P(f(a)) \mid  S(a) \lor  R(g(a))}
\end{prooftree}


what if different starting point:
\begin{prooftree}
	\AxiomCm{ \sig{\bot \mid P(f(x)) \lor R(g(x)) } }
  \AxiomCm{ \sig{\bot \mid \lnot P(f(\hc z)) \lor S(\hc z)}}
  \AxiomCm{ \p{\top \mid \lnot S(a)}}
	\RightLabelm{ z\mapsto a}
  \BinaryInfCm{ S(\arrowA a) \mid \lnot P(\arrowB f(a))} 
  %\noLine\UnaryInfC{}
	\RightLabelm{ x\mapsto a}
  \BinaryInfCm{  P(f(a) \mid  S(a)  \mid R(g(a))}
  \AxiomCm{\p{\top \mid \lnot R(u)}}
	\BinaryInfCm{  P(f(a)) \mid  S(a) \lor  R(g(a))}
\end{prooftree}

\clearpage

More special cases from proof:

\e{215a}


\begin{prooftree}
	\AxiomCm{ P(f(g(v)), f(v)  ) }
	\AxiomCm{ \lnot P(f(g(a)), f(u) ) \lor S(h(u))}
	\BinaryInfCm{ P(f(g(a)), f(a)) \mid S(h(a)) }
	\noLine\UnaryInfC{need arrow to $S$}
\end{prooftree}

prequel to this situation:

RHS:
\begin{prooftree}
	\AxiomCm{ \p{R(g(a))} }
	\AxiomCm{ \sig{\lnot R(x) \lor \lnot P(f(x), f(u)) \lor S(h(u))} }
	\BinaryInfCm{ \lnot R(g(a)) \mid \lnot P(f(g(a)), f(u)) \lor S(h(u))} 
\end{prooftree}

LHS1:
\begin{prooftree}
	\AxiomCm{ \sig{ R(y) \lor  P(f(y), f(v)) \lor Q(v) } }
	\AxiomCm{ \p{ \lnot R(g(z)) \lor Q(z)}}
	\BinaryInfCm{ R(g(z)) \mid P(f(g(z)), f(v)) \lor Q(v) \lor Q(z) }
	\UnaryInfCm{ R(g(v)) \mid P(f(g(v)), f(v)) \lor Q(v) }
	\noLine\UnaryInfC{ $\Ra$ have grey occ of v, it is only a problem if there isn't one}
\end{prooftree}




\end{document}
